<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Golang源码学习之sort</title>
      <link href="/2021/03/23/Golang%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8Bsort/"/>
      <url>/2021/03/23/Golang%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8Bsort/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍go语言sort包内部分排序函数的实现，学习如何在实际的工业代码中如何应用那些基础的排序算法。</p><h1 id="Sort方法"><a href="#Sort方法" class="headerlink" title="Sort方法"></a>Sort方法</h1><p>sort包内的Sort方法位于源文件<code>sort/sort.go</code>，是一个通用的非稳定排序的方法。</p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><p>函数签名</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span></span><br></pre></td></tr></table></figure><p>go由于没有泛型，要实现通用排序只能另辟蹊径。<br>sort使用接口类型<code>sort.Interface</code>作为方法参数，<code>sort.Interface</code>接口定义了交换和比较的方法，按照比较方法的结果进行排序。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type<span class="built_in"> Interface interface </span>&#123;</span><br><span class="line">Len() int</span><br><span class="line">Less(i, j int) bool</span><br><span class="line">Swap(i, j int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sort方法实现"><a href="#Sort方法实现" class="headerlink" title="Sort方法实现"></a>Sort方法实现</h2><p>一般不稳定排序我们会先考虑快排，不过需要解决以下两个问题：</p><ul><li>如何避免递归调用过深</li><li>如何避免最差情况时间复杂度</li></ul><p>下面我们看一下go源码中使用了什么方法来解决这些问题，以及它使用了哪些优化手段。</p><a id="more"></a><h3 id="quickSort函数"><a href="#quickSort函数" class="headerlink" title="quickSort函数"></a>quickSort函数</h3><p>Sort方法内部调用了quickSort函数，主要逻辑在该函数中</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func quickSort(data Interface, <span class="selector-tag">a</span>, <span class="selector-tag">b</span>, maxDepth int)</span><br></pre></td></tr></table></figure><p>a,b传进来的是(0,data.Len())，对应的排序范围为[a, b)<br>maxDepth传进来的是根据Len计算出来的对数值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// quickSort方法体</span></span><br><span class="line"><span class="keyword">for</span> b - a &gt; <span class="number">12</span> &#123;</span><br><span class="line"><span class="keyword">if</span> maxDepth == <span class="number">0</span> &#123;</span><br><span class="line">heapSort(<span class="keyword">data</span>, a, b)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">maxDepth--</span><br><span class="line"><span class="comment">// 以下为快排逻辑，下文会讲到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b - a &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// 步长为6的shell排序</span></span><br><span class="line"><span class="keyword">for</span> i := a + <span class="number">6</span>; i &lt; b; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">data</span>.Less(i, i-<span class="number">6</span>) &#123;</span><br><span class="line"><span class="keyword">data</span>.Swap(i, i-<span class="number">6</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line">insertionSort(<span class="keyword">data</span>, a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>quickSort是一个递归的方法，以上代码主要关注出口的逻辑</p><ul><li>当maxDepth为0时，为了避免继续递归产生很深的调用栈，源码使用了堆排序对子序列进行排序</li><li>当子序列长度小于等于12，此时会先用步长为6的shell排序预处理，然后使用插入排序对子序列排序</li></ul><p>以上两步优化，限制了调用栈深度，加速了短的子序列的排序</p><p>快排流程</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">b</span> - <span class="selector-tag">a</span> &gt; <span class="number">12</span> &#123;</span><br><span class="line"><span class="comment">// 省略了上面讲到的代码</span></span><br><span class="line">maxDepth--</span><br><span class="line">mlo, mhi := doPivot(data, <span class="selector-tag">a</span>, b)</span><br><span class="line"><span class="keyword">if</span> mlo-<span class="selector-tag">a</span> &lt; b-mhi &#123;</span><br><span class="line">quickSort(data, <span class="selector-tag">a</span>, mlo, maxDepth)</span><br><span class="line"><span class="selector-tag">a</span> = mhi</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">quickSort(data, mhi, <span class="selector-tag">b</span>, maxDepth)</span><br><span class="line"><span class="selector-tag">b</span> = mlo</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次循环会处理一部分子任务，所以深度需要减一<br>doPivot函数对子序列进行交换，使得左边元素的值小于右边，相同元素放在中间，返回等于pivot和大于pivot的第一个元素位置<br>每次处理长度较小的子序列，做这一步目的应该是为了避免递归深度太深，下一次循环处理剩余的子序列</p><h4 id="doPivot方法"><a href="#doPivot方法" class="headerlink" title="doPivot方法"></a>doPivot方法</h4><p>这个方法略为复杂，主要干了以下三件事</p><ul><li>优化取pivot，使用了三值取中间值的优化方法</li><li>交换元素，使得左边元素小于pivot右边元素大于pivot</li><li>优化相等的元素，尽可能使相等元素放中间，同时找到左右边界</li></ul><p>取pivot</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">m</span> := <span class="keyword">int</span>(uint(<span class="keyword">lo</span>+<span class="keyword">hi</span>) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">// 对于很长的子序列，会先从三个位置的周围寻找中值</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">hi</span>-<span class="keyword">lo</span> &gt; <span class="number">40</span>&#123;</span><br><span class="line">s := (<span class="keyword">hi</span> - <span class="keyword">lo</span>) / <span class="number">8</span></span><br><span class="line">medianOfThree(data, <span class="keyword">lo</span>, <span class="keyword">lo</span>+s, <span class="keyword">lo</span>+<span class="number">2</span>*s)</span><br><span class="line">medianOfThree(data, <span class="keyword">m</span>, <span class="keyword">m</span>-s, <span class="keyword">m</span>+s)</span><br><span class="line">medianOfThree(data, <span class="keyword">hi</span>-<span class="number">1</span>, <span class="keyword">hi</span>-<span class="number">1</span>-s, <span class="keyword">hi</span>-<span class="number">1</span>-<span class="number">2</span>*s)</span><br><span class="line">&#125;</span><br><span class="line">// medianOfThree会对这三个进行比较，最终的结果是data[<span class="keyword">m</span>]&lt;data[<span class="keyword">lo</span>]&lt;data[<span class="keyword">hi</span>-<span class="number">1</span>]</span><br><span class="line">// pivot在<span class="keyword">lo</span>位置上</span><br><span class="line">medianOfThree(data, <span class="keyword">lo</span>, <span class="keyword">m</span>, <span class="keyword">hi</span>-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>交换元素</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pivot</span> := lo</span><br><span class="line"><span class="title">a</span>, c := lo+<span class="number">1</span>, hi<span class="number">-1</span> // lo和hi<span class="number">-1</span>都交换过，后面不需要再交换，再处理相等的时候再考虑</span><br><span class="line">// 跳过小于pivot的元素</span><br><span class="line"><span class="title">for</span> ; a &lt; c &amp;&amp; <span class="class"><span class="keyword">data</span>.<span class="type">Less</span>(<span class="title">a</span>, <span class="title">pivot</span>); a++&#123;&#125;</span></span><br><span class="line"><span class="title">b</span> := a // b指向第一个大于等于pivot的元素</span><br><span class="line"><span class="title">for</span> &#123;</span><br><span class="line">// <span class="class"><span class="keyword">data</span>[b] &lt;= pivot，找到第一个大于pivot的位置b</span></span><br><span class="line">for ; b &lt; c &amp;&amp; !<span class="class"><span class="keyword">data</span>.<span class="type">Less</span>(<span class="title">pivot</span>, <span class="title">b</span>); b++ &#123; </span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line">// c起始位置在hi<span class="number">-1</span>，而hi<span class="number">-1</span>已经调整过</span><br><span class="line">// <span class="class"><span class="keyword">data</span>[c-1] &gt; pivot，找到第一个小于等于pivot的右边位置</span></span><br><span class="line">for ; b &lt; c &amp;&amp; <span class="class"><span class="keyword">data</span>.<span class="type">Less</span>(<span class="title">pivot</span>, <span class="title">c</span>-1); c<span class="comment">-- &#123;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b &gt;= c &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">// <span class="class"><span class="keyword">data</span>[b] &gt; pivot; <span class="keyword">data</span>[c-1] &lt;= pivot</span></span><br><span class="line"><span class="class"><span class="keyword">data</span>.<span class="type">Swap</span>(<span class="title">b</span>, <span class="title">c</span>-1)</span></span><br><span class="line">b++ // <span class="class"><span class="keyword">data</span>[b-1] &lt;= pivot</span></span><br><span class="line">c<span class="comment">-- // data[c] &gt; pivot</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段交换逻辑主要是理解b和c指向的位置<br>b经过第一个for循环，总是指向一个大于pivot的元素或者结束位置，遇到相等元素会跳过<br>c经过第二个for循环，总是指向小于等于pivot元素的右边，所以后面交换的位置是c-1<br>循环结束之后，b和c相等。c如果有移动，那么指向大于pivot的第一个元素，否则指向hi-1</p><p>移动相等元素</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">protect</span> := hi-c &lt; <span class="number">5</span> // 如果大于pivot的元素小于<span class="number">5</span>个认为划分有倾斜，小于等于的一侧可能有相等元素</span><br><span class="line">// 如果没有倾斜，尝试检查三个位置是否有相等元素</span><br><span class="line"><span class="title">if</span> !protect &amp;&amp; hi-c &lt; (hi-lo)/<span class="number">4</span> &#123;</span><br><span class="line">dups := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> !<span class="class"><span class="keyword">data</span>.<span class="type">Less</span>(<span class="title">pivot</span>, <span class="title">hi</span>-1) &#123; // 之前没有检查过，不过相等的概率比较低</span></span><br><span class="line"><span class="class"><span class="title">data</span>.<span class="type">Swap</span>(<span class="title">c</span>, <span class="title">hi</span>-1)</span></span><br><span class="line"><span class="class"><span class="title">c</span>++</span></span><br><span class="line"><span class="class"><span class="title">dups</span>++</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="keyword">if</span> !<span class="class"><span class="keyword">data</span>.<span class="type">Less</span>(<span class="title">b</span>-1, <span class="title">pivot</span>) &#123; // 检查边界左边元素</span></span><br><span class="line"><span class="class"><span class="title">b</span><span class="comment">--</span></span></span><br><span class="line"><span class="class"><span class="title">dups</span>++</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line">// 小于等于的元素范围占<span class="number">3</span>/<span class="number">4</span>以上，那么中间元素也在小于等于范围内</span><br><span class="line"><span class="keyword">if</span> !<span class="class"><span class="keyword">data</span>.<span class="type">Less</span>(<span class="title">m</span>, <span class="title">pivot</span>) &#123;</span></span><br><span class="line"><span class="class"><span class="title">data</span>.<span class="type">Swap</span>(<span class="title">m</span>, <span class="title">b</span>-1)</span></span><br><span class="line"><span class="class"><span class="title">b</span><span class="comment">--</span></span></span><br><span class="line"><span class="class"><span class="title">dups</span>++</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line">protect = dups &gt; <span class="number">1</span> // 如果有<span class="number">2</span>个相等元素</span><br><span class="line">&#125;</span><br><span class="line">// 主要的移动逻辑</span><br><span class="line"><span class="title">if</span> protect &#123;</span><br><span class="line">for &#123;</span><br><span class="line">// for: <span class="class"><span class="keyword">data</span>[b] == pivot</span></span><br><span class="line">for ; a &lt; b &amp;&amp; !<span class="class"><span class="keyword">data</span>.<span class="type">Less</span>(<span class="title">b</span>-1, <span class="title">pivot</span>); b<span class="comment">--&#123;</span></span></span><br><span class="line">&#125;</span><br><span class="line">// after for: <span class="class"><span class="keyword">data</span>[b-1]&lt;pivot</span></span><br><span class="line">// for: <span class="class"><span class="keyword">data</span>[a] &lt; pivot</span></span><br><span class="line">for ; a &lt; b &amp;&amp; <span class="class"><span class="keyword">data</span>.<span class="type">Less</span>(<span class="title">a</span>, <span class="title">pivot</span>); a++ &#123;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line">// after for: <span class="class"><span class="keyword">data</span>[a] == pivot</span></span><br><span class="line"><span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">data</span>.<span class="type">Swap</span>(<span class="title">a</span>, <span class="title">b</span>-1)</span></span><br><span class="line">a++</span><br><span class="line">b<span class="comment">--</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否需要找相同元素根据划分的倾斜情况来，对于长的子序列会根据比例判断是否需要寻找相同元素<br>最后的for循环检查小于等于的元素，把相等元素移动到中间，结束之后a向右移，b向左移</p><p>最后交换pivot，返回pivot位置和大于pivot的第一个位置</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span>.<span class="type">Swap</span>(<span class="title">pivot</span>, <span class="title">b</span>-1) </span></span><br><span class="line"><span class="title">return</span> b<span class="number">-1</span>, c</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Sort方法做了以下优化来控制调用深度、避免最坏时间复杂度以及加速短序列排序</p><ul><li>使用maxDepth控制递归深度，每处理一个子序列maxDepth减一，当maxDepth为0时采用堆排序</li><li>在快排中使用了三位置取中值的优化，避免最坏时间复杂度；元素交换之后尝试把相等元素移动到中间，减少子序列范围</li><li>当子序列长度小于12，使用shell排序预处理，然后用插入排序优化短序列排序</li></ul><p>虽然快排本身看起来简单，要在工业软件中使用，还是需要做许多优化的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大数据工作流组件oozie简介</title>
      <link href="/2021/01/31/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%BB%84%E4%BB%B6oozie%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/01/31/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%BB%84%E4%BB%B6oozie%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>Oozie是一个管理 Apache Hadoop 作业的工作流调度系统。</p><p>Oozie的 workflow jobs 是由 actions 组成的 有向无环图(DAG)。</p><p>Oozie的 coordinator jobs 是由时间 (频率)和数据可用性触发的重复的 workflow jobs 。</p><p>Oozie与Hadoop生态圈的其他部分集成在一起，支持多种类型的Hadoop作业（如Java map-reduce、流式map-reduce、Pig、Hive、Sqoop和Distcp）以及特定于系统的工作（如Java程序和shell脚本），不同作业对应不同的workflow action。</p><a id="more"></a><h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><p>Workflow：工作流，由我们需要处理的每个工作组成。</p><p>Coordinator：协调器，根据条件触发工作流执行，支持周期触发和检测数据是否准备好。</p><p>Bundle：将一堆的coordinator进行汇总处理。</p><h3 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h3><p><img src="images/16120697407602.jpg" alt=""></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>job的组成</p><ul><li>job.properties 记录了job的属性</li><li>workflow.xml 使用hPDL 定义任务的流程和分支</li><li>lib目录 用来执行具体的任务</li><li>coordinator.xml 定义调度策略</li></ul><h3 id="job-properties"><a href="#job-properties" class="headerlink" title="job.properties"></a>job.properties</h3><table><thead><tr><th>KEY</th><th>含义</th></tr></thead><tbody><tr><td>nameNode</td><td>HDFS地址</td></tr><tr><td>jobTracker</td><td>jobTracker（ResourceManager）地址</td></tr><tr><td>queueName</td><td>Oozie队列（默认填写default）</td></tr><tr><td>oozie.usr.system.libpath</td><td>是否加载用户lib目录（true/false）</td></tr><tr><td>oozie.libpath</td><td>用户lib库所在的位置</td></tr><tr><td>oozie.wf.application.path</td><td>Oozie流程所在hdfs地址（workflow.xml所在的地址）</td></tr><tr><td>user.name</td><td>当前用户</td></tr><tr><td>oozie.coord.application.path</td><td>Coordinator.xml地址（没有可以不写）</td></tr><tr><td>oozie.bundle.application.path</td><td>Bundle.xml地址（没有可以不写）</td></tr></tbody></table><h3 id="workflow-xml"><a href="#workflow-xml" class="headerlink" title="workflow.xml"></a>workflow.xml</h3><p><img src="images/16120697594642.jpg" alt=""></p><p>包含<strong>控制流节点</strong>(control flow nodes)和<strong>动作节点</strong>(action nodes)</p><ul><li>[控制流节点]：主要包括start、end、fork、join等，其中fork、join成对出现，在fork展开。分支，最后在join结点汇聚<pre><code>* start* end</code></pre></li><li>[动作节点]：包括Hadoop任务、SSH、HTTP、EMAIL、OOZIE子任务<pre><code>* ok    --&gt; end* error --&gt; kill* 定义具体需要执行的job任务* MapReduce、shell、hive</code></pre></li></ul><p>actions 在远程系统（如Hadoop、Pig）中启动工作。在action完成时，远程系统回调Oozie通知action完成，此时Oozie将继续在workflow 中进行下一步操作。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;workflow-app xmlns=<span class="string">"uri:oozie:workflow:0.2"</span> <span class="built_in">name</span>=<span class="string">"no-op-wf"</span>&gt;</span><br><span class="line">    &lt;start <span class="keyword">to</span>=<span class="string">"end"</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">end</span> <span class="built_in">name</span>=<span class="string">"end"</span>/&gt;</span><br><span class="line">&lt;/workflow-app&gt;</span><br></pre></td></tr></table></figure><h3 id="coordinator-xml"><a href="#coordinator-xml" class="headerlink" title="coordinator.xml"></a>coordinator.xml</h3><p><img src="images/16120697726699.jpg" alt=""></p><p>workflow 作业是基于常规的时间间隔（time intervals）和数据可用性（data availability）运行的。</p><p>包括controls、datasets、input-events、output-events、action节点</p><ul><li>controls</li></ul><table><thead><tr><th>元素名称</th><th>含义说明</th></tr></thead><tbody><tr><td>timeout</td><td>超时时间，单位为分钟。当一个Coordinator Job启动的时候，会初始化多个Coordinator动作，timeout用来限制这个初始化过程。默认值为-1，表示永远不超时，如果为0 则总是超时。</td></tr><tr><td>concurrency</td><td>并发数，指多个Coordinator Job并发执行，默认值为1。</td></tr><tr><td>execution</td><td>配置多个Coordinator Job并发执行的策略：默认是FIFO。另外还有两种：LIFO（最新的先执行）、LAST_ONLY（只执行最新的Coordinator Job，其它的全部丢弃）。</td></tr><tr><td>throttle</td><td>一个Coordinator Job初始化时，允许Coordinator动作处于WAITING状态的最大数量。</td></tr></tbody></table><ul><li>datasets</li></ul><p>Coordinator Job中有一个Dataset的概念，它可以为实际计算提供计算的数据，主要是指HDFS上的数据目录或文件，能够配置数据集生成的频率（Frequency）、URI模板、时间等信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">datasets</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">include</span>&gt;</span>[SHARED_DATASETS]<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line">     <span class="tag">&lt;<span class="name">dataset</span> <span class="attr">name</span>=<span class="string">"[NAME]"</span> <span class="attr">frequency</span>=<span class="string">"[FREQUENCY]"</span> <span class="attr">initial-instance</span>=<span class="string">"[DATETIME]"</span> <span class="attr">timezone</span>=<span class="string">"[TIMEZONE]"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">uri-template</span>&gt;</span>[URI TEMPLATE]<span class="tag">&lt;/<span class="name">uri-template</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dataset</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">datasets</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>input-events和output-events元素</li></ul><p>一个Coordinator应用的输入事件指定了要执行一个Coordinator动作<strong>必须满足的输入条件</strong>，在Oozie当前版本，只支持使用dataset实例。</p><ul><li>action节点定义需要运行的workflow</li></ul><p>Coordinator 动作的状态变迁</p><table><thead><tr><th>转移前状态</th><th>转以后状态集合</th></tr></thead><tbody><tr><td>WAITING</td><td>READY 、 TIMEDOUT 、 KILLED</td></tr><tr><td>READY</td><td>SUBMITTED 、 KILLED</td></tr><tr><td>SUBMITTED</td><td>RUNNING 、 KILLED 、 FAILED</td></tr><tr><td>RUNNING</td><td>SUCCEEDED 、 KILLED 、 FAILED</td></tr></tbody></table><ul><li>EL变量</li></ul><table><thead><tr><th>常量表示形式</th><th>含义说明</th></tr></thead><tbody><tr><td>${coord:minutes(int n)}</td><td>返回日期时间：从一开始，周期执行n分钟</td></tr><tr><td>${coord:hours(int n)}</td><td>返回日期时间：从一开始，周期执行n * 60分钟</td></tr><tr><td>${coord:days(int n)}</td><td>返回日期时间：从一开始，周期执行n * 24 * 60分钟</td></tr><tr><td>${coord:current(int n)}</td><td>返回日期时间：从一个Coordinator动作（Action）创建时开始计算，第n个dataset实例执行时间</td></tr><tr><td>${coord:dataIn(String name)}</td><td>在输入事件（input-events）中，解析dataset实例包含的所有的URI</td></tr><tr><td>${coord:dataOut(String name)}</td><td>在输出事件（output-events）中，解析dataset实例包含的所有的URI</td></tr><tr><td>${coord:offset(int n, String timeUnit)}</td><td>表示时间偏移，如果一个Coordinator动作创建时间为T，n为正数表示向时刻T之后偏移，n为负数向向时刻T之前偏移，timeUnit表示时间单位（选项有MINUTE、HOUR、DAY、MONTH、YEAR）</td></tr><tr><td>${coord:nominalTime()}</td><td>nominal时间等于Coordinator Job启动时间，加上多个Coordinator Job的频率所得到的日期时间。例如：start=”2009-01-01T24:00Z”，end=”2009-12-31T24:00Z”，frequency=”${coord:days(1)}”，frequency=”${coord:days(1)}，则nominal时间为：2009-01-02T00:00Z、2009-01-03T00:00Z、2009-01-04T00:00Z、…、2010-01-01T00:00Z</td></tr><tr><td>${coord:actualTime()}</td><td>Coordinator动作的实际创建时间。例如：start=”2011-05-01T24:00Z”，end=”2011-12-31T24:00Z”，frequency=”${coord:days(1)}”，则实际时间为：2011-05-01，2011-05-02，2011-05-03，…，2011-12-31</td></tr><tr><td>${coord:user()}</td><td>启动当前Coordinator Job的用户名称</td></tr><tr><td>${coord:dateOffset(String baseDate, int instance, String timeUnit)}</td><td>计算新的日期时间的公式：newDate = baseDate + instance * timeUnit，如：baseDate=’2009-01-01T00:00Z’，instance=’2′，timeUnit=’MONTH’，则计算得到的新的日期时间为’2009-03-01T00:00Z’。</td></tr><tr><td>${coord:formatTime(String timeStamp, String format)}</td><td>格式化时间字符串，format指定模式</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oozie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gin web框架</title>
      <link href="/2020/05/06/Gin-web%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/05/06/Gin-web%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>gin是一个基于Golang标准库<code>net/http</code>封装的HTTPweb框架。<br>它提供了方便的路由注册功能，支持捕获URL参数，提供了中间件机制来串连请求处理流程，提供了方便的数据获取和输出方法，所有这些功能提升了开发web服务的效率。<br>本文将从以下六个方面介绍gin的实现。</p><h2 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h2><p>基于Golang标准库<code>net/http</code>的web服务都需要实现<code>http.Handler</code>接口，而<code>Engine</code>就是gin实现该接口的类，它同时也实现了注册路由、run服务等方法。<br><code>ServeHTTP</code>是HTTP请求的入口，而主要逻辑在<code>handleHTTPRequest</code>方法中实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库HTTP接口</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(engine *Engine)</span> <span class="title">handleHTTPRequest</span><span class="params">(c *Context)</span></span></span><br></pre></td></tr></table></figure><p>以下是几个比较重要的成员。<br>RouterGroup是路由注册的类，收集路由信息和对应的HandlerChain，实际注册还是调用的<code>Engine.addRoute</code>方法。<br><code>trees</code>是底层组织路由的结构。<br><code>pool</code>是分配<code>gin.Context</code>的池，优化内存分配。<br>Render用于数据渲染。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">RouterGroup <span class="comment">// 路由，engine作为根路由</span></span><br><span class="line"></span><br><span class="line">pool        sync.Pool <span class="comment">// context池</span></span><br><span class="line">trees       methodTrees <span class="comment">// 路由</span></span><br><span class="line"></span><br><span class="line">HTMLRender       render.HTMLRender <span class="comment">// 渲染数据</span></span><br><span class="line">FuncMap          template.FuncMap  <span class="comment">// 渲染数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>gin定义了两个接口来处理路由信息<br><code>IRoutes</code>包含设置中间件、设置HTTP处理函数以及静态文件等方法，应用程序通过它来注册应用的路由处理逻辑。<br><code>IRouter</code>继承了<code>IRoutes</code>，另外添加了一个<code>Group</code>方法来按URL路径层次组织router。</p><p>RouterGroup实现了<code>IRouter</code>接口，字段包含路径以及请求处理链，保存了Engine的指针，注册路由是通过调用<code>engine.addRoute</code>实现的。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">RouterGroup</span> struct &#123;</span><br><span class="line"><span class="type">Handlers</span> <span class="type">HandlersChain</span> // 处理链</span><br><span class="line">basePath string</span><br><span class="line">engine   *<span class="type">Engine</span></span><br><span class="line">root     bool // 如果是根，那么返回的<span class="type">IRoutes</span>接口对象为engine；否则返回自身</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addRoute方法根据不同HTTP method获取路由的根节点，然后按路径加入到基数树中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> (<span class="selector-tag">engine</span> *<span class="selector-tag">Engine</span>) <span class="selector-tag">addRoute</span>(<span class="selector-tag">method</span>, <span class="selector-tag">path</span> <span class="selector-tag">string</span>, <span class="selector-tag">handlers</span> <span class="selector-tag">HandlersChain</span>) &#123;</span><br><span class="line"><span class="attribute">root </span>:= engine.trees.<span class="built_in">get</span>(method)</span><br><span class="line">if root == nil &#123;</span><br><span class="line">root = <span class="built_in">new</span>(node)</span><br><span class="line">root.fullPath = <span class="string">"/"</span></span><br><span class="line">engine.trees = <span class="built_in">append</span>(engine.trees, methodTree&#123;method: method, root: root&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">root</span><span class="selector-class">.addRoute</span>(<span class="selector-tag">path</span>, <span class="selector-tag">handlers</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>trees类型定义</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由组织成一个森林，不同HTTP的方法代表一颗路径树</span></span><br><span class="line"><span class="comment">// HTTP只有9个方法，所有使用数组保存</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">methodTrees</span> []<span class="title">methodTree</span></span></span><br></pre></td></tr></table></figure><p>gin的路由实现似乎参考了httprouter这个项目，代码有点复杂先略过。<br>每个路由包含一个请求处理链<code>Handlers HandlersChain</code>。</p><p>HandlersChain定义为处理函数切片，处理函数只接收<code>*Context</code>参数，所有的请求响应需要的字段、以及处理流程控制变量都包含在<code>Context</code>结构体中。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerFunc defines the handler used by gin middleware as return value.</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">HandlerFunc</span> <span class="title">func</span></span>(*Context)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlersChain defines a HandlerFunc array.</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">HandlersChain</span> []<span class="title">HandlerFunc</span></span></span><br></pre></td></tr></table></figure><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>请求中间件和处理函数是同一个类型<code>HandlerFunc</code>。<br>分为全局中间件和针对某个URL的中间件。<code>Engine.Use</code>设置全局中间件。</p><p><code>func (engine *Engine) Use(middleware ...HandlerFunc) IRoutes</code></p><p><code>RouterGroup.Use</code>设置当前路由的中间件。</p><p><code>func (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes</code></p><p>gin提供了以下中间件，开发自定义中间件可以参考它们。</p><ul><li>HTTP验证 <code>BasicAuth</code>等</li><li>日志 <code>Logger</code>等</li><li>捕获panic <code>Recovery</code></li></ul><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context对象由<code>Engine.pool</code>分配，请求处理完又放回了池中。<br>主要字段包含请求、响应对象，捕获的参数，处理链，用来控制处理流程的索引，kv值存储等。<br>它实现了标准库<code>context.Context</code>接口，但是内部没有实现<code>Deadline</code>方法。请求的超时context在Request对象中，可以通过<code>c.Request.Context()</code>获取。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Context</span> struct &#123;</span><br><span class="line">writermem responseWriter // <span class="type">HTTP</span> writer的包装对象</span><br><span class="line"><span class="type">Request</span>   *http.<span class="type">Request</span>  // 请求对象</span><br><span class="line"><span class="type">Writer</span>    <span class="type">ResponseWriter</span> // 指向writermem</span><br><span class="line"></span><br><span class="line"><span class="type">Params</span>   <span class="type">Params</span> // url参数</span><br><span class="line">handlers <span class="type">HandlersChain</span> // 处理链，最多63个处理函数</span><br><span class="line">index    int8 // handlers的索引，控制handlers调用。reset函数初始化为-1</span><br><span class="line">fullPath string // 请求路径</span><br><span class="line"></span><br><span class="line">engine *<span class="type">Engine</span></span><br><span class="line"></span><br><span class="line">// <span class="type">This</span> mutex protect <span class="type">Keys</span> map</span><br><span class="line"><span class="type">KeysMutex</span> *sync.<span class="type">RWMutex</span></span><br><span class="line"></span><br><span class="line">// <span class="type">Keys</span> is a key/value pair exclusively for the context of each request.</span><br><span class="line"><span class="type">Keys</span> map[string]interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理控制逻辑由<code>Next</code>和<code>Abort</code>两个函数实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next可以在处理函数内部调用，相当于直接调用下一个处理函数，调用层级+1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *Context)</span></span> <span class="type">Next</span>() &#123;</span><br><span class="line"><span class="built_in">c</span>.index++ <span class="comment">// 初始化为-1，从0开始执行</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">c</span>.index &lt; int8(len(<span class="built_in">c</span>.handlers)) &#123;</span><br><span class="line"><span class="built_in">c</span>.handlers[<span class="built_in">c</span>.index](<span class="built_in">c</span>) <span class="comment">// 调用当前函数</span></span><br><span class="line"><span class="built_in">c</span>.index++ <span class="comment">// 移动到下一个函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Abort终止所有后续的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *Context)</span></span> <span class="type">Abort</span>() &#123;</span><br><span class="line"><span class="built_in">c</span>.index = abortIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他API包括以下几类</p><ul><li>读请求参数，如<code>Param</code>,<code>Query</code>等</li><li>读写kv数据，如<code>Get</code>,<code>Set</code>等</li><li>解析请求数据，如带<code>Bind</code>的方法</li><li>渲染数据，写响应，如<code>JSON</code>,<code>Data</code>,<code>Render</code>等</li></ul><h2 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h2><p>gin提供了binding接口来解码请求数据，接口和实现定义在binding目录下面。<br>为了方便，在Context上实现了许多数据格式解码的帮助函数，包括json、yaml、xml、protobuf等</p><p>最基础的是<code>Binding</code>接口，它定义了从request读数据并且解码的接口<br><code>BindingBody</code>定义了从body读数据的接口<br><code>BindingUri</code>定义了从URL读数据的接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Binding <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="built_in">string</span></span><br><span class="line">Bind(*http.Request, <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> BindingBody <span class="keyword">interface</span> &#123;</span><br><span class="line">Binding</span><br><span class="line">BindBody([]byte, <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BindingUri adds BindUri method to Binding. BindUri is similar with Bind,</span></span><br><span class="line"><span class="comment">// but it read the Params.</span></span><br><span class="line"><span class="keyword">type</span> BindingUri <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="built_in">string</span></span><br><span class="line">BindUri(map[<span class="built_in">string</span>][]<span class="built_in">string</span>, <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Context的帮助函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *Context)</span></span> <span class="type">ShouldBindJSON</span>(obj interface&#123;&#125;) error <span class="comment">// 不设置状态码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *Context)</span></span> <span class="type">BindUri</span>(obj interface&#123;&#125;) error <span class="comment">// 错误设置400</span></span><br></pre></td></tr></table></figure><h2 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h2><p>Context数据渲染方法</p><p><code>func (c *Context) Render(code int, r render.Render)</code></p><p>Render接口定义在render目录下，包括各种常用格式，如json、jsonp、HTML、protobuf等</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Render</span> interface &#123;</span><br><span class="line">// <span class="type">Render</span> writes data with custom <span class="type">ContentType</span>.</span><br><span class="line"><span class="type">Render</span>(http.<span class="type">ResponseWriter</span>) error</span><br><span class="line">// <span class="type">WriteContentType</span> writes custom <span class="type">ContentType</span>.</span><br><span class="line"><span class="type">WriteContentType</span>(w http.<span class="type">ResponseWriter</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Context的帮助函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">JSONP</span><span class="params">(code <span class="keyword">int</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Context)</span> <span class="title">Data</span><span class="params">(code <span class="keyword">int</span>, contentType <span class="keyword">string</span>, data []<span class="keyword">byte</span>)</span></span></span><br></pre></td></tr></table></figure><p>有个小坑需要注意，Render函数内部会panic。如果渲染报错了，直接panic。<br>其他渲染函数都会调用它，所以都有可能panic。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Render writes the response headers and calls render.Render to render data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *Context)</span></span> <span class="type">Render</span>(code int, r render.<span class="type">Render</span>) &#123;</span><br><span class="line"><span class="built_in">c</span>.<span class="type">Status</span>(code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !bodyAllowedForStatus(code) &#123;</span><br><span class="line">r.<span class="type">WriteContentType</span>(<span class="built_in">c</span>.<span class="type">Writer</span>)</span><br><span class="line"><span class="built_in">c</span>.<span class="type">Writer</span>.<span class="type">WriteHeaderNow</span>()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := r.<span class="type">Render</span>(<span class="built_in">c</span>.<span class="type">Writer</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>基数树高效组织路由</li><li>sync.pool分配Context</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> (<span class="selector-tag">engine</span> *<span class="selector-tag">Engine</span>) <span class="selector-tag">ServeHTTP</span>(<span class="selector-tag">w</span> <span class="selector-tag">http</span><span class="selector-class">.ResponseWriter</span>, <span class="selector-tag">req</span> *<span class="selector-tag">http</span><span class="selector-class">.Request</span>) &#123;</span><br><span class="line"><span class="attribute">c </span>:= engine.pool.<span class="built_in">Get</span>().(*Context)</span><br><span class="line">c.writermem.<span class="built_in">reset</span>(w)</span><br><span class="line">c.Request = req</span><br><span class="line">c.<span class="built_in">reset</span>()</span><br><span class="line"></span><br><span class="line">engine.<span class="built_in">handleHTTPRequest</span>(c)</span><br><span class="line"></span><br><span class="line">engine.pool.<span class="built_in">Put</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可替换的json库。<br>  在<code>internal/json</code>封装了常用json函数，用<code>// +build jsoniter</code>来替换标准库json。</p></li><li><p>字符串和slice转换优化。<br>  在<code>internal/bytesconv</code>里定义了优化后的转换函数，用了黑魔法避免内存拷贝。</p></li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">StringToBytes </span>converts <span class="keyword">string </span>to <span class="keyword">byte </span>slice without a memory allocation.</span><br><span class="line"><span class="symbol">func</span> <span class="keyword">StringToBytes(s </span><span class="keyword">string) </span>(<span class="keyword">b </span>[]<span class="keyword">byte) </span>&#123;</span><br><span class="line">sh := *(*reflect.<span class="keyword">StringHeader)(unsafe.Pointer(&amp;s))</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">bh </span>:= (*reflect.SliceHeader)(unsafe.Pointer(&amp;<span class="keyword">b))</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">bh.Data, </span><span class="keyword">bh.Len, </span><span class="keyword">bh.Cap </span>= sh<span class="meta">.Data</span>, sh.Len, sh.Len</span><br><span class="line">return <span class="keyword">b</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span><span class="keyword">BytesToString </span>converts <span class="keyword">byte </span>slice to <span class="keyword">string </span>without a memory allocation.</span><br><span class="line"><span class="symbol">func</span> <span class="keyword">BytesToString(b </span>[]<span class="keyword">byte) </span><span class="keyword">string </span>&#123;</span><br><span class="line">return *(*<span class="keyword">string)(unsafe.Pointer(&amp;b))</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这里只记录了gin框架的大体架构，涉及到细节的地方大多都略过了。例如HTTP请求处理逻辑、路由trees的匹配算法等，希望以后有时间可以补上。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang failpoint工具</title>
      <link href="/2020/04/25/Golang-failpoint%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/04/25/Golang-failpoint%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/pingcap/failpoint" target="_blank" rel="noopener">failpoint</a>是用于测试时注入错误的工具。<br>来源是BSD系统的failpoint功能，已有的go语言实现有etcd的gofail。</p><p>它与gofail的区别是用标记函数代替了注释，标记函数的好处在于IDE可以识别并且编译时可以进行语法检查。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>注入错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/pingcap/failpoint"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    failpoint.Inject(<span class="string">"testPanic"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"failpoint triggerd"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开错误<code>failpoint-ctl enable</code><br>关闭<code>failpoint-ctl disable</code></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>enable和disable命令对应code目录下面的两个功能模块</p><ul><li>rewriter</li><li>restorer</li></ul><a id="more"></a><h4 id="rewriter"><a href="#rewriter" class="headerlink" title="rewriter"></a>rewriter</h4><p>Rewriter遍历目录，根据文件名过滤掉非go文件和rewrite之后生成的文件。<br>parse文件的import，过滤没有import标记函数包的文件</p><p><code>file, err := parser.ParseFile(fset, path, nil, parser.ImportsOnly)</code></p><p>对所有函数定义进行rewrite</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span>, <span class="title">ok</span> := <span class="title">decl</span>.</span>(*ast.FuncDecl)</span><br><span class="line">r.rewriteFuncDecl(<span class="function"><span class="keyword">fn</span>)</span></span><br></pre></td></tr></table></figure><p>rewrite使用了递归，覆盖了所有可能出现注入错误的语句。<br>实际需要修改的是表达式<code>*ast.ExprStmt</code>，并且是包函数调用<code>*ast.SelectorExpr</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exprRewriter, found := exprRewriters[expr.Sel.Name]</span><br><span class="line"><span class="keyword">if</span> !found &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">rewritten, stmt, err := exprRewriter(r, call)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记函数对应的修改函数的映射放在<code>exprRewriters</code>这个map<br>修改函数构造一个新的stmt替换掉原来的语句，再输出到原文件，修改就完成了。<br>除了修改原文件，rewriter会生成一个binding文件和原文件的备份，备份文件用于disable的时候来恢复原文件。</p><h4 id="restorer"><a href="#restorer" class="headerlink" title="restorer"></a>restorer</h4><p>restore没有直接把备份文件rename为原文件，而是把生成的文件跟备份文件做了一次diff，然后把patch加到备份文件上，这样做是为了把生成之后对新文件的修改应用到备份文件上，避免用户disable之后修改丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;&lt;领域驱动开发&gt;&gt;摘要</title>
      <link href="/2020/04/11/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E6%91%98%E8%A6%81/"/>
      <url>/2020/04/11/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E6%91%98%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>领域层 – 核心<br>应用层 – 领域的一个使用场景<br>基础设施 – 实现的支撑系统</p><h2 id="构件"><a href="#构件" class="headerlink" title="构件"></a>构件</h2><p>Entity – 需要追踪生命周期的具有唯一标识的对象<br>Value Object – 属性对象，一般不可变<br>Service – 放置不属于领域层对象（Entity或Value Object）的操作<br>Aggregate – 领域对象的集合，以Entity作为跟外部交互的root，有且只有一个root，内部对象封装在它里面<br>Factory – 封装对象创建逻辑<br>Repository – 跟持久化交互的层，封装简单存储、恢复对象的操作</p><h2 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h2><p>specification 一种VO，封装条件逻辑，在验证、从集合中选择对象、根据要求创建对象的时候使用</p><p>Intention-Revealing interface 接口设计原则，只描述意图而隐藏实现。命名类和操作时要描述它们的效果和目的，而不要表露它们通过何种方式达到目的。清楚地分离函数、命令或查询，函数描述它的行为，命令需要说明它的副作用。</p><p>side-effect-free function 尽可能把程序逻辑放到函数中，因为函数不产生副作用。如果发现一个适合承担复杂逻辑职责的概念，就可以把这个复杂逻辑放到value object中。</p><p>assertion 使用断言把副作用表示出来。<br><img src="/images/15865899111921.jpg" alt=""></p><p>closure of operation 闭合操作，实现者的类型和参数、返回值的类型一致，那么这个操作没有引入其他依赖类型，可以认为是一个闭合操作。</p><h2 id="柔性设计"><a href="#柔性设计" class="headerlink" title="柔性设计"></a>柔性设计</h2><p><img src="/images/15865899255816.jpg" alt=""></p><p>去掉类之间不必要的关联，保持低耦合。低耦合的极致是standalone class。<br>每多产生一个概念-显示或隐式，都会加重理解的负担。</p><a id="more"></a><h2 id="切入问题的角度"><a href="#切入问题的角度" class="headerlink" title="切入问题的角度"></a>切入问题的角度</h2><ul><li><p>分割子领域<br>  重点突击某个部分，使设计的一个部分真正变得灵活起来</p></li><li><p>尽可能利用已有的形式<br>  对领域中建立已久的概念加以修改和利用</p></li></ul><h2 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h2><p>开发一个包含所有业务的统一大模型不是一种行之有效且经济的做法。</p><p>三个主题</p><ul><li><p>上下文 bounded context 划分了各个子模型的边界</p><p>  给上下文起名称，并添加到ubiquitous language中<br>  在单个bounded context中持续集成<br>  一般来说，一个bounded context对应一个团队。一个团队可以维护多个bounded context，但是多个团队在一个bounded context工作通常比较困难。</p><ul><li><p>合并代码和其他实现工件</p></li><li><p>自动测试查明模型分裂问题</p></li><li><p>严格坚持使用ubiquitous language，对概念模型达成共识</p><p>bounded context之间使用context map描述它们的关系<br>context map模式之间的区别在于对另一模型的控制程度、两个团队的合作水平和合作类型，以及特性和数据的集成程度</p></li><li><p>shared kernel 两个团队<strong>共享</strong>各自<strong>领域模型</strong>的一个<strong>子集</strong>以及相关代码、数据，集成的频率比持续集成低，每次修改必须通过两个团队的测试</p></li><li><p>customer/supplier development team 单向的依赖关系，必须有自动测试套件，两个团队需要良好的合作，最好属于同一个管理者</p></li><li><p>conformist 跟随者模式 当上游团队没有合作意愿的时候，且接口很大集成很重要的时候，遵从上游团队的模型可以简化集成</p></li><li><p>anticorruption layer 当需要集成不同模型且无法控制的系统时，创建防护层是一个防止模型因为集成而受到影响的好方法。</p><ul><li>以service提供对集成系统的访问</li><li>adapter 接收访问请求，处理集成系统返回的结果</li><li>facade 对集成系统的接口进行简化</li><li>translator 提供对象转换功能，adapter调用它实现转换</li></ul><ul><li><p>separate way 独立自主 集成代价高而收益小，不如单独开发一个新的    bounded context</p></li><li><p>open host service 当需要与大量其他子系统集成时，可以把你的子系统作为一组service供其他系统访问</p><ul><li>published language 良好文档化、能够表达领域信息的共享语言作为公共的通信媒介</li></ul></li></ul><p><img src="/images/15865899588669.jpg" alt=""></p></li></ul></li></ul><ul><li><p>精炼 集中注意力到最核心的部分</p><p>  目的</p><ul><li><p>帮助所有团队成员掌握系统的总体设计及协调</p></li><li><p>找到适度规模的核心模型并把它添加到通用语言中，从而促进沟通</p></li><li><p>指导重构</p></li><li><p>专注于模型最有价值的部分</p></li><li><p>指导外部、现成组件的使用以及人物委派</p><p>实施方法</p></li><li><p>对模型进行提炼，找到并精炼core domain，最有价值和最专业的概念要轮廓分明。</p></li><li><p>让最有才能的人来开发core domain</p></li><li><p>识别并分离通用子领域（非core domain），考虑使用现成的解决方案或公开发布的模型</p><p><img src="/images/15865899760958.jpg" alt=""></p></li><li><p>domain vision statement 领域前景说明，写一份core domain的简短描述以及它会创造的价值，展示出领域模型是如何实现和均衡各方利益的。</p></li><li><p>highlighted core 编写简短文档，描述core domain和core元素之间的主要交互过程。</p></li><li><p>cohesive mechanism 把概念上的内聚机制分离到单独的轻量级框架中，用一个intention-revealing interface来公开框架的功能，它用来满足规则或模型指定的计算。</p></li><li><p>segregated core 把核心概念从支持性元素中分离出来，增强core内聚性，减少与其它代码的耦合。</p></li><li><p>abstract core 把模型中最基本的概念识别出来，并分离到不同的类、抽象类或接口中，使之能表达出重要组件的大部分交互。</p></li></ul></li><li><p>大比例结构</p><p>  大比例结构是一种语言，人们可以用它来从大局上讨论和理解系统。<br>  设计一种应用于整个系统的规则（或角色和关系）模式，使人们可以通过它在一定程度上了解各个部分在整体中所处的位置。</p><p><img src="/images/15865900039898.jpg" alt=""></p></li><li><p>evolving order</p><p>  应该允许大比例结构随着应用程序一起演变，有些设计和模型的决策必须在掌握了详细知识之后才能确定，这样的决策不能过早地制定。<br>  当发现一种大比例结构明显地使系统变得更清晰，而又没有为模型开发施加不自然的约束时，就应该采用这种结构。要记住宁缺毋滥的原则。</p></li><li><p>system metaphor 当系统的一个具体类比正好符合团队成员对系统的想象，并且能够引导他们向着一个有用的方向思考时，就应该把这个类比用作一种大比例结构。</p></li><li><p>responsibility layer 如果在领域中发现了自然的层次结构，就把它们转换为主要的抽象职责。</p></li><li><p>knowledge level 创建一组不同的对象，用它们来描述和约束基本模型的结构和行为。把这些对象分为两个级别，一个是非常具体的级别，另一个则提供了一些可供用户或超级用户定制的规则和知识。</p></li><li><p>plugable component framework 从接口和交互中提炼出一个abstract core，并创建一个框架，这个框架要允许这些接口的各种不同实现被自由替换。缺点是难以使用和只为应用程序提供有限的选择。</p></li></ul><h3 id="战略设计决策的要点"><a href="#战略设计决策的要点" class="headerlink" title="战略设计决策的要点"></a>战略设计决策的要点</h3><ul><li>决策必须传达到整个团队</li><li>决策过程必须收集反馈意见</li><li>计划必须允许演变</li><li>架构团队不必把所有最好、最聪明的人员都吸收进来<br>  领域专家对架构也很重要。应用程序的开发也需要技术能力强的人。</li><li>战略设计需要遵守简约和谦逊的原则</li><li>对象的职责专一，而开发人员应该是多面手</li></ul><h3 id="领域驱动设计的标志"><a href="#领域驱动设计的标志" class="headerlink" title="领域驱动设计的标志"></a>领域驱动设计的标志</h3><p>把理解目标领域并把学到的知识融合到软件中当作首要任务。</p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>zap源码阅读</title>
      <link href="/2020/04/10/zap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2020/04/10/zap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>zap是Uber开源的golang日志库，以结构化日志、高性能、可扩展的特点受到许多开发者的欢迎。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建logger"><a href="#创建logger" class="headerlink" title="创建logger"></a>创建logger</h3><p>zap对外提供了两个不同的日志对象，强类型的Logger和简化使用方式的SugaredLogger</p><ul><li><p>Logger创建</p><ul><li><p>低级API</p><p>  <code>func New(core zapcore.Core, options ...Option) *Logger</code></p></li><li><p>通过配置创建<br>  使用了builder模式，通过Config对象的Build方法创建</p><p>  <code>func (cfg Config) Build(opts ...Option) (*Logger, error)</code></p><p>  配置对象可以使用预设的<code>NewDevelopmentConfig</code>或<code>NewProductionConfig</code>创建，也可以反序列化json或yaml来创建<br>  Option提供了动态修改Logger配置的能力，定义为接口，每个实现在闭包中修改Logger对象</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Option<span class="built_in"> interface </span>&#123;</span><br><span class="line">apply(*Logger)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造带固定上下文的Logger</p><p>  <code>func (log *Logger) With(fields ...Field) *Logger</code></p></li></ul></li><li><p>SugaredLogger</p><ul><li><p>封装了Logger，可以和Logger互相转换</p><p>  <code>func (log *Logger) Sugar() *SugaredLogger</code><br>  <code>func (s *SugaredLogger) Desugar() *Logger</code></p><p>  内部通过<code>sweetenFields</code>方法把<code>(string, interface{})</code>类型的kv参数转换为强类型的<code>Field</code></p><p>  <code>func (s *SugaredLogger) sweetenFields(args []interface{}) []Field</code></p></li><li><p>通过<code>With</code>方法构造一个带固定上下文的SugaredLogger</p><p>  <code>func (s *SugaredLogger) With(args ...interface{}) *SugaredLogger</code></p></li></ul></li></ul><h3 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h3><ul><li><p>Logger</p><p>  msg传入简单字符串，其他日志信息通过<code>Field</code>包装起来<br>  <code>func (log *Logger) Info(msg string, fields ...Field)</code></p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.<span class="builtin-name">Info</span>(<span class="string">"msg"</span>, zap.String(<span class="string">"foo"</span>, <span class="string">"bar"</span>))</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>SugaredLogger</p><p>  格式化msg的方法<br>  <code>func (s *SugaredLogger) Infof(template string, args ...interface{})</code></p>  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sugar</span><span class="selector-class">.Infof</span>(<span class="string">"Failed to fetch URL: %s"</span>, url)</span><br></pre></td></tr></table></figure><p>  带kv参数的方法<br>  <code>func (s *SugaredLogger) Infow(msg string, keysAndValues ...interface{})</code></p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sugar.Infow(<span class="string">"Failed to fetch URL."</span>,</span><br><span class="line"><span class="comment">// Structured context as loosely typed key-value pairs.</span></span><br><span class="line"><span class="string">"url"</span>, url,</span><br><span class="line"><span class="string">"attempt"</span>, <span class="number">3</span>,</span><br><span class="line"><span class="string">"backoff"</span>, <span class="selector-tag">time</span><span class="selector-class">.Second</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>zapcore 封装日志的Core接口和实现，以及level、entry、encoder、field等基础功能<br>zap 提供高层接口，包括sugarlogger、配置、输出接口<code>Sink</code>和实现、HTTP修改level接口等<br>其他包提供支持功能。buffer实现了一个默认size为<strong>1k</strong>的buffer池。zapgrpc封装了与grpclog兼容的日志。</p><a id="more"></a><h3 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h3><p>Logger结构体很轻量，核心的core是一个接口，创建一个新的对象开销不大，一般使用也可以重用Logger对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Logger <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">core zapcore.Core</span><br><span class="line"></span><br><span class="line">development <span class="keyword">bool</span></span><br><span class="line">name        <span class="built_in">string</span></span><br><span class="line">errorOutput zapcore.WriteSyncer</span><br><span class="line"></span><br><span class="line">addCaller <span class="keyword">bool</span></span><br><span class="line">addStack  zapcore.LevelEnabler</span><br><span class="line"></span><br><span class="line">callerSkip <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>New</code>方法<br>  <code>func New(core zapcore.Core, options ...Option) *Logger</code></p><p>  根据传入的参数赋值，然后调用<code>WithOptions</code>设置Logger。</p></li><li><p><code>Config.Build</code><br>  <code>func (cfg Config) Build(opts ...Option) (*Logger, error)</code></p><p>  根据配置构造encoder，输出对象，然后调用<code>zapcore.NewCore</code>创建core，最后根据参数opts来设置Logger</p><p>  encoder的创建使用了简单工厂，内部维护了一个字符串到构造函数的映射，根据配置来决定使用哪个encoder。可以用<code>RegisterEncoder</code>注册新的encoder。</p><p>  输出对象也使用了简单工厂，内部维护了URL的scheme到构造函数的映射。通过<code>url.URL</code>来决定输出对象接口<code>Sink</code>的实现。可以用<code>RegisterSink</code>来注册新的<code>Sink</code>实现。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cfg Config)</span> <span class="title">Build</span><span class="params">(opts ...Option)</span> <span class="params">(*Logger, error)</span></span> &#123;</span><br><span class="line">enc, err := cfg.buildEncoder()</span><br><span class="line"><span class="comment">// error handle</span></span><br><span class="line"></span><br><span class="line">sink, errSink, err := cfg.openSinks()</span><br><span class="line"><span class="comment">// error handle</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cfg.Level == (AtomicLevel&#123;&#125;) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"missing Level"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log := New(</span><br><span class="line">zapcore.NewCore(enc, sink, cfg.Level),</span><br><span class="line">cfg.buildOptions(errSink)...,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(opts) &gt; <span class="number">0</span> &#123;</span><br><span class="line">log = log.WithOptions(opts...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> log, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>zapcore.NewCore</code>创建了一个ioCore，主要的日志编码和输出逻辑在它的<code>Write</code>方法中实现</p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func NewCore(<span class="keyword">enc</span> Encoder, ws WriteSyncer, enab LevelEnabler) Core &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ioCore&#123;</span><br><span class="line">LevelEnabler: enab,</span><br><span class="line"><span class="keyword">enc</span>:          <span class="keyword">enc</span>,</span><br><span class="line"><span class="keyword">out</span>:          ws,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="打印日志流程"><a href="#打印日志流程" class="headerlink" title="打印日志流程"></a>打印日志流程</h3><p>以Info函数为例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(log *Logger)</span> <span class="title">Info</span><span class="params">(msg <span class="keyword">string</span>, fields ...Field)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ce := log.check(InfoLevel, msg); ce != <span class="literal">nil</span> &#123;</span><br><span class="line">ce.Write(fields...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行打印之前会调用Logger的check方法，如果不满足条件就不会创建对象和调用Write方法。</p><p>  <code>check</code>方法会先检查level，如果不满足条件就返回nil了。如果满足条件会创建日志entry，并调用core的check，如果core.Check返回了<code>zapcore.CheckedEntry</code>才会继续执行添加其他日志信息操作。实际打印的逻辑发生在<code>zapcore.CheckedEntry</code>的Write方法里面。</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">func (log *Logger) check(lvl zapcore<span class="selector-class">.Level</span>, msg string) *zapcore.CheckedEntry&#123;</span><br><span class="line"><span class="comment">// check must always be called directly by a method in the Logger interface</span></span><br><span class="line"><span class="comment">// (e.g., Check, Info, Fatal).</span></span><br><span class="line">const callerSkipOffset = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the level first to reduce the cost of disabled log calls.</span></span><br><span class="line"><span class="comment">// Since Panic and higher may exit, we skip the optimization for those levels.</span></span><br><span class="line"><span class="keyword">if</span> lvl &lt; zapcore<span class="selector-class">.DPanicLevel</span> &amp;&amp; !log<span class="selector-class">.core</span><span class="selector-class">.Enabled</span>(lvl) &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create basic checked entry thru the core; this will be non-nil if the</span></span><br><span class="line"><span class="comment">// log message will actually be written somewhere.</span></span><br><span class="line">ent := zapcore.Entry&#123;</span><br><span class="line">LoggerName: log<span class="selector-class">.name</span>,</span><br><span class="line">Time:       <span class="selector-tag">time</span>.Now(),</span><br><span class="line">Level:      lvl,</span><br><span class="line">Message:    msg,</span><br><span class="line">&#125;</span><br><span class="line">ce := log<span class="selector-class">.core</span><span class="selector-class">.Check</span>(ent, nil)</span><br><span class="line">willWrite := ce != nil</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up any required terminal behavior.</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Only do further annotation if we're going to write this message; checked</span></span><br><span class="line"><span class="comment">// entries that exist only for terminal behavior don't benefit from</span></span><br><span class="line"><span class="comment">// annotation.</span></span><br><span class="line"><span class="keyword">if</span> !willWrite &#123;</span><br><span class="line">return ce</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread the error output through to the CheckedEntry.</span></span><br><span class="line">ce<span class="selector-class">.ErrorOutput</span> = log.errorOutput</span><br><span class="line"><span class="comment">// add caller</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add stack</span></span><br><span class="line"></span><br><span class="line">return ce</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>core接口实现的Check方法<br>  不同的core实现会执行不同操作，但是要执行core的Write方法需要调用<code>AddCore</code>把自己加入到<code>zapcore.CheckedEntry</code>的core列表里面。<br>  以ioCore为例</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *ioCore)</span></span> <span class="type">Check</span>(ent <span class="type">Entry</span>, ce *<span class="type">CheckedEntry</span>) *<span class="type">CheckedEntry</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">Enabled</span>(ent.<span class="type">Level</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ce.<span class="type">AddCore</span>(ent, <span class="built_in">c</span>) <span class="comment">// 加入到待执行core列表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ce</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>zapcore.CheckedEntry</code>保存了日志原始信息<code>Entry</code>，以及需要执行的core，打印日志后需要执行的动作标识等<br>  <code>AddCore</code>方法会通过<code>getCheckedEntry</code>方法从<code>sync.Pool</code>中获取CheckedEntry对象，把core加入到待执行列表</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckedEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">Entry</span><br><span class="line">ErrorOutput WriteSyncer</span><br><span class="line">dirty       <span class="keyword">bool</span> <span class="comment">// best-effort detection of pool misuse</span></span><br><span class="line">should      CheckWriteAction</span><br><span class="line">cores       []Core</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ce *CheckedEntry)</span> <span class="title">AddCore</span><span class="params">(ent Entry, core Core)</span> *<span class="title">CheckedEntry</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ce == <span class="literal">nil</span> &#123;</span><br><span class="line">ce = getCheckedEntry()</span><br><span class="line">ce.Entry = ent</span><br><span class="line">&#125;</span><br><span class="line">ce.cores = <span class="built_in">append</span>(ce.cores, core)</span><br><span class="line"><span class="keyword">return</span> ce</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  执行日志打印的Write方法</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func (ce *CheckedEntry) Write(fields ...Field) &#123;</span><br><span class="line"><span class="keyword">if</span> ce == nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ce<span class="selector-class">.dirty</span> &#123;</span><br><span class="line"><span class="comment">// 输出内部错误信息</span></span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">ce<span class="selector-class">.dirty</span> = true</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> err error</span><br><span class="line"><span class="comment">// **关键路径**：执行多个core，其他的core例如hook、tee等功能都依赖它来执行</span></span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> := range ce<span class="selector-class">.cores</span> &#123;</span><br><span class="line">err = multierr.Append(err, ce<span class="selector-class">.cores</span>[i].Write(ce<span class="selector-class">.Entry</span>, fields))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ce<span class="selector-class">.ErrorOutput</span> != nil &#123;</span><br><span class="line"><span class="comment">// 输出内部错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">should, msg := ce<span class="selector-class">.should</span>, ce.Message</span><br><span class="line">putCheckedEntry(ce)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行后续动作</span></span><br><span class="line">switch should &#123;</span><br><span class="line">case WriteThenPanic:</span><br><span class="line">panic(msg)</span><br><span class="line">case WriteThenFatal:</span><br><span class="line">exit.Exit()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>core接口实现的Write方法。具体日志处理逻辑由这个方法实现。</p><p>  ioCore</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *ioCore)</span></span> <span class="type">Write</span>(ent <span class="type">Entry</span>, fields []<span class="type">Field</span>) error &#123;</span><br><span class="line"><span class="comment">// 日志编码，调用具体的编码器实现，结果buf由它分配，使用完需要手动释放</span></span><br><span class="line">buf, err := <span class="built_in">c</span>.enc.<span class="type">EncodeEntry</span>(ent, fields)</span><br><span class="line"><span class="comment">// 处理错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出日志，调用具体输出实现</span></span><br><span class="line"><span class="number">_</span>, err = <span class="built_in">c</span>.out.<span class="type">Write</span>(buf.<span class="type">Bytes</span>())</span><br><span class="line"><span class="comment">// 归还buf</span></span><br><span class="line">buf.<span class="type">Free</span>()</span><br><span class="line"><span class="comment">// 处理错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ent.<span class="type">Level</span> &gt; <span class="type">ErrorLevel</span> &#123;</span><br><span class="line"><span class="comment">// Since we may be crashing the program, sync the output. Ignore Sync</span></span><br><span class="line"><span class="comment">// errors, pending a clean solution to issue #370.</span></span><br><span class="line"><span class="built_in">c</span>.<span class="type">Sync</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>encoder接口</p><p>  zap定义了所有基础类型和容器对象类型的编码接口，内部有json和console两个实现。<br>  json编码器从buffer池获取结果buf，通过字符串拼接的方式把日志拼装成json格式，避免了使用<code>encoding/json</code>的反射开销。</p></li><li><p>WriteSyncer接口    </p><p>  zap实现了输出到文件(stdout/stderr)，更高级的功能例如rotation需要自定义WriteSyncer实现然后用它来创建core</p></li></ul><h3 id="日志扩展"><a href="#日志扩展" class="headerlink" title="日志扩展"></a>日志扩展</h3><p>Logger对象保存的core接口可以对应多种实现，zap内部扩展功能例如Hook、sampler都是通过保存上一个core形成一个责任链，通过重写<code>Check</code>/<code>Write</code>方法来实现自己的逻辑。<br>zap提供了工具函数来包装一个core</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WrapCore</span><span class="params">(f func(zapcore.Core)</span> <span class="title">zapcore</span>.<span class="title">Core</span>) <span class="title">Option</span> &#123;</span></span><br><span class="line"><span class="keyword">return</span> optionFunc(<span class="function"><span class="keyword">func</span><span class="params">(log *Logger)</span> &#123;</span></span><br><span class="line"><span class="built_in">log</span>.core = f(<span class="built_in">log</span>.core)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hook在Write方法中调用注册的函数</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">h</span> *hooked) Write(ent Entry, _ []Field) <span class="keyword">error</span> &#123;</span><br><span class="line"><span class="comment">// Since our downstream had a chance to register itself directly with the</span></span><br><span class="line"><span class="comment">// CheckedMessage, we don't need to call it here.</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">err</span> <span class="keyword">error</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> <span class="keyword">h</span>.funcs &#123;</span><br><span class="line"><span class="keyword">err</span> = multierr.<span class="keyword">Append</span>(<span class="keyword">err</span>, <span class="keyword">h</span>.funcs[i](ent))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>zap在优化性能方法做了以下一些措施</p><ul><li><p>避免创建多余的<code>Entry</code>和<code>CheckedEntry</code></p><p>  写日志之前会调用<code>Logger.check</code>，不满足条件不会创建<code>Entry</code>对象<br>  在<code>AddCore</code>方法中才会创建<code>CheckedEntry</code>，而只有真正要执行的core才会调用<code>AddCore</code>方法</p></li><li><p>sync.Pool的使用</p><p>  <code>Entry</code>、<code>CheckedEntry</code>、<code>Buffer</code>等中间对象都通过内存池缓存来减少gc开销</p></li><li><p>预分配<strong>1k</strong>的buffer</p><p>  zap默认分配<strong>1k</strong>大小的buffer，避免因为容量不足而扩容。如果应用需要更长的日志，可能需要调整该参数。</p></li><li><p>强类型参数</p><p>  Logger的方法需要传入Field作为上下文信息，Field保存了类型信息，每个对应的类型都实现了编码方法，避免了反射开销。<br>  缺点是调用的时候需要调用辅助函数来构造Field，略微有点不方便。</p></li><li><p>自定义编码器</p><p>  zap定义了可接受的类型以及对应的json编码实现，通过处理每种类型对应的编码来避免反射开销。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go Code Style Guide</title>
      <link href="/2020/03/28/go-code-style-guide/"/>
      <url>/2020/03/28/go-code-style-guide/</url>
      
        <content type="html"><![CDATA[<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>当命名包时，请遵守下面规则：</p><ul><li>全部小写。没有大写或下划线。</li><li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li><li>不建议使用“common”，“util”，“shared”或“lib”。这些是信息量不足的名称。</li></ul><p>BAD</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kv_log</span><br><span class="line">rateLimit</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kvlog</span></span><br><span class="line"><span class="attribute">ratelimit</span></span><br></pre></td></tr></table></figure><h3 id="函数、变量名"><a href="#函数、变量名" class="headerlink" title="函数、变量名"></a>函数、变量名</h3><p>遵循 Go 社区关于使用 MixedCaps 作为函数名 的约定。使用单词首字母大小写命名，作用域越大的名称越详细，名字不包含下划线。<br>有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：TestMyFunction_WhatIsBeingTested.<br>函数名字使用动词加名词的形式，避免使用<code>v1/v2</code>这类后缀.</p><p>BAD</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global_variable <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">const</span> MAX_SIZE = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVariable <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">const</span> MaxSize = <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="时间相关变量命名带上单位。"><a href="#时间相关变量命名带上单位。" class="headerlink" title="时间相关变量命名带上单位。"></a>时间相关变量命名带上单位。</h3><p>BAD</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expireTime <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expireMilliSeconds <span class="keyword">int</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="接收者命名"><a href="#接收者命名" class="headerlink" title="接收者命名"></a>接收者命名</h3><p>使用一致的名字.<br>不推荐this、self，原因是跟开源社区习惯不一致。<br>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f foo)</span> <span class="title">A</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pf *foo)</span> <span class="title">B</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// 这类的pf跟前面使用的f不一致</span></span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f foo)</span> <span class="title">A</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">B</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="函数和接口定义"><a href="#函数和接口定义" class="headerlink" title="函数和接口定义"></a>函数和接口定义</h2><h3 id="函数长度"><a href="#函数长度" class="headerlink" title="函数长度"></a>函数长度</h3><p>不超过100行。</p><h3 id="函数复杂度"><a href="#函数复杂度" class="headerlink" title="函数复杂度"></a>函数复杂度</h3><p>圈复杂度小于12（易于测试）<br>认知复杂度小于15（便于理解）</p><h3 id="参数和返回值个数"><a href="#参数和返回值个数" class="headerlink" title="参数和返回值个数"></a>参数和返回值个数</h3><p>参数少于5个，返回值少于3个.<br>过多的参数请根据它们的用途归类到参数对象传递.</p><h3 id="context参数"><a href="#context参数" class="headerlink" title="context参数"></a>context参数</h3><p>必须作为函数第一个参数出现<br>禁止业务代码通过context传递参数，以明确的参数代替。<br>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    isOldUser, ok := ctx.Value(<span class="string">"is_old_user"</span>).(boo) <span class="comment">// ctx禁止传递业务参数</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isOldUser &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(ctx context.Context, isOldUser <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> isOldUser &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="枚举从1开始"><a href="#枚举从1开始" class="headerlink" title="枚举从1开始"></a>枚举从1开始</h3><p>0是Go语言的默认值，通常只有在它能代表一定意义才会使用，否则应该避免0值。<br>BAD</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">type</span> Operation int</span><br><span class="line"><span class="symbol">const</span> (</span><br><span class="line">  <span class="keyword">Add </span>Operation = iota</span><br><span class="line">  <span class="keyword">Subtract</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">Multiply</span></span><br><span class="line"><span class="keyword">)</span></span><br><span class="line"><span class="keyword">// </span><span class="keyword">Add=0, </span><span class="keyword">Subtract=1, </span><span class="keyword">Multiply=2</span></span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">type</span> Operation int</span><br><span class="line"><span class="symbol">const</span> (</span><br><span class="line">  <span class="keyword">Add </span>Operation = iota + <span class="number">1</span></span><br><span class="line">  <span class="keyword">Subtract</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">Multiply</span></span><br><span class="line"><span class="keyword">)</span></span><br><span class="line"><span class="keyword">// </span><span class="keyword">Add=1, </span><span class="keyword">Subtract=2, </span><span class="keyword">Multiply=3</span></span><br></pre></td></tr></table></figure><h3 id="使用字段名初始化结构体"><a href="#使用字段名初始化结构体" class="headerlink" title="使用字段名初始化结构体"></a>使用字段名初始化结构体</h3><p>初始化结构体时，应该指定字段名称。<br>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;<span class="string">"John"</span>, <span class="string">"Doe"</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line"><span class="symbol">    FirstName:</span> <span class="string">"John"</span>,</span><br><span class="line"><span class="symbol">    LastName:</span> <span class="string">"Doe"</span>,</span><br><span class="line"><span class="symbol">    Admin:</span> true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用常量代替魔法数字"><a href="#用常量代替魔法数字" class="headerlink" title="用常量代替魔法数字"></a>用常量代替魔法数字</h3><p>对于有意义的魔法数字，必须用常量代替</p><p>BAD</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch processState &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch processState &#123;</span><br><span class="line">case <span class="keyword">state</span>Successfully:</span><br><span class="line">...</span><br><span class="line">case <span class="keyword">state</span>ExitWithError:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-defer-释放资"><a href="#使用-defer-释放资" class="headerlink" title="使用 defer 释放资"></a>使用 defer 释放资</h3><p>使用 defer 释放资源，诸如文件和锁。</p><p>BAD</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>.Lock()</span><br><span class="line"><span class="keyword">if</span> <span class="selector-tag">p</span><span class="selector-class">.count</span> &lt; <span class="number">10</span> &#123;</span><br><span class="line">  <span class="selector-tag">p</span>.Unlock()</span><br><span class="line">  return <span class="selector-tag">p</span>.count</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>.count++</span><br><span class="line">newCount := <span class="selector-tag">p</span>.count</span><br><span class="line"><span class="selector-tag">p</span>.Unlock()</span><br><span class="line">return newCount</span><br><span class="line"><span class="comment">// 当有多个 return 分支时，很容易遗忘 unlock</span></span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>.Lock()</span><br><span class="line">defer <span class="selector-tag">p</span>.Unlock()</span><br><span class="line"><span class="keyword">if</span> <span class="selector-tag">p</span><span class="selector-class">.count</span> &lt; <span class="number">10</span> &#123;</span><br><span class="line">  return <span class="selector-tag">p</span>.count</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>.count++</span><br><span class="line">return <span class="selector-tag">p</span>.count</span><br><span class="line"><span class="comment">// 更可读</span></span><br></pre></td></tr></table></figure><h3 id="返回错误"><a href="#返回错误" class="headerlink" title="返回错误"></a>返回错误</h3><p>错误类型必须是error接口<br>如果调用者需要检测某种特定错误，必须返回一个特定哨兵错误。<br>如果自定义错误类型，最好提供检查错误的方法。</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">"could not open"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err.Error() == <span class="string">"could not open"</span> &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err == foo.ErrCouldNotOpen &#123; <span class="comment">// 哨兵错误值</span></span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotFoundError</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  _, ok := err.(errNotFound)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(<span class="string">"testfile.txt"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := IsNotFoundError(err); ok &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理函数返回的error"><a href="#处理函数返回的error" class="headerlink" title="处理函数返回的error"></a>处理函数返回的error</h3><p>最好处理所有error。<br>对于那些不关心的error使用下划线占位符。</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> errors.New(<span class="string">"error"</span>) &#125;</span><br><span class="line">foo() <span class="comment">// 未处理的错误</span></span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> errors.New(<span class="string">"error"</span>) &#125;</span><br><span class="line"><span class="keyword">if</span> err := foo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理类型断言失败"><a href="#处理类型断言失败" class="headerlink" title="处理类型断言失败"></a>处理类型断言失败</h3><p>使用”comma ok”的语句形式</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="comment">// 优雅地处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理panic"><a href="#处理panic" class="headerlink" title="处理panic"></a>处理panic</h3><p>对于可以预料的错误不应该产生panic，应该返回错误由调用者处理，必要时加上监控或上报sentry。</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">raiseError</span><span class="params">(e <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errors.New(<span class="string">"error occur"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">raiseError</span><span class="params">(e <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"error occur"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管理goruntine"><a href="#管理goruntine" class="headerlink" title="管理goruntine"></a>管理goruntine</h3><p>goruntine需要在入口处recover住panic并处理panic。<br>goruntine要有明确的生命周期管理，如果有长时间运行的goruntine，需要通过context传递结束信号。</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mayPanic</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rand.Int()%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(errors.New(<span class="string">"surprise"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mayPanic()</span><br><span class="line">&#125; ()</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">mayPanic()</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片 Slice"></a>切片 Slice</h3><ul><li><p>取元素之前需要确保索引不超过有效长度。</p></li><li><p>要检查切片是否为空，请始终使用len(s) == 0。而非 nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>不应明确返回长度为零的切片。应该返回nil来代替</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>零值切片（用var声明的切片）可立即使用，无需调用make()创建。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="在边界处拷贝-Slices-和-Maps"><a href="#在边界处拷贝-Slices-和-Maps" class="headerlink" title="在边界处拷贝 Slices 和 Maps"></a>在边界处拷贝 Slices 和 Maps</h3><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。<br>接收 Slices 和 Maps<br>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = trips</span><br><span class="line">&#125;</span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"><span class="comment">// 你是要修改 d1.trips 吗？</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))</span><br><span class="line">  <span class="built_in">copy</span>(d.trips, trips)</span><br><span class="line">&#125;</span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"><span class="comment">// 这里我们修改 trips[0]，但不会影响到 d1.trips</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br><span class="line">返回 slices 或 maps</span><br><span class="line">同样，请注意用户对暴露内部状态的 <span class="keyword">map</span> 或 slice 的修改。</span><br></pre></td></tr></table></figure><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Snapshot 返回当前状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> s.counters</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// snapshot 不再受互斥锁保护</span></span><br><span class="line"><span class="comment">// 因此对 snapshot 的任何访问都将受到数据竞争的影响</span></span><br><span class="line"><span class="comment">// 影响 stats.counters</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">  result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(s.counters))</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;</span><br><span class="line">    result[k] = v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// snapshot 现在是一个拷贝</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure><h3 id="减少嵌套"><a href="#减少嵌套" class="headerlink" title="减少嵌套"></a>减少嵌套</h3><p>代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。<br>嵌套层级最好不要超过3层。</p><p>BAD</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123; <span class="comment">// 第一层</span></span><br><span class="line">  <span class="keyword">if</span> v.F1 == 1 &#123; <span class="comment">// 第二层</span></span><br><span class="line">    v = process(v)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> := v.Call(); <span class="keyword">err</span> == nil &#123; <span class="comment">// 第三层</span></span><br><span class="line">      v.Send()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">log</span>.Printf(<span class="string">"quot;Invalid v: %v"</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 != 1 &#123;</span><br><span class="line">    <span class="keyword">log</span>.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  v = process(v)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">err</span> := v.Call(); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">  &#125;</span><br><span class="line">  v.Send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免在闭包中引用循环变量"><a href="#避免在闭包中引用循环变量" class="headerlink" title="避免在闭包中引用循环变量"></a>避免在闭包中引用循环变量</h3><p>在闭包中引用循环变量经常会导致非预期的结果，产生bug。</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">GOOD</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;(s) <span class="comment">// 传值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> option <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">    opt *option</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newConfig</span><span class="params">(opt *option)</span> *<span class="title">config</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;config&#123;opt: opt&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> []option&#123;option&#123;A:<span class="number">10</span>&#125;, option&#123;A:<span class="number">20</span>&#125;&#125; &#123;</span><br><span class="line">   v := opt <span class="comment">// 拷贝一次</span></span><br><span class="line">   newConfig(&amp;v) <span class="comment">// 把临时变量指针保存以后使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不必要的-else"><a href="#不必要的-else" class="headerlink" title="不必要的 else"></a>不必要的 else</h3><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p><p>BAD</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> int</span><br><span class="line"><span class="keyword">if</span> <span class="selector-tag">b</span> &#123;</span><br><span class="line">  <span class="selector-tag">a</span> = <span class="number">100</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="selector-tag">a</span> = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> <span class="selector-tag">b</span> &#123;</span><br><span class="line">  <span class="selector-tag">a</span> = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外部调用"><a href="#外部调用" class="headerlink" title="外部调用"></a>外部调用</h2><h3 id="设置超时"><a href="#设置超时" class="headerlink" title="设置超时"></a>设置超时</h3><p>调用外部系统例如HTTP服务、数据库等必须设置一个超时时间</p><p>BAD</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.<span class="builtin-name">Get</span>(url)</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">   <span class="attribute">Timeout</span>: time<span class="variable">.Millisecond</span> * time<span class="variable">.Duration</span>(conf<span class="variable">.TimeoutMS</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免数据库事务被用户取消"><a href="#避免数据库事务被用户取消" class="headerlink" title="避免数据库事务被用户取消"></a>避免数据库事务被用户取消</h3><p>在事务中谨慎使用从用户请求传递过来的context，因为可能会随着用户请求取消而产生非预期的行为</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestHandle</span><span class="params">(ctx context.Context, param <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    db.Txx(ctx, param() <span class="comment">// 直接调用会因为用户取消而导致事务失败，如果这个行为不是你想要的，那么很可能会导致问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestHandle</span><span class="params">(ctx context.Context, param <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    txCtx, cancel := context.WithTimeout(context.Background(), <span class="number">100</span>*time.Millisecond)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    db.Txx(txCtx, param() <span class="comment">// 重新设定超时时间，用户取消也会在超时时间内执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免散播存储层的错误"><a href="#避免散播存储层的错误" class="headerlink" title="避免散播存储层的错误"></a>避免散播存储层的错误</h3><p>避免调用者检查数据库返回的错误，需要把关注的错误码转换成其他形式返回给调用者</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getValueFromRedis</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(val *<span class="keyword">struct</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, redis.Nil</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v, err := getValueFromRedis(<span class="string">""</span>)</span><br><span class="line">    <span class="comment">// 在下层处理redis.Nil，返回(nil,nil)或者自定义错误(nil, ErrKeyNotExists)</span></span><br><span class="line">    <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getValueFromRedis</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(val *<span class="keyword">struct</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v, err := getValueFromRedis(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否为空指针</span></span><br><span class="line">    <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件布局"><a href="#文件布局" class="headerlink" title="文件布局"></a>文件布局</h2><p>从上到下依次为:</p><ul><li>常量定义</li><li>变量定义</li><li>类型定义</li><li>类型构造函数</li><li>类型方法 </li><li>(多个类型)…</li><li>全局函数</li></ul><p>函数根据调用顺序，被调用函数放在调用者之后<br>类型定义和类型构造函数、类型方法定义不能分散到多个文件里面</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="使用表驱动测试"><a href="#使用表驱动测试" class="headerlink" title="使用表驱动测试"></a>使用表驱动测试</h3><p>使用表驱动搭配断言来编写测试用例</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LVS notes</title>
      <link href="/2019/04/06/LVS-notes/"/>
      <url>/2019/04/06/LVS-notes/</url>
      
        <content type="html"><![CDATA[<h3 id="LVS-Linux-Virtual-Server"><a href="#LVS-Linux-Virtual-Server" class="headerlink" title="LVS (Linux Virtual Server)"></a>LVS (Linux Virtual Server)</h3><p>它是一种集群(Cluster)技术，采用IP负载均衡技术</p><p><img src="/images/15545381191583.jpg" alt=""></p><h4 id="主要组成部分"><a href="#主要组成部分" class="headerlink" title="主要组成部分"></a>主要组成部分</h4><p>负载调度器(load balancer/ Director)<br>服务器池(server pool/ Realserver)<br>共享存储(shared storage)</p><h4 id="负载均衡方式"><a href="#负载均衡方式" class="headerlink" title="负载均衡方式"></a>负载均衡方式</h4><ul><li><p>Virtual Server via Network Address Translation NAT(VS/NAT) </p><p>  NAT修改请求的目的VIP和端口为选出来的后端服务器的IP和端口，发送给真实处理的服务器<br>  服务器处理完成，通过设置默认网关为VIP，返回结果给调度器<br>  调度器修改结果的源IP和端口为VIP和端口，然后返回给客户端<br>  in/out的流量都要经过调度器<br>  当集群规模变大，调度器可能成为瓶颈</p></li><li><p>Virtual Server via IP Tunneling(VS/TUN)</p><p>  调度器对请求的IP报文进行封装，外层为真实服务器IP<br>  真实服务器收到包后进行解封，获得目的地址为VIP的包，通过设置隧道设备为VIP让内核处理这个包<br>  处理完直接返回给客户端，因为目的地址是VIP，返回的源地址也是VIP<br>  调度器转发的端口和后端服务器的端口需要一致，调度器需要维护连接状态<br>  <img src="/images/15545381400249.jpg" alt=""></p><p>  建立tunnel对IP报文封包转发，返回报文直接发送给用户<br>  需要内核支持IP-tunnel协议，性能较高</p></li><li><p>Virtual Server via Direct Routing(VS/DR)</p><p>  <img src="/images/15545381565629.jpg" alt=""></p></li></ul><pre><code>修改报文Mac地址路由给real-server，真实服务器配置一个非ARP设备的IP为VIP来接收并处理请求返回报文直接发送给用户调度器转发的端口和后端服务器的端口需要一致，调度器需要维护连接状态需要real-server有一块网卡和调度器连接在同一网段，性能高</code></pre><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><table><thead><tr><th>_</th><th>VS/NAT</th><th>VS/TUN</th><th>VS/DR</th></tr></thead><tbody><tr><td>Server</td><td>any</td><td>Tunneling</td><td>Non-arp device</td></tr><tr><td>server network</td><td>private</td><td>LAN/WAN</td><td>LAN</td></tr><tr><td>server number</td><td>low (10~20)</td><td>High (100)</td><td>High (100)</td></tr><tr><td>server gateway</td><td>load balancer</td><td>own router</td><td>Own router</td></tr></tbody></table><h4 id="负载均衡调度算法"><a href="#负载均衡调度算法" class="headerlink" title="负载均衡调度算法"></a>负载均衡调度算法</h4><ul><li>最少的连接方式(Least Connection)</li><li>最快模式(Fastest)</li><li>观察模式(Observed)</li><li>预测模式(Predictive)</li><li>动态性能分配(Dynamic Ratio-APM)</li><li>动态服务器补充(Dynamic Server Act.)</li><li>服务质量(QoS)</li><li>服务类型(ToS)</li><li>规则模式</li></ul><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>主备模式<br>ARP欺骗切换IP<br>多线路存活探测<br>高效状态同步</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.linuxvirtualserver.org/zh/lvs3.html" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/zh/lvs3.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang Channel小结</title>
      <link href="/2018/10/17/Golang-Channel%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/10/17/Golang-Channel%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="确保接收"><a href="#确保接收" class="headerlink" title="确保接收"></a>确保接收</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">01 </span>go func() &#123;</span><br><span class="line"><span class="symbol">02 </span>    p := &lt;-ch // Receive</span><br><span class="line"><span class="symbol">03 </span>&#125;()</span><br><span class="line"><span class="number">04</span></span><br><span class="line"><span class="symbol">05 </span>ch &lt;- <span class="string">"paper"</span> // Send</span><br></pre></td></tr></table></figure><p>以上代码，当05行发送之后，不同的channel接收者的行为不同。</p><p>channel类型：</p><ul><li><p>Buffered</p><p>  确保接收之后发送的代码才继续执行</p></li><li><p>Unbuffered</p><p>  发送代码继续执行，不确保此时被接收</p></li></ul><h4 id="状态和行为"><a href="#状态和行为" class="headerlink" title="状态和行为"></a>状态和行为</h4><p>状态：</p><ul><li>nil</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ** nil channel</span><br><span class="line">// A channel is <span class="keyword">in</span> a nil <span class="keyword">state</span> when it is declared <span class="keyword">to</span> its zero value</span><br><span class="line">var ch chan string</span><br><span class="line"></span><br><span class="line">// A channel can be placed <span class="keyword">in</span> a nil <span class="keyword">state</span> by explicitly setting it <span class="keyword">to</span> nil.</span><br><span class="line">ch = nil</span><br></pre></td></tr></table></figure><ul><li>open </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ** open channel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A channel is in a open state when it’s made using the built-in function make.</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure><ul><li>closed</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">// ** closed channel</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> A channel <span class="keyword">is</span> <span class="keyword">in</span> a closed state <span class="keyword">when</span> <span class="literal">it</span>’s closed using the built-<span class="keyword">in</span> <span class="keyword">function</span> close.</span><br><span class="line">close(ch)</span><br></pre></td></tr></table></figure><p>行为：</p><table><thead><tr><th>操作\状态</th><th>Nil</th><th>Open</th><th>Closed</th></tr></thead><tbody><tr><td>Send</td><td>Blocked</td><td>Allowed</td><td>Panic</td></tr><tr><td>Receive</td><td>Blocked</td><td>Allowed</td><td>Allowed</td></tr><tr><td>Close</td><td>Panic</td><td>Allowed</td><td>Panic</td></tr></tbody></table><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell基础语法</title>
      <link href="/2018/09/02/shell%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/09/02/shell%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="shell基础语法"><a href="#shell基础语法" class="headerlink" title="shell基础语法"></a>shell基础语法</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ expression ][</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> test expression; <span class="keyword">then</span></span><br><span class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ expression <span class="number">1</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="number">1</span> <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line">elif [[ expression <span class="number">2</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="number">2</span> <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line">elif [[ expression <span class="number">3</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="number">3</span> <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> <span class="literal">no</span> expression <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SERVICES=<span class="string">"80   22   25   110   8000   23   20   21   3306   "</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="variable">$SERVICES</span>; do</span><br><span class="line">  iptables -A INPUT -p tcp --dport <span class="variable">$x</span> -m <span class="keyword">state</span> --state NEW -j ACCEPT</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以下是Bash的用法，与zsh的不同</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a=(1 2 3 4 5)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$a</span></span></span><br><span class="line">1</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;#a[@]&#125;</span> <span class="comment"># 用$&#123;#数组名[@或*]&#125; 可以得到数组长度</span></span></span><br><span class="line">5</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;a[*]&#125;</span> <span class="comment"># 用$&#123;数组名[下标]&#125; 下标是从0开始  下标是：*或者@ 得到整个数组内容</span></span></span><br><span class="line">1 2 3 4 5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接通过 数组名[下标] 就可以对其进行引用赋值，如果下标不存在，自动添加新一个数组元素到数组末尾</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a[1]=100 &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;a[1]&#125;</span></span></span><br><span class="line">100</span><br><span class="line"><span class="meta">#</span><span class="bash"> a[10]=100 &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;a[*]&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;a[10]&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;#a[*]&#125;</span></span></span><br><span class="line">1 2 3 4 5 100</span><br><span class="line">100</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接通过：<span class="built_in">unset</span> 数组[下标] 可以清除相应的元素，不带下标，清除整个数据。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">unset</span> a[1] &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;#a[*]&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;a[1]&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;a[*]&#125;</span></span></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">1 3 4 5 100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接通过 <span class="variable">$&#123;数组名[@或*]:起始位置:长度&#125;</span> 切片原先数组，返回是字符串，中间用“空格”分开，因此如果加上”()”，将得到切片数组，上面例子：c 就是一个新数据。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a=(1 2 3 4 5) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;a[@]:0:3&#125;</span></span></span><br><span class="line">1 2 3</span><br><span class="line"><span class="meta">#</span><span class="bash"> c=(<span class="variable">$&#123;a[@]:1:4&#125;</span>) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;#c[@]&#125;</span></span></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换元素调用方法是：<span class="variable">$&#123;数组名[@或*]/查找字符/替换字符&#125;</span> 该操作不会改变原先数组内容，如果需要修改，可以看上面例子，重新定义数据。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a=(1 2 3 4 5) &amp;&amp; c=(<span class="variable">$&#123;a[@]/3/100&#125;</span>) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;c[@]&#125;</span></span></span><br><span class="line">1 2 100 4 5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断元素是否在数组中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> [[ <span class="variable">$&#123;array[@]&#125;</span> =~ <span class="variable">$item</span> ]]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">'yes'</span>; <span class="keyword">fi</span></span></span><br></pre></td></tr></table></figure><h4 id="命令行解析"><a href="#命令行解析" class="headerlink" title="命令行解析"></a>命令行解析</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># use <span class="keyword">break</span> to jump <span class="keyword">out</span> <span class="keyword">for</span> loop</span><br><span class="line"><span class="keyword">for</span> opt <span class="keyword">in</span> $@; <span class="keyword">do</span></span><br><span class="line">case $opt <span class="keyword">in</span></span><br><span class="line"><span class="keyword">init</span>) project_init</span><br><span class="line"><span class="keyword">break</span>;;</span><br><span class="line">start) start_train</span><br><span class="line"><span class="keyword">break</span>;;</span><br><span class="line">stop) stop_train</span><br><span class="line"><span class="keyword">break</span>;;</span><br><span class="line">resume) resume_train</span><br><span class="line"><span class="keyword">break</span>;;</span><br><span class="line">*) show_usage</span><br><span class="line"><span class="keyword">break</span>;;</span><br><span class="line">esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><ul><li><p>通过子命令的方式</p><p>  函数内部任何标准输出都会返回给接收变量，结果容易受到输出日志的干扰</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">a=$(foo)</span><br><span class="line"><span class="keyword">echo</span> $a <span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure></li><li><p>通过return返回整数值，<code>$?</code>获取</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">foo <span class="comment"># 1 2</span></span><br><span class="line"><span class="keyword">echo</span> $? <span class="comment"># 0</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><ul><li>截取字符串</li></ul><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>$&#123;#string}</td><td>$string的长度</td></tr><tr><td><code>${string:position}</code></td><td>在$string中, 从位置$position开始提取子串</td></tr><tr><td><code>${string:position:length}</code></td><td>在$string中, 从位置$position开始提取长度为$length的子串</td></tr><tr><td><code>${string#substring}</code></td><td>从变量$string的开头, 删除最短匹配$substring的子串</td></tr><tr><td><code>${string##substring}</code></td><td>从变量$string的开头, 删除最长匹配$substring的子串</td></tr><tr><td><code>${string%substring}</code></td><td>从变量$string的结尾, 删除最短匹配$substring的子串</td></tr><tr><td><code>${string%%substring}</code></td><td>从变量$string的结尾, 删除最长匹配$substring的子串</td></tr><tr><td><code>${string/substring/replacement}</code></td><td>使用$replacement, 来代替第一个匹配的$substring</td></tr><tr><td><code>${string//substring/replacement}</code></td><td>使用$replacement, 代替所有匹配的$substring</td></tr><tr><td><code>${string/#substring/replacement}</code></td><td>如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</td></tr><tr><td><code>${string/%substring/replacement}</code></td><td>如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</td></tr></tbody></table><ul><li><p>示例:</p><pre><code>${str:0:-1} 去掉最后一个字符${str:0: ${#str}} 返回整个字符串。避免写成$#str，$#有特殊含义，是传给函数或脚本的参数个数``` </code></pre></li><li><p>定义字符串</p></li></ul><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>${var}</code></td><td>变量var的值, 与$var相同</td></tr><tr><td><code>${var-DEFAULT}</code></td><td>如果var没有被声明, 那么就以$DEFAULT作为其值，但是不会改变变量的值 *</td></tr><tr><td><code>${var:-DEFAULT}</code></td><td>如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 *</td></tr><tr><td><code>${var=DEFAULT}</code></td><td>如果var没有被声明, 那么就以$DEFAULT作为其值，跟上面<code>-</code>的区别在于会设置变量的值 *</td></tr><tr><td><code>${var:=DEFAULT}</code></td><td>如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 *</td></tr><tr><td><code>${var+OTHER}</code></td><td>如果var声明了, 那么其值就是$OTHER, 否则就为null字符串</td></tr><tr><td><code>${var:+OTHER}</code></td><td>如果var被设置了, 那么其值就是$OTHER, 否则就为null字符串</td></tr><tr><td><code>${var?ERR_MSG}</code></td><td>如果var没被声明, 那么就打印$ERR_MSG *</td></tr><tr><td><code>${var:?ERR_MSG}</code></td><td>如果var没被设置, 那么就打印$ERR_MSG *</td></tr><tr><td><code>${!varprefix*}</code></td><td>匹配之前所有以varprefix开头进行声明的变量</td></tr><tr><td><code>${!varprefix@}</code></td><td>匹配之前所有以varprefix开头进行声明的变量</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git Hooks</title>
      <link href="/2018/09/02/Git-Hooks/"/>
      <url>/2018/09/02/Git-Hooks/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-Hooks"><a href="#Git-Hooks" class="headerlink" title="Git Hooks"></a>Git Hooks</h2><p>git通过hooks来定制行为，所有的hooks存储在<code>hooks</code>目录，客户端是<code>.git/hooks</code>目录。<br><code>git init</code>的时候会在<code>.git/hooks</code>目录生成很多示例hook，只要重命名文件就能启用。</p><p>hook分为</p><ul><li>客户端hook</li><li>服务端hook</li></ul><p>客户端hook不会被克隆，如果要强制实现某个git策略，需要用服务端hook。</p><h3 id="客户端hook"><a href="#客户端hook" class="headerlink" title="客户端hook"></a>客户端hook</h3><p>客户端hook在工程目录下运行<br>客户端hook又可以分为</p><ul><li>committing-workflow</li><li>email-workflow</li><li>其他</li></ul><h4 id="committing-workflow"><a href="#committing-workflow" class="headerlink" title="committing-workflow"></a>committing-workflow</h4><ul><li><p>pre-commit</p><p>  第一个运行的hook，在创建提交message之前就运行。<br>  返回非0则终止提交，但是可以用<code>git commit --no-verify</code>来跳过检查。<br>  可以在这个hook中运行测试，检查代码格式，做代码静态检查等。</p></li><li><p>prepare-commit-msg</p><p>  在默认commit message创建之后，打开message编辑器之前运行。<br>  会传入几个参数：当前消息文件路径、commit类型，如果是amend提交再加上commit的SHA-1。<br>  一般用来生成自动提交的信息。</p></li><li><p>commit-msg</p><p>  编辑完提交消息之后运行。<br>  传入一个参数：保存用户提交消息的临时文件的路径。<br>  返回非0终止提交。<br>  一般用来验证消息格式。</p></li><li><p>post-commit    </p><p>  提交完成之后运行。<br>  一般用来做提交通知。</p></li></ul><h4 id="email-workflow-hooks"><a href="#email-workflow-hooks" class="headerlink" title="email-workflow hooks"></a>email-workflow hooks</h4><p>通过<code>git am</code>命令调用，如果你需要通过email来接收patch，可能会用到这个类型的hook。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>pre-rebase</p><p>  rebase之前运行。<br>  返回非0终止rebase。</p></li><li><p>post-rewrite</p><p>  <code>git commit --amend</code>和<code>git rebase</code>会触发这个hook。<br>  传入参数：触发hook的命令。</p></li><li><p>post-checkout</p><p>  checkout成功之后运行。</p></li><li><p>post-merge</p><p>  merge成功之后运行。</p></li><li><p>pre-push</p><p>  remote ref更新之后，传输对象之前运行。<br>  返回非0终止push。<br>  传入参数：远端的名称和地址。</p></li><li><p>pre-auto-gc</p><p>  由<code>git gc --auto</code>触发。</p></li></ul><h3 id="服务端hook"><a href="#服务端hook" class="headerlink" title="服务端hook"></a>服务端hook</h3><p>服务端hook在服务器的工程<code>.git</code>目录下运行</p><ul><li><p>pre-receive</p><p>  服务端接收push第一个运行的hook，从stdin接收被push过来的references。<br>  返回非0则终止push。</p></li><li><p>update</p><p>  类似pre-receive，但是每个分支运行一次。<br>  传入三个参数：分支名、前一个commit的SHA-1，当前push的SHA-1<br>  返回非0则终止push。    </p></li><li><p>post-receive</p><p>  所有流程完成之后运行。<br>  跟pre-receive一样从stdin传入references。<br>  客户端等待这个脚本完成才断开连接。</p></li></ul><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" target="_blank" rel="noopener">https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks</a><br><a href="https://docs.gitlab.com/ee/administration/custom_hooks.html" target="_blank" rel="noopener">https://docs.gitlab.com/ee/administration/custom_hooks.html</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git hook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cpp Static Initialization Order Fiasco</title>
      <link href="/2017/01/20/Cpp-Static-initialization-order-fiasco/"/>
      <url>/2017/01/20/Cpp-Static-initialization-order-fiasco/</url>
      
        <content type="html"><![CDATA[<h3 id="Static-initialization-order-fiasco"><a href="#Static-initialization-order-fiasco" class="headerlink" title="Static initialization order fiasco"></a>Static initialization order fiasco</h3><ul><li><p>Construct On First Use Idiom</p><ul><li><p>If the object does not need to be destructed, uses a static pointer.</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File x.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Fred.h"</span></span></span><br><span class="line"><span class="function">Fred&amp; <span class="title">x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Fred* ans = <span class="keyword">new</span> Fred();</span><br><span class="line">  <span class="keyword">return</span> *ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File Barney.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"Barney.h"</span></span></span><br><span class="line"><span class="symbol">Barney:</span>:Barney()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  x().goBowling();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This approach is that the Fred object is <strong>never destructed</strong>.<br>The Construct On First Use Idiom uses a pointer and intentionally leaks the object.</p></li><li><p>If you need to destruct the object and do not care the order of static objects deinitialization, uses a static object.</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File x.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Fred.h"</span></span></span><br><span class="line"><span class="function">Fred&amp; <span class="title">x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Fred ans;  <span class="comment">// was static Fred* ans = new Fred();</span></span><br><span class="line">  <span class="keyword">return</span> ans;       <span class="comment">// was return *ans;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  It does not leak the object, but <strong>it does not control the order of static deinitialization</strong>, so it is (very!) unsafe to use the object during static deinitialization, that is, from a destructor of another statically declared object.</p></li></ul></li><li><p>Nifty Counter</p><p>  It is a more complicated solution that solves problems mentioned above.</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STREAM_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STREAM_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stream</span> &#123;</span></span><br><span class="line">  Stream ();</span><br><span class="line">  ~Stream ();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> Stream&amp; stream; <span class="comment">// global stream object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">StreamInitializer</span> &#123;</span></span><br><span class="line">  StreamInitializer ();</span><br><span class="line">  ~StreamInitializer ();</span><br><span class="line">&#125; streamInitializer; <span class="comment">// static initializer for every translation unit</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STREAM_H</span></span></span><br></pre></td></tr></table></figure>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Stream.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;         // placement new</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt; // aligned_storage</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nifty_counter; <span class="comment">// zero initialized at load time</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">typename</span> std::aligned_storage&lt;<span class="keyword">sizeof</span> (<span class="built_in">Stream</span>), <span class="keyword">alignof</span> (<span class="built_in">Stream</span>)&gt;::type</span><br><span class="line">  stream_buf; <span class="comment">// memory for the stream object</span></span><br><span class="line"><span class="built_in">Stream</span>&amp; stream = <span class="keyword">reinterpret_cast</span>&lt;<span class="built_in">Stream</span>&amp;&gt; (stream_buf);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Stream</span>::<span class="built_in">Stream</span> ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// initialize things</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Stream</span>::~<span class="built_in">Stream</span> ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// clean-up</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">StreamInitializer::StreamInitializer ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">if</span> (nifty_counter++ == <span class="number">0</span>) <span class="keyword">new</span> (&amp;stream) <span class="built_in">Stream</span> (); <span class="comment">// placement new</span></span><br><span class="line">&#125;</span><br><span class="line">StreamInitializer::~StreamInitializer ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">if</span> (--nifty_counter == <span class="number">0</span>) (&amp;stream)-&gt;~<span class="built_in">Stream</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  The header file of the Stream class <strong>must be included before any member function can be called on the Stream object</strong>.<br>  An instance of the StreamInitializer class is included in each compilation unit. Any use of the Stream object follows the inclusion of the header, which ensures that the constructor of the initializer object is called before the Stream object is used.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go-doc-tips</title>
      <link href="/2016/12/18/go-doc-tips/"/>
      <url>/2016/12/18/go-doc-tips/</url>
      
        <content type="html"><![CDATA[<h3 id="Go-doc-tips"><a href="#Go-doc-tips" class="headerlink" title="Go doc tips"></a>Go doc tips</h3><ol><li><p>新建<code>doc.go</code>作为文档文件，<code>package pkgname</code>之前的注释作为文档。</p></li><li><p>文档注释的格式</p><ol><li>相邻的行位于同一段落，分段需要添加空行</li><li>上下空行的短语会被作为接下来段落的head</li><li>预先格式化的文本需要跟周围的注释保持缩进</li><li>URL会被转换成链接，不需要标记</li></ol></li><li><p>Go同一个目录可以添加<code>{pkg}_test</code>的测试包。</p></li><li><p>包<code>{pkg}_test</code>的文件(<code>_test.go</code>结尾)，函数名以<code>Example</code>开头且没有参数的函数作为示例代码。</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleFoo</span><span class="params">()</span></span>     <span class="comment">// documents the Foo function or type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleBar_Qux</span><span class="params">()</span></span> <span class="comment">// documents the Qux method of type Bar</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example</span><span class="params">()</span></span>        <span class="comment">// documents the package as a whole</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleReverse</span><span class="params">()</span></span> <span class="comment">// Reverse first example</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleReverse_second</span><span class="params">()</span></span> <span class="comment">// Reverse second example</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleReverse_third</span><span class="params">()</span></span> <span class="comment">// Reverse thirdß example</span></span><br></pre></td></tr></table></figure><p> <code>_test.go</code>结尾的文件，如果只包含一个<code>Example</code>函数，并且有其他包级声明，整个文件会作为示例代码显示。</p></li><li><p><code>// Output: olleh</code>预期输出，示例函数可以作为<code>go test</code>的测试用例。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stringutil_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/golang/example/stringutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleReverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(stringutil.Reverse(<span class="string">"hello"</span>))</span><br><span class="line">    <span class="comment">// Output: olleh</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim-shortcut</title>
      <link href="/2016/12/12/vim-shortcut/"/>
      <url>/2016/12/12/vim-shortcut/</url>
      
        <content type="html"><![CDATA[<h3 id="vim快捷键"><a href="#vim快捷键" class="headerlink" title="vim快捷键"></a>vim快捷键</h3><h4 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h4><ol><li><p>行内跳转 </p><p> <code>^</code> 行开头<br> <code>$</code> 行尾<br> <code>w/W</code> 下一个单词开头<br> <code>e/E</code> 下一个单词末尾<br> <code>b/B</code> 上一个单词开头<br> <code>f+{字符}</code> 下一个字符本身 <code>F+{字符}</code> 上一个字符本身<br> <code>t+{字符}</code> 下一个字符之后 <code>T+{字符}</code> 上一个字符之后</p></li></ol><ol start="2"><li><p>跨行跳转</p><p> <code>h</code> 左 <code>j</code> 下 <code>k</code> 上 <code>l</code> 右<br> <code>{数字}+h/j/k/l</code> 跳转n个位置<br> <code>{数字}+G</code> 跳转到第n行<br> <code>*</code> 向下搜索光标对应单词<br> <code>#</code> 向上搜索光标对应单词<br> <code>gg</code> 文件开头<br> <code>G</code> 文件末尾<br> <code>ctrl+b</code> 向上翻页<br> <code>ctrl+f</code> 向下翻页<br> <code>ctrl+u</code> 向上翻半页<br> <code>ctrl+d</code> 向下翻半页<br> <code>ctrl+o</code> 跳转到光标上一个位置<br> <code>ctrl+i</code> 跳转到光标下一个位置</p></li></ol><h4 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h4><ol><li><p>行内编辑</p><p> <code>x</code> 删除一个字符<br> <code>{数字}+x</code> 删除n个字符<br> <code>dd</code> 删除一行，包括换行<br> <code>d+{数字}+d</code> / <code>{数字}+dd</code> 删除n行<br> <code>d+w/W</code> / <code>d+e/E</code> 向后删除一个单词<br> <code>d+b/B</code> 向前删除一个单词<br> <code>D</code> / <code>d+$</code> 删除光标之后所有字符，不包括换行<br> <code>i</code> 光标之前插入<br> <code>a</code> 光标之后插入<br> <code>r</code> 替换光标处字符<br> <code>{数字}+r</code>    替换光标开始n个字符<br> <code>o</code> 插入下一行，光标跳转到新行<br> <code>O</code> 插入上一行，光标跳转到新行</p></li><li><p>复制粘贴</p><p> <code>yy</code> 复制一行<br> <code>{数字}+yy</code> / <code>y+{数字}+y</code> 复制n行<br> <code>y+{位置}+y</code> 复制光标与某一行直接的内容<br> <code>y+w/W</code> / <code>y+e/E</code> 向后复制一个单词<br> <code>y+b/B</code> 向前复制一个单词<br> <code>p</code> 在光标后粘贴<br> <code>P</code> 在光标前粘贴<br> <code>{数字}+p</code> 多次粘贴</p></li></ol><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ol><li><p>常规模式</p><p> <code>:h registers</code> 查看man page<br> <code>&quot;+{寄存器名}</code> 引用一个寄存器<br> <code>&quot;&quot;</code> 未命名寄存器，复制或删除都会替换它的内容<br> <code>&quot;0~&quot;9</code> <code>&quot;0</code> 保存最后一次复制内容 <code>&quot;1</code>~<code>&quot;9</code> 保存最后删除的内容，<code>&quot;1</code>为最近删除<br> <code>&quot;+{寄存器名}+y</code> 复制到指定寄存器<br> <code>&quot;+{寄存器名}+p</code> 粘贴指定寄存器内容<br> <code>:reg {寄存器名}</code> 查看寄存器内容<br> <code>&quot;.</code> <code>&quot;%</code> <code>&quot;:</code> <code>&quot;#</code> 只读寄存器</p><blockquote></blockquote><p> <code>&quot;.</code>存最后插入的内容；<code>&quot;%</code>存当前文件相对于vim打开时的路径；<code>&quot;:</code>存最后执行的命令，使用<code>@:</code>重复执行上一次命令；<code>&quot;#</code>存替换文件名</p><p> <code>&quot;=</code>保存表达式或命令结果，<code>ctrl-r =</code>可以在插入模式下粘贴结果，<code>:%s/&lt;Ctrl-r&gt;/something/g</code>可以直接替换之前搜索的结果<br> <code>:let @{寄存器名}=&#39;&lt;Ctrl-r {寄存器名}&gt;&#39;</code> 可以修改寄存器内容</p></li><li><p>编辑模式 </p><p> <code>ctrl+r+{寄存器名}</code> 粘贴寄存器内容</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ssh-settings</title>
      <link href="/2016/05/24/ssh-settings/"/>
      <url>/2016/05/24/ssh-settings/</url>
      
        <content type="html"><![CDATA[<h4 id="记一下平时用到的有用的ssh设置和命令"><a href="#记一下平时用到的有用的ssh设置和命令" class="headerlink" title="记一下平时用到的有用的ssh设置和命令"></a>记一下平时用到的有用的ssh设置和命令</h4><ol><li><p>设置防止自动断开<br><code>ssh user@host -o ServerAliveInterval=30</code><br><code>-o</code>可以设置很多选项，<code>ServerAliveInterval</code>设置隔多少秒没收到数据之后，给对方发送消息请求响应，防止连接被中断</p></li><li><p>公钥验证免密码登陆<br>服务端设置: 修改 <code>/etc/ssh/sshd_config</code>，设置 <code>RSAAuthentication yes</code>，重启ssh服务<br>本机: 生成公钥 <code>$ ssh-keygen</code>，上传公钥 <code>$ ssh user@host &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></p></li><li><p>利用session clone来打开多个会话<br>本机: 修改 <code>~/.ssh/config</code>文件，加入下面内容</p><pre><code>#file:~/.ssh/configHost *ControlMaster autoControlPath ~/.ssh/master-%r@%h:%pControlPersist 10m</code></pre><p> 上面的配置在第一次建立ssh连接的时候把连接作为master，后面的连接都会复用第一次建立的网络连接，通过ControlPath下面的文件来确定复用哪个。只要第一个连接不中断，后面ssh命令就可以不输入密码直接连接了。</p></li><li><p>利用tmux和session clone实现免密码登录<br>找一台私人服务器，按照上面3步骤配置ssh的session clone<br>创建tmux session: <code>tmux new -s session</code><br>在tmux里面登录: <code>ssh user@host -o ServerAliveInterval=30</code><br>这样你打开新的tmux窗口直接ssh就不需要密码了<br>终端退出tmux: <code>ctrl-b &amp;</code>关闭窗口, <code>ctrl-b d</code>detach tmux client，这样tmux session的进程并不会退出，里面登录的ssh session也会保存下来<br>重新登录: <code>tmux attach -t session</code>attach client，原来登录的ssh session可以继续使用<br>登出服务器: 终端退出tmux后把tmux转到后台，假设1号job是tmux执行<code>disown %1</code>，如果进程被挂起需要执行<code>kill -cont -42813</code>，42813是tmux的pid</p></li><li><p>本地端口转发<br><code>$ ssh -NT -D 8080 host</code></p></li><li><p>python自动ssh登录<br>利用下面两个库可以实现自动ssh登录<br><code>pexpect</code>模拟shell输入<br><code>pyotp</code>进行otp验证</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go使用Rsa加解密</title>
      <link href="/2016/04/15/go-rsa-notes/"/>
      <url>/2016/04/15/go-rsa-notes/</url>
      
        <content type="html"><![CDATA[<h3 id="一次使用rsa的经历"><a href="#一次使用rsa的经历" class="headerlink" title="一次使用rsa的经历"></a>一次使用rsa的经历</h3><p>   最近项目中要提供一个接口供客户端查询信息。逻辑简单主要考虑安全性问题，信息保密要求不高但是要保证是服务端返回的，也就是要防止数据被篡改和替换。</p><p>   因为只有一个这样的接口，而且申请证书比较麻烦就不考虑https了。客户端的安全性不是很可靠，如果用AES这样的对称加密，密钥放客户端会有较大风险。考虑用rsa加密来达到目的。</p><p>   初步想法是服务端保存rsa私钥，用来加密数据，客户端保存公钥，解密服务端返回的数据，这样客户端只能解服务端返回的数据，而且是密文传输。想法很简单，实现起来就遇到了问题。Go语言的rsa包提供的解密方法只能使用公钥加密。</p><p>   函数原型<br>    <code>func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err error)</code></p><p>   试验半天还是不知道如何使用私钥加密。Go论坛上有个使用私钥加密的讨论<a href="https://groups.google.com/d/msg/golang-nuts/SkOBSsqLsrE/5rLo02hutbwJ" target="_blank" rel="noopener">https://groups.google.com/d/msg/golang-nuts/SkOBSsqLsrE/5rLo02hutbwJ</a>，大概的意思是公钥大家都能拿到，用私钥加密的信息并没有起到保密的作用，一般私钥只用来签名。虽然理论上私钥加密是可以的，但在这里只好换一个思路。</p><p>   在这个场景中，签名可以达到要求，用私钥对关键信息签名，客户端用公钥校验，可以保证接受正确的服务端信息，唯一不太好的是明文传输的，需要引入一个对称加密对消息加密。</p><p>   要引入对称加密，可以由客户端随机生成key，用这个key对称加密带校验信息的数据，然后用公钥加密key，这样只有服务端能解出key。然后服务端把客户端带上来的校验信息和数据打包，使用这个key进行对称加密再返回，客户端用自己生成的key解密并校验数据。这样一个流程能保证接受正确的服务端信息，同时是密文传输。</p><p>   公钥是放在客户端的，假如被其他人拿到，破解了查询协议，最多只能查到数据。要伪造数据去欺骗其他客户端，必须同时知道其他客户端生成的key和校验信息，才能用伪造的请求的结果去欺骗这个客户端。若是AES的key泄漏，不但能查到数据，还能构造其他客户端的查询结果。</p><h3 id="rsa使用笔记"><a href="#rsa使用笔记" class="headerlink" title="rsa使用笔记"></a>rsa使用笔记</h3><p>   在跟客户端对接的过程中由于对rsa不是很熟悉，遇到了一些问题。</p><ol><li><p>padding模式<br>  rsa遵循公钥加密标准(Public Key Cryptography Standards, PKCS)，老的是1.x，一般用1.5，新的是2。对应的padding模式有三种：PKCS1V15对应v1.5，OAEP对应v2，Nopadding。Go的rsa库有前面两种，推荐使用OAEP。</p></li><li><p>hash算法<br>  Go的rsa库提供hash函数的参数，可以自己设置hash函数，推荐使用sha256。不同hash值的长度会影响OAEP模式下最大消息长度，下面会讲到。加解密的hash函数要设置成一样的，客户端使用的比较旧的openssl使用的sha1，跟我设置的不一样，因为这个调试了很久。对比了一下sha256和md5，md5要快一点。</p></li><li><p>消息长度<br>  每次加解密的消息长度有限制。对于v1.5，最大长度为<code>keyBytes-11</code>，<code>keyBytes</code>是私钥字节数，比如2048位的私钥就是256字节。对于v2，最大长度为<code>keyBytes-(hashSize*2+2)</code>，根据hash函数不同长度不同，比如sha1计算结果20字节，对于2048位的key最大长度<code>256-(20*2+2)</code>。<br>  如果原文超过了这个一般就分块进行加密。</p></li></ol><h3 id="rsa简介"><a href="#rsa简介" class="headerlink" title="rsa简介"></a>rsa简介</h3><ol><li><p>选择质数<code>p</code>和<code>q</code>，计算<code>n=p*q</code>，欧拉函数<code>φ(n)=(p-1)*(q-1)</code></p></li><li><p>随机选择一个整数<code>e</code>，条件是<code>1&lt; e &lt; φ(n)</code>，且<code>e</code>与<code>φ(n)</code>互质，计算模反元素<code>d</code>，即<code>(e*d)mod(φ(n))=1</code></p></li><li><p>经过上面两步得到<code>p、q、n、e、d</code>五个数，把<code>n、e</code>作为公钥，<code>n、d</code>作为私钥进行加解密。</p><ul><li>加密：消息<code>m</code>，<code>m&lt;n</code>，计算<code>(pow(m,e))mod(n)=c</code>，<code>c</code>就是<code>m</code>的密文</li><li>解密：密文<code>c</code>，计算<code>(pow(c,d)mod(n))=m</code></li><li>对于<code>m&gt;=n</code>，可以分块加密或者使用对称加密<code>m</code>然后公钥加密对称加密密钥</li></ul><p>算法的安全性保证在于很难从<code>n</code>和<code>e</code>推断出<code>d</code>，计算<code>d</code>需要知道<code>φ(n)</code>，而当<code>n</code>值很大的时候，直接计算<code>φ(n)</code>很困难，分解<code>n</code>得到<code>p、q</code>也很困难。</p><p>rsa原理的介绍推荐阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">文章</a>。</p></li></ol><h3 id="Go语言rsa简单封装"><a href="#Go语言rsa简单封装" class="headerlink" title="Go语言rsa简单封装"></a>Go语言rsa简单封装</h3><p>   为了方便使用做了个简单封装，放在Github上。</p><p>   安装方法<br>    <code>go get github.com/RivenZoo/goutil/dencrypt</code></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Rsa </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu Mount NTFS with system boot</title>
      <link href="/2015/10/10/ubuntu-mount-ntfs/"/>
      <url>/2015/10/10/ubuntu-mount-ntfs/</url>
      
        <content type="html"><![CDATA[<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu14.<span class="number">04</span></span><br><span class="line"></span><br><span class="line">$ vim <span class="regexp">/etc/</span>fstab</span><br><span class="line"></span><br><span class="line"><span class="regexp">/dev/</span>sda2 <span class="regexp">/media ntfs auto,user,rw,async,exec 0 0 # 加exec选项才可以执行挂载目录内的程序，相当于 mount -t ntfs /</span>dev<span class="regexp">/sda2 /m</span>edia -o exec</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> NTFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go Notes</title>
      <link href="/2015/09/19/go-notes/"/>
      <url>/2015/09/19/go-notes/</url>
      
        <content type="html"><![CDATA[<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p>   <code>go test -v -run=[pattern]</code></p><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><p>   <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t]</code></p><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>race:</p><p>  <code>go test -v -run=[pattern] -race</code></p></li><li><p>cpu:</p><p>  <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t] -cpuprofile=[output]</code></p></li><li><p>mem:</p><p>  <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t] -memprofile=[output]</code></p></li><li><p>block:</p><p>  <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t] -blockprofile=[output]</code></p><p>  <code>go tool pprof [program].test [output]</code></p></li></ul><h3 id="GODEBUG"><a href="#GODEBUG" class="headerlink" title="GODEBUG"></a>GODEBUG</h3><p>   runtime提供了环境变量来控制程序。GODEBUG是其中一，它可以设置很多值，格式<code>name=value,name=val</code>，如开启gctrace：<code>$ GODEBUG=&#39;gctrace=1&#39; your_program</code>，会在标准错误输出gc信息。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>   推荐使用<a href="https://github.com/pquerna/ffjson" target="_blank" rel="noopener">ffjson</a><br>   用它替换标准库后，编解码效率提高2倍。对于一些需要编码的大对象，可以采用sync.Pool缓存一定大小的bytes.Buffer，然后直接写buffer来完成json编码，性能有一定提高，在我笔记本上测10*1024的字符串数组，大概比标准json快20%，结果受到分配buffer大小的影响。在对json对象编码的时候，如果有字符串字段，并且字符串可能出现json格式用到的字符，最好预先对字符串编码，否则json编码的时候处理字符串转义会导致性能下降，如果字符串很长，可能会成为瓶颈。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PythonBrew</title>
      <link href="/2015/04/15/python-brew/"/>
      <url>/2015/04/15/python-brew/</url>
      
        <content type="html"><![CDATA[<h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><p>pythonbrew作者弃坑了，推荐了另外一个项目<a href="https://github.com/yyuu/pyenv" target="_blank" rel="noopener">https://github.com/yyuu/pyenv</a><br>功能跟这个有重叠，貌似更强大，用的人也更多</p><h3 id="pythonbrew多版本管理工具"><a href="#pythonbrew多版本管理工具" class="headerlink" title="pythonbrew多版本管理工具"></a>pythonbrew多版本管理工具</h3><p>pythonbrew是一个python版本管理的工具，具体命令见<a href="http://pythonbrew.readthedocs.org/en/latest/" target="_blank" rel="noopener">http://pythonbrew.readthedocs.org/en/latest/</a>。</p><h4 id="pythonbrew-install-2-5-6-的问题"><a href="#pythonbrew-install-2-5-6-的问题" class="headerlink" title="pythonbrew install 2.5.6 的问题"></a>pythonbrew install 2.5.6 的问题</h4><p>在安装python 2.5.6的时候遇到编译错误<code>make: *** [Modules/getbuildinfo.o] error 1</code>，参考了<a href="http://askubuntu.com/questions/398481/make-python2-5-failed-on-ubuntu-13-04" target="_blank" rel="noopener">http://askubuntu.com/questions/398481/make-python2-5-failed-on-ubuntu-13-04</a>这里的解决方法。<br>在python 2.5.6下载解压后的目录<br><code>/HOME/.pythonbrew/build/Python-2.5.6</code>，<br>手动执行<br><code>SVNVERSION=not-found ./configure --prefix=/HOME/.pythonbrew/pythons/Python-2.5.6</code>，<br>把python2.5.6安装到了pythonbrew预定的目录就可以了。</p><p>pythonbrew管理虚拟环境</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pythonbrew venv init</span><br><span class="line">$ pythonbrew venv create proj -<span class="selector-tag">p</span> x<span class="selector-class">.x</span><span class="selector-class">.x</span></span><br></pre></td></tr></table></figure><p>以上2步就创建了一个可用的虚拟环境，然后到需要环境的工程，执行<code>pythonbrew venv use proj</code>就可以使用之前创建的虚拟环境了。</p><h5 id="ps-pythonbrew有个别名pybrew。"><a href="#ps-pythonbrew有个别名pybrew。" class="headerlink" title="ps:pythonbrew有个别名pybrew。"></a>ps:pythonbrew有个别名pybrew。</h5>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Take a look at Level source code</title>
      <link href="/2015/03/08/leveldb-source-1/"/>
      <url>/2015/03/08/leveldb-source-1/</url>
      
        <content type="html"><![CDATA[<p>最近看了一点leveldb源码，了解一下实现机制。</p><p>之前也看过leveldb相关介绍以及别人的分析blog，已经有了一定了解。leveldb如其名，按照层级来组织数据，数据从内存到磁盘一层一层迁移。在内存中是通过skiplist来管理数据，而磁盘上则是一种名为SSTable(Sorted Strings Table)的结构来存储数据的。</p><a id="more"></a><h5 id="DB-Get实现"><a href="#DB-Get实现" class="headerlink" title="DB::Get实现"></a>DB::Get实现</h5><p>这个头文件include/leveldb/db.h定义了DB抽象类，Get接口也在其中，具体实现在db/db_impl.cc文件中。<br>下面引用的代码因为篇幅会删除一些代码行，完整代码参考源文件。 </p><p>代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Get(<span class="keyword">const</span> ReadOptions&amp; options,</span><br><span class="line">                   <span class="keyword">const</span> Slice&amp; key,</span><br><span class="line">                   std::string* value) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  MutexLock l(&amp;mutex_);</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    LookupKey lkey(key, snapshot);</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="keyword">NULL</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = current-&gt;Get(options, lkey, value, &amp;stats);</span><br><span class="line">      have_stat_update = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) &#123;</span><br><span class="line">    MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是Get的实现函数，省略了一些代码。Get主要的查询过程在中间if-else语句分支中。在查询之前<code>mutex_.Unlock();</code>进行了解锁，是因为数据是只追加不删除的，可以同时读写。数据删除会转换成一条标记key-deleted的数据追加到库中。 </p><p>SequenceNumber snapshot为数据序号，每一条数据都有序号，后追加的序号比之前的序号要大，相同key的数据，序号大的要排在前面，参见<code>db/dbformat.cc</code> <code>InternalKeyComparator::Compare</code>函数。 </p><p>第一个分支mem指向一个MemTable，MemTable只有Add和Get两个接口来操作数据，底层实现为skiplist，这个mem指向可修改的MemTable。 </p><p>第二个分支imm指向一个不可修改的MemTable，imm是mem达到一定条件后转换来的，具体的逻辑在db/db_impl.cc DBImpl::MakeRoomForWrite函数中。 </p><p>前面2个分支都是在内存中进行查询，没找到就只能到磁盘上查询。最后一个分支current指向当前的Version，Version包含数据文件的元信息。 </p><p>最后根据情况调用MaybeScheduleCompaction函数，在后台对数据进行Compact，将内存的迁到磁盘，对磁盘上的数据进行合并等。</p><p>Version::Get实现。这个函数就是上一节最后一个if分支调用的函数，也是查询磁盘数据的入口。 </p><p>代码:</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Status Version::Get(<span class="keyword">const</span> ReadOptions&amp; options,</span><br><span class="line">                    <span class="keyword">const</span> LookupKey&amp; k,</span><br><span class="line">                    std::string* value,</span><br><span class="line">                    GetStats* stats) &#123;      </span><br><span class="line">  ...       </span><br><span class="line">  <span class="comment">// We can search level-by-level since entries never hop across</span></span><br><span class="line">  <span class="comment">// levels.  Therefore we are guaranteed that if we find data</span></span><br><span class="line">  <span class="comment">// in an smaller level, later levels are irrelevant.</span></span><br><span class="line">  std::vector&lt;FileMetaData*&gt; tmp;</span><br><span class="line">  FileMetaData* tmp2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    size_t num_files = files_[level].size();</span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the list of files to search in this level</span></span><br><span class="line">    FileMetaData* <span class="keyword">const</span>* files = &amp;files_[level][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Level-0 files may overlap each other.  Find all files that</span></span><br><span class="line">      <span class="comment">// overlap user_key and process them in order from newest to oldest.</span></span><br><span class="line">      tmp.reserve(num_files);</span><br><span class="line">      <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; num_files; i++) &#123;</span><br><span class="line">        FileMetaData* f = files[i];</span><br><span class="line">        <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          tmp.push_back(f);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (tmp.<span class="keyword">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::sort(tmp.begin(), tmp.end(), NewestFirst);</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Binary search to find earliest index whose largest key &gt;= ikey.</span></span><br><span class="line">      uint32_t index = FindFile(vset_-&gt;icmp_, files_[level], ikey);</span><br><span class="line">      <span class="keyword">if</span> (index &gt;= num_files) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp2 = files[index];</span><br><span class="line">        <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, tmp2-&gt;smallest.user_key()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// All of "tmp2" is past any data for user_key</span></span><br><span class="line">          ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          files = &amp;tmp2;</span><br><span class="line">          num_files = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; num_files; ++i) &#123;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">      FileMetaData* f = files[i];</span><br><span class="line">      last_file_read = f;</span><br><span class="line">      last_file_read_level = level;</span><br><span class="line"></span><br><span class="line">      Saver saver;</span><br><span class="line">      saver.state = kNotFound;</span><br><span class="line">      saver.ucmp = ucmp;</span><br><span class="line">      saver.user_key = user_key;</span><br><span class="line">      saver.value = value;</span><br><span class="line">      s = vset_-&gt;table_cache_-&gt;Get(options, f-&gt;number, f-&gt;file_size,</span><br><span class="line">                                   ikey, &amp;saver, SaveValue);</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="keyword">return</span> Status::NotFound(Slice());  <span class="comment">// Use an empty error message for speed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数主要是对每个level上的数据从低到高进行查询，比较新的数据放在低的level。 </p><p>主for循环所有level，先根据key查找符合要求的文件，由于Sstable是排序数据，每个文件都有key的范围，所以可以查找包含了查询key的文件即可。level-0和其他的level处理方式不太一样，level-0是直接遍历，而其他level调用FindFile进行查询。 </p><p>找到符合要求的文件之后，进入后一个for循环，通过vset_-&gt;table_cache_-&gt;Get查找所有的文件。</p><p>上面提到的FindFile使用internal_key即带序号的查询key在一层的文件中进行二分查找，找到离查询key最近且文件largest-key比查询key大的文件，如果key存在库的这一层中，那应该会落在这个文件。 </p><p>TableCache::Get比较简单，先调用了FindTable找到对应的Table对象，然后调用Table对象的InternalGet函数。下面说FindTable函数和Table::InternalGet函数。</p><p>FindTable函数 </p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Status TableCache::FindTable(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span><br><span class="line">                             Cache::Handle** handle) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(file_number)];</span><br><span class="line">  EncodeFixed64(buf, file_number);</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">(buf, <span class="keyword">sizeof</span>(buf))</span></span>;</span><br><span class="line"></span><br><span class="line">  *handle = cache_-&gt;Lookup(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br><span class="line">    RandomAccessFile* file = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = Table::Open(*options_, file, file_size, &amp;table);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TableAndFile* tf = <span class="keyword">new</span> TableAndFile;</span><br><span class="line">      tf-&gt;file = file;</span><br><span class="line">      tf-&gt;table = table;</span><br><span class="line">      *handle = cache_-&gt;Insert(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cache_-&gt;Lookup(key)先在cache中查找，cache_指向一个LRU的cache，缓存的内容为打开的文件对象和Table对象的指针，最后一个else语句块里cache_-&gt;Insert把要缓存的内容插入了缓存。 </p><p>若缓存中没有要找的Table则调用Table::Open打开文件载入Table对象，然后插入缓存。 </p><p>Table::Open代码:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="keyword">Table</span>::Open(const <span class="comment">Options&amp; options,</span></span><br><span class="line">               RandomAccessFile* file,</span><br><span class="line">               uint64_t size,</span><br><span class="line">               <span class="keyword">Table</span>** <span class="keyword">table</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  char footer_space[Footer::kEncodedLength];</span><br><span class="line">  Slice footer_input;</span><br><span class="line">  Status s = <span class="keyword">file</span>-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                        &amp;footer_input, footer_space);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    s = ReadBlock(<span class="keyword">file</span>, opt, footer.index_handle(), &amp;contents);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      index_block = new Block(contents);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// We've successfully read the footer and the index block: we're</span></span><br><span class="line">    <span class="comment">// ready to serve requests.</span></span><br><span class="line">    Rep* rep = new <span class="keyword">Table</span>::Rep;</span><br><span class="line">    rep-&gt;options = options;</span><br><span class="line">    rep-&gt;<span class="keyword">file</span> = <span class="keyword">file</span>;</span><br><span class="line">    rep-&gt;metaindex_handle = footer.metaindex_handle();</span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    rep-&gt;cache_id = (<span class="keyword">options</span>.block_cache ? <span class="keyword">options</span>.block_cache-&gt;NewId() : <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    *<span class="keyword">table</span> = new <span class="comment">Table(rep)</span>;</span><br><span class="line">    (*<span class="keyword">table</span>)-&gt;ReadMeta(footer);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;     </span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Table::Open把index-block的内容读出来缓存起来，如果有meta数据或filter数据，也会读出来并缓存。options.block_cache这个指针如果指向一个cache对象，后面在读入新的block的时候也会把block缓存起来。</p><p>Table::InternalGet </p><p>代码:</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Status Table::InternalGet(const ReadOptions&amp; options, const Slice&amp; k,</span><br><span class="line">                          void* arg,</span><br><span class="line">                          void (*saver)(void*, const Slice&amp;, const Slice&amp;)) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  I<span class="function"><span class="title">terator</span>* iiter = rep_-&gt;</span><span class="function"><span class="title">index_block</span>-&gt;</span>N<span class="function"><span class="title">ewIterator</span>(rep_-&gt;</span>options.comparator);</span><br><span class="line">  <span class="function"><span class="title">iiter</span>-&gt;</span>Seek(k);</span><br><span class="line">  <span class="function"><span class="title">if</span> (iiter-&gt;</span>Valid()) &#123;</span><br><span class="line">    S<span class="function"><span class="title">lice</span> handle_value = iiter-&gt;</span>value();</span><br><span class="line">    F<span class="function"><span class="title">ilterBlockReader</span>* filter = rep_-&gt;</span>filter;</span><br><span class="line">    BlockHandle handle;</span><br><span class="line">    <span class="keyword">if</span> (filter != NULL &amp;&amp;</span><br><span class="line">        handle.DecodeFrom(&amp;handle_value).ok() &amp;&amp;</span><br><span class="line">        !<span class="function"><span class="title">filter</span>-&gt;</span>KeyMayMatch(handle.offset(), k)) &#123;</span><br><span class="line">      <span class="comment">// Not found</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      I<span class="function"><span class="title">terator</span>* block_iter = BlockReader(this, options, iiter-&gt;</span>value());</span><br><span class="line">      <span class="function"><span class="title">block_iter</span>-&gt;</span>Seek(k);</span><br><span class="line">      <span class="function"><span class="title">if</span> (block_iter-&gt;</span>Valid()) &#123;</span><br><span class="line">        (*<span class="function"><span class="title">saver</span>)(arg, block_iter-&gt;</span><span class="function"><span class="title">key</span>(), block_iter-&gt;</span>value());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="title">s</span> = block_iter-&gt;</span>status();</span><br><span class="line">      delete block_iter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Table::InternalGet先在index-block中找到距离key最近的block，block也有key范围，查找过程和查找文件类似也是通过二分查找找到最近的block，但是index-block并不是所有block的索引，所以还需要进一步到block附近进行查找。 </p><p>如果找到key附近的block，就对block进行查找。先结合filter判断key是否不在，如不在直接返回NotFound。然后读index对应的block，进行二次查找。iter-&gt;Seek(k)具体可以参考table/block.cc Block::Iter::Seek函数，函数并没有进行相等比较，只能定位范围。由于iter-&gt;Seek(k)只能定位到key附近，所以需要调用(*saver)(arg, block_iter-&gt;key(), block_iter-&gt;value())，saver对应上文提到的db/version_set.cc SaveValue函数，代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveValue</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> Slice&amp; ikey, <span class="keyword">const</span> Slice&amp; v)</span> </span>&#123;</span><br><span class="line">  Saver* s = <span class="keyword">reinterpret_cast</span>&lt;Saver*&gt;(arg);</span><br><span class="line">  ParsedInternalKey parsed_key;</span><br><span class="line">  <span class="keyword">if</span> (!ParseInternalKey(ikey, &amp;parsed_key)) &#123;</span><br><span class="line">    s-&gt;state = kCorrupt;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;ucmp-&gt;Compare(parsed_key.user_key, s-&gt;user_key) == <span class="number">0</span>) &#123;</span><br><span class="line">      s-&gt;state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;</span><br><span class="line">      <span class="keyword">if</span> (s-&gt;state == kFound) &#123;</span><br><span class="line">        s-&gt;value-&gt;assign(v.data(), v.size());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据文件的编码格式比较复杂，就不写了，可以参考源文件或网络。 </p><p>以上就是Get的过程，流程还是比较长的。网上的测试结果表明leveldb的写性能高于读，跟它的磁盘查找关系很大，对于需要频繁随机读的应用还是要仔细考虑一下性能问题。打开block-cache可能会提高读性能，相应的就需要消耗内存，把文件放到ssd也是一个优化方案，没有具体实践，不知效果如何。 </p><p>欢迎指出本文的错误，也欢迎分享相关内容！</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Leveldb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Makefile获取依赖的源文件</title>
      <link href="/2015/03/07/makefile-source-dependency/"/>
      <url>/2015/03/07/makefile-source-dependency/</url>
      
        <content type="html"><![CDATA[<p>代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exclude=<span class="string">"_test"</span></span><br><span class="line"><span class="comment">#exclude="___"</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *[^<span class="variable">$(exclude)</span>].c ./subs/*.c)</span></span><br><span class="line"></span><br><span class="line">files=<span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(files)</span> )</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        @echo <span class="variable">$(src)</span></span><br><span class="line">        @echo <span class="variable">$(files)</span></span><br><span class="line">        @echo <span class="variable">$(obj)</span></span><br><span class="line">        @echo <span class="string">"end"</span></span><br></pre></td></tr></table></figure><p>wildcard通过通配符来匹配文件并将结果展开，第一个参数排除了_test.c的文件。<br>notdir去掉src中的目录，只保留文件名<br>patsubst进行替换，把.c换成.o<br>上面代码参考Makefile中的wildcard用法这篇blog，稍微修改了下。</p><h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>上面的代码</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exclude=<span class="string">"_test"</span></span><br><span class="line"><span class="comment">#exclude="___"</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *[^<span class="variable">$(exclude)</span>].c ./subs/*.c)</span></span><br></pre></td></tr></table></figure><p>其实有点问题，*[^$<em>test].c这个正则只能过滤.c之前是’</em>‘,’t’,’e’,’s’这4个字符的文件名，达不到想要的目的。<br>需要修改一下，对src进行替换</p><p><code>$(patsubst %_test.c,, $(src))</code></p><p>这样就把文件列表中含_test.c的去掉了。修改后为</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src :=<span class="variable">$(<span class="built_in">wildcard</span> *.c ./subs/*.c)</span></span><br><span class="line">src :=<span class="variable">$(<span class="built_in">patsubst</span> %_test.c,,<span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">files :=<span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">obj :=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(files)</span> )</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        @echo <span class="variable">$(src)</span></span><br><span class="line">        @echo <span class="variable">$(files)</span></span><br><span class="line">        @echo <span class="variable">$(obj)</span></span><br><span class="line">        @echo <span class="string">"end"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言INT_MIN定义的问题</title>
      <link href="/2015/01/21/c-minint-define/"/>
      <url>/2015/01/21/c-minint-define/</url>
      
        <content type="html"><![CDATA[<p>关于c语言INT_MIN定义的问题</p><p>最近看到一段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br></pre></td></tr></table></figure><p>INT_MIN的值应该为 -2147483648，为什么不直接定义呢？原因参考<a href="http://www.cnblogs.com/Jack47/archive/2013/01/06/TMin32-in-c.html" target="_blank" rel="noopener">Jack47的blog:C语言中TMin的写法</a>这篇文章。</p><p>个人理解为C语言在处理程序中常量时，符号-和后面的值是分开处理的，先处理字面值，然后将-作为一元运算符。处理字面值的时候会决定这个常量的类型，基本的规则是选能容纳字面值的最小类型。如32位系统，2147483648这个值决定为unsigned int，如果使用<code>#define INT_MIN (-2147483648)</code>这个定义，INT_MIN类型为unsigned int。</p><p>写了一段代码验证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TMIN is unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TMIN (-2147483648)        </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; TMIN) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d &gt; tmin\n"</span>, i);</span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d &lt; tmin\n"</span>, i);</span><br><span class="line">    <span class="keyword">if</span> (i &gt; INT_MIN)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d &gt;INT_MIN\n"</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(TMIN));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><blockquote></blockquote><p>1 &lt; tmin<br>1 &gt;INT_MIN<br>4</p><p>补充：</p><p>CSAPP的补充材料<a href="http://csapp.cs.cmu.edu/public/waside/waside-tmin.pdf" target="_blank" rel="noopener">waside-tmin.pdf</a></p><p>上面的例子说明了不同格式字面值在C90和C99下面的类型确定的规则，C90 32位下类型为unsigned，就会产生上面程序的结果。</p><p>对于这种会产生不同行为的代码最好避免.</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Notes About Kafka</title>
      <link href="/2014/09/21/notes-about-kafka/"/>
      <url>/2014/09/21/notes-about-kafka/</url>
      
        <content type="html"><![CDATA[<h5 id="consumer-offset-commit"><a href="#consumer-offset-commit" class="headerlink" title="consumer offset commit"></a>consumer offset commit</h5><p>使用kafka的python api时遇到了offset回滚的问题，因为最初使用了autocommit参数，发现有时会重复取记录，发现autocommit是批量提交，并且有offset回滚的问题，具体原因未发现，解决方法是手动调用commit函数提交，经过测试手动调用没有出现offset回滚的问题。</p><h5 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h5><p>一开始为了简单只使用了一个分区，consumer都从一个leader取数据，请求压力都在一台机器。使用不同分区策略可以分散topic的leader，还可以灵活处理不同数据。</p><h5 id="fetch-msg"><a href="#fetch-msg" class="headerlink" title="fetch msg"></a>fetch msg</h5><p>MaxWaitTime 请求最大等待时间，MinBytes 请求消息的最小字节数，通过这2个参数可以调整你获取数据时的等待策略，最简单的做法就是不等待，没数据直接返回。</p><h5 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h5><p>由于硬盘限制，把kafka和zookeeper的日志目录放在了同一个磁盘，而且磁盘的性能不是很好，造成了kafka写数据效率低下，每次写数据只有几百k。zookeeper网站上对这2个配置有Notes说不要把他们放在繁忙的磁盘设备上，会影响其他程序写磁盘的性能，最好这2个目录都分开存放不同设备。简单看了一下，dataDir下存的是snapshot文件，dataLogDir存的是log文件，应该是zookeeper把内存数据持久化到这2种文件中了，而且持久化操作很频繁且写的数据很少，会影响kafka写日志。</p><h5 id="磁盘参数"><a href="#磁盘参数" class="headerlink" title="磁盘参数"></a>磁盘参数</h5><p>在排查磁盘io高的问题时用到了<code>iostat -d -x</code>命令，在排查时主要关注w/s、wkB/s、rkB/s，对于扇区没怎么关注，rsec/s wsec/s avgrq-sz这几个参数反应磁盘操作扇区的情况，当磁盘利用率高且iowait高，而平均扇区低也就意味着磁盘把大量时间用于磁盘寻道，你可能需要考虑是不是有大量随机写磁盘的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>重入与线程安全</title>
      <link href="/2013/11/22/about-thread-safe/"/>
      <url>/2013/11/22/about-thread-safe/</url>
      
        <content type="html"><![CDATA[<p>在stackoverflow上看的的关于可重入与线程安全的区别：</p><blockquote><p>These functions are not reentrant. They are thread-safe. There’s a big difference. Functions that are reentrant are automatically thread-safe, but thread-safe functions can still deadlock (or worse) if called again from the same thread they’re already running in (for example from a signal handler).</p></blockquote><p>函数可重入很自然会觉得该函数是线程安全的，既然能被其他流程中断并可调用自身也就可以被多个线程同时调用。但是线程安全是不是可重入有点模糊，上面说了一种情况，当重复调用一个线程安全的函数，并且函数中有锁就有可能发生死锁，表明线程安全不一定可重入。看来重入的要求比线程安全要更严格一点。</p><p>附带查了查关于Posix的标准io操作，Posix标准要求操作字符流的函数实现为可重入，但是各个实现为了性能方面的考虑都没有实现为可重入的，这些函数有潜在不安全。但是又说明：</p><blockquote><p>all standard I/O functions that reference character streams shall behave as if they use flockfile() and funlockfile() internally to obtain ownership of the character streams</p></blockquote><p>表明它们应该是线程安全的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义linux信号</title>
      <link href="/2013/11/05/define-linux-signal/"/>
      <url>/2013/11/05/define-linux-signal/</url>
      
        <content type="html"><![CDATA[<p>有时候我们需要在程序中利用信号来控制程序行为，linux为我们提供了2个已经定义的信号SIGUSR1和SIGUSR2，一般的程序利用这2个信号已经能满足需要，不过我最近需要一些其他信号来避免覆盖原来的信号处理函数。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSIG_MSG        (SIGUSR2 + 1)</span></span><br><span class="line"><span class="comment">// 定义信号然后注册处理函数</span></span><br></pre></td></tr></table></figure><p>然后到系统里查了一下，MYSIG_MSG其实将其他的信号给覆盖了<br><code>$kill -l</code></p><blockquote><p>10) SIGUSR1    11) SIGSEGV    12) SIGUSR2 13) SIGPIPE    14) SIGALRM </p></blockquote><p>虽然SIGPIPE和SIGALRM在这个程序中没有用到，但是这并不是我想要的效果。<br>我发现在后面有 </p><blockquote><p>34) SIGRTMIN 35) SIGRTMIN+1    36) SIGRTMIN+2 </p></blockquote><p><code>man 7 signal</code>页面同样也说明可以用 SIGRTMIN作为自定义信号。然后程序里就多了下面的代码： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSIG_MSG        (SIGRTMIN+ 1)</span></span><br></pre></td></tr></table></figure><p>结果出错了，但是并不是这个定义方式的问题。在我程序中有下面的代码： </p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch(signo)&#123;</span><br><span class="line">    <span class="keyword">case</span> MYSIG_MSG:</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">编译时才发现原来SIGRTMIN并不是一个常量，看了头文件里才知道：</span><br></pre></td></tr></table></figure><p>// centos5.9 /usr/include/bits/signum.h<br>#define SIGRTMIN        (__libc_current_sigrtmin ())</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">原来是函数调用，运行时确定的。 </span><br><span class="line">要用这个SIGRTMIN宏是不行，只能自己定义了：</span><br></pre></td></tr></table></figure><p>#define MYSIGRTMIN    34<br>#define MYSIG_MSG     (MYSIGRTMIN + 1)</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在找到系统定义的SIGRTMIN值之前，根据man <span class="number">7</span> signal里面的说明：</span><br><span class="line">&gt; Linux supports <span class="number">32</span> real-<span class="built_in">time</span> signals, numbered <span class="built_in">from</span> <span class="number">32</span> (SIGRTMIN) <span class="built_in">to</span> <span class="number">63</span> (SIGRTMAX). </span><br><span class="line">我把自定义的信号值定义成了<span class="number">32</span>，但是一直注册不了这个信号，后来赫然发现在 `man <span class="number">7</span> signal`下面有一行说明， </span><br><span class="line">&gt; However, <span class="keyword">the</span> glibc POSIX threads implementation internally uses <span class="literal">two</span> (<span class="keyword">for</span> NPTL) <span class="keyword">or</span> <span class="literal">three</span>  (<span class="keyword">for</span>  LinuxThreads)  real-<span class="built_in">time</span> signals  (see  pthreads(<span class="number">7</span>)), <span class="keyword">and</span> adjusts <span class="keyword">the</span> <span class="built_in">value</span> <span class="keyword">of</span> SIGRTMIN suitably (<span class="built_in">to</span> <span class="number">34</span> <span class="keyword">or</span> <span class="number">35</span>) </span><br><span class="line"></span><br><span class="line">这个说明在ubuntu12<span class="number">.04</span>里面看见的，估计centos也有类似的情况。同时头文件下面也有：</span><br></pre></td></tr></table></figure><p>/* These are the hard limits of the kernel.  These values should not be<br>used directly at user level.  */<br>#define __SIGRTMIN  32<br>#define __SIGRTMAX  (_NSIG - 1)</p><pre><code>改成34之后就没有问题了。不过这个方法不太可靠，程序不应该直接用常量标识信号. </code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2013/09/01/hello-world/"/>
      <url>/2013/09/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
