<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Git Hooks]]></title>
      <url>http://rivenzoo.github.io/2018/09/02/Git-Hooks/</url>
      <content type="html"><![CDATA[<h2 id="Git-Hooks"><a href="#Git-Hooks" class="headerlink" title="Git Hooks"></a>Git Hooks</h2><p>git通过hooks来定制行为，所有的hooks存储在<code>hooks</code>目录，客户端是<code>.git/hooks</code>目录。<br><code>git init</code>的时候会在<code>.git/hooks</code>目录生成很多示例hook，只要重命名文件就能启用。</p>
<p>hook分为</p>
<ul>
<li>客户端hook</li>
<li>服务端hook</li>
</ul>
<p>客户端hook不会被克隆，如果要强制实现某个git策略，需要用服务端hook。</p>
<h3 id="客户端hook"><a href="#客户端hook" class="headerlink" title="客户端hook"></a>客户端hook</h3><p>客户端hook在工程目录下运行<br>客户端hook又可以分为</p>
<ul>
<li>committing-workflow</li>
<li>email-workflow</li>
<li>其他</li>
</ul>
<h4 id="committing-workflow"><a href="#committing-workflow" class="headerlink" title="committing-workflow"></a>committing-workflow</h4><ul>
<li><p>pre-commit</p>
<p>  第一个运行的hook，在创建提交message之前就运行。<br>  返回非0则终止提交，但是可以用<code>git commit --no-verify</code>来跳过检查。<br>  可以在这个hook中运行测试，检查代码格式，做代码静态检查等。</p>
</li>
<li><p>prepare-commit-msg</p>
<p>  在默认commit message创建之后，打开message编辑器之前运行。<br>  会传入几个参数：当前消息文件路径、commit类型，如果是amend提交再加上commit的SHA-1。<br>  一般用来生成自动提交的信息。</p>
</li>
<li><p>commit-msg</p>
<p>  编辑完提交消息之后运行。<br>  传入一个参数：保存用户提交消息的临时文件的路径。<br>  返回非0终止提交。<br>  一般用来验证消息格式。</p>
</li>
<li><p>post-commit    </p>
<p>  提交完成之后运行。<br>  一般用来做提交通知。</p>
</li>
</ul>
<h4 id="email-workflow-hooks"><a href="#email-workflow-hooks" class="headerlink" title="email-workflow hooks"></a>email-workflow hooks</h4><p>通过<code>git am</code>命令调用，如果你需要通过email来接收patch，可能会用到这个类型的hook。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p>pre-rebase</p>
<p>  rebase之前运行。<br>  返回非0终止rebase。</p>
</li>
<li><p>post-rewrite</p>
<p>  <code>git commit --amend</code>和<code>git rebase</code>会触发这个hook。<br>  传入参数：触发hook的命令。</p>
</li>
<li><p>post-checkout</p>
<p>  checkout成功之后运行。</p>
</li>
<li><p>post-merge</p>
<p>  merge成功之后运行。</p>
</li>
<li><p>pre-push</p>
<p>  remote ref更新之后，传输对象之前运行。<br>  返回非0终止push。<br>  传入参数：远端的名称和地址。</p>
</li>
<li><p>pre-auto-gc</p>
<p>  由<code>git gc --auto</code>触发。</p>
</li>
</ul>
<h3 id="服务端hook"><a href="#服务端hook" class="headerlink" title="服务端hook"></a>服务端hook</h3><p>服务端hook在服务器的工程<code>.git</code>目录下运行</p>
<ul>
<li><p>pre-receive</p>
<p>  服务端接收push第一个运行的hook，从stdin接收被push过来的references。<br>  返回非0则终止push。</p>
</li>
<li><p>update</p>
<p>  类似pre-receive，但是每个分支运行一次。<br>  传入三个参数：分支名、前一个commit的SHA-1，当前push的SHA-1<br>  返回非0则终止push。    </p>
</li>
<li><p>post-receive</p>
<p>  所有流程完成之后运行。<br>  跟pre-receive一样从stdin传入references。<br>  客户端等待这个脚本完成才断开连接。</p>
</li>
</ul>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" target="_blank" rel="external">https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks</a><br><a href="https://docs.gitlab.com/ee/administration/custom_hooks.html" target="_blank" rel="external">https://docs.gitlab.com/ee/administration/custom_hooks.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Cpp Static Initialization Order Fiasco]]></title>
      <url>http://rivenzoo.github.io/2017/01/20/Cpp-Static-initialization-order-fiasco/</url>
      <content type="html"><![CDATA[<h3 id="Static-initialization-order-fiasco"><a href="#Static-initialization-order-fiasco" class="headerlink" title="Static initialization order fiasco"></a>Static initialization order fiasco</h3><ul>
<li><p>Construct On First Use Idiom</p>
<ul>
<li><p>If the object does not need to be destructed, uses a static pointer.</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File x.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"Fred.h"</span></span></span><br><span class="line"><span class="function">Fred&amp; <span class="title">x</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Fred* ans = <span class="keyword">new</span> Fred();</span><br><span class="line">  <span class="keyword">return</span> *ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File Barney.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"Barney.h"</span></span></span><br><span class="line">Barney::Barney()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  x().goBowling();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This approach is that the Fred object is <strong>never destructed</strong>.<br>The Construct On First Use Idiom uses a pointer and intentionally leaks the object.</p>
</li>
<li><p>If you need to destruct the object and do not care the order of static objects deinitialization, uses a static object.</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File x.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"Fred.h"</span></span></span><br><span class="line"><span class="function">Fred&amp; <span class="title">x</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Fred ans;  <span class="comment">// was static Fred* ans = new Fred();</span></span><br><span class="line">  <span class="keyword">return</span> ans;       <span class="comment">// was return *ans;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  It does not leak the object, but <strong>it does not control the order of static deinitialization</strong>, so it is (very!) unsafe to use the object during static deinitialization, that is, from a destructor of another statically declared object.</p>
</li>
</ul>
</li>
<li><p>Nifty Counter</p>
<p>  It is a more complicated solution that solves problems mentioned above.</p>
  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STREAM_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STREAM_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">Stream</span> &#123;</span><br><span class="line">  <span class="built_in">Stream</span> ();</span><br><span class="line">  ~<span class="built_in">Stream</span> ();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">Stream</span>&amp; stream; <span class="comment">// global stream object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> StreamInitializer &#123;</span><br><span class="line">  StreamInitializer ();</span><br><span class="line">  ~StreamInitializer ();</span><br><span class="line">&#125; streamInitializer; <span class="comment">// static initializer for every translation unit</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STREAM_H</span></span></span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"Stream.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span>         // placement new</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span> // aligned_storage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nifty_counter; <span class="comment">// zero initialized at load time</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">typename</span> <span class="built_in">std</span>::aligned_storage&lt;<span class="keyword">sizeof</span> (Stream), <span class="keyword">alignof</span> (Stream)&gt;::type</span><br><span class="line">  stream_buf; <span class="comment">// memory for the stream object</span></span><br><span class="line">Stream&amp; stream = <span class="keyword">reinterpret_cast</span>&lt;Stream&amp;&gt; (stream_buf);</span><br><span class="line"></span><br><span class="line">Stream::Stream ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// initialize things</span></span><br><span class="line">&#125;</span><br><span class="line">Stream::~Stream ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// clean-up</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">StreamInitializer::StreamInitializer ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (nifty_counter++ == <span class="number">0</span>) <span class="keyword">new</span> (&amp;stream) Stream (); <span class="comment">// placement new</span></span><br><span class="line">&#125;</span><br><span class="line">StreamInitializer::~StreamInitializer ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (--nifty_counter == <span class="number">0</span>) (&amp;stream)-&gt;~Stream ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  The header file of the Stream class <strong>must be included before any member function can be called on the Stream object</strong>.<br>  An instance of the StreamInitializer class is included in each compilation unit. Any use of the Stream object follows the inclusion of the header, which ensures that the constructor of the initializer object is called before the Stream object is used.</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[go-doc-tips]]></title>
      <url>http://rivenzoo.github.io/2016/12/18/go-doc-tips/</url>
      <content type="html"><![CDATA[<h3 id="Go-doc-tips"><a href="#Go-doc-tips" class="headerlink" title="Go doc tips"></a>Go doc tips</h3><ol>
<li>新建<code>doc.go</code>作为文档文件，<code>package pkgname</code>之前的注释作为文档。</li>
<li><p>文档注释的格式</p>
<ol>
<li>相邻的行位于同一段落，分段需要添加空行</li>
<li>上下空行的短语会被作为接下来段落的head</li>
<li>预先格式化的文本需要跟周围的注释保持缩进</li>
<li>URL会被转换成链接，不需要标记</li>
</ol>
</li>
<li><p>Go同一个目录可以添加<code>{pkg}_test</code>的测试包。</p>
</li>
<li><p>包<code>{pkg}_test</code>的文件(<code>_test.go</code>结尾)，函数名以<code>Example</code>开头且没有参数的函数作为示例代码。</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleFoo</span><span class="params">()</span></span>     <span class="comment">// documents the Foo function or type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleBar_Qux</span><span class="params">()</span></span> <span class="comment">// documents the Qux method of type Bar</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example</span><span class="params">()</span></span>        <span class="comment">// documents the package as a whole</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleReverse</span><span class="params">()</span></span> <span class="comment">// Reverse first example</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleReverse_second</span><span class="params">()</span></span> <span class="comment">// Reverse second example</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleReverse_third</span><span class="params">()</span></span> <span class="comment">// Reverse thirdß example</span></span><br></pre></td></tr></table></figure>
<p> <code>_test.go</code>结尾的文件，如果只包含一个<code>Example</code>函数，并且有其他包级声明，整个文件会作为示例代码显示。</p>
</li>
<li><p><code>// Output: olleh</code>预期输出，示例函数可以作为<code>go test</code>的测试用例。</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package stringutil_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/golang/example/stringutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleReverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.<span class="type">Println</span>(stringutil.<span class="type">Reverse</span>(<span class="string">"hello"</span>))</span><br><span class="line">    <span class="comment">// Output: olleh</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vim-shortcut]]></title>
      <url>http://rivenzoo.github.io/2016/12/12/vim-shortcut/</url>
      <content type="html"><![CDATA[<h3 id="vim快捷键"><a href="#vim快捷键" class="headerlink" title="vim快捷键"></a>vim快捷键</h3><h4 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h4><ol>
<li><p>行内跳转 </p>
<p> <code>^</code> 行开头<br> <code>$</code> 行尾<br> <code>w/W</code> 下一个单词开头<br> <code>e/E</code> 下一个单词末尾<br> <code>b/B</code> 上一个单词开头<br> <code>f+{字符}</code> 下一个字符本身 <code>F+{字符}</code> 上一个字符本身<br> <code>t+{字符}</code> 下一个字符之后 <code>T+{字符}</code> 上一个字符之后</p>
</li>
</ol>
<ol>
<li><p>跨行跳转</p>
<p> <code>h</code> 左 <code>j</code> 下 <code>k</code> 上 <code>l</code> 右<br> <code>{数字}+h/j/k/l</code> 跳转n个位置<br> <code>{数字}+G</code> 跳转到第n行<br> <code>*</code> 向下搜索光标对应单词<br> <code>#</code> 向上搜索光标对应单词<br> <code>gg</code> 文件开头<br> <code>G</code> 文件末尾<br> <code>ctrl+b</code> 向上翻页<br> <code>ctrl+f</code> 向下翻页<br> <code>ctrl+u</code> 向上翻半页<br> <code>ctrl+d</code> 向下翻半页<br> <code>ctrl+o</code> 跳转到光标上一个位置<br> <code>ctrl+i</code> 跳转到光标下一个位置</p>
</li>
</ol>
<h4 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h4><ol>
<li><p>行内编辑</p>
<p> <code>x</code> 删除一个字符<br> <code>{数字}+x</code> 删除n个字符<br> <code>dd</code> 删除一行，包括换行<br> <code>d+{数字}+d</code> / <code>{数字}+dd</code> 删除n行<br> <code>d+w/W</code> / <code>d+e/E</code> 向后删除一个单词<br> <code>d+b/B</code> 向前删除一个单词<br> <code>D</code> / <code>d+$</code> 删除光标之后所有字符，不包括换行<br> <code>i</code> 光标之前插入<br> <code>a</code> 光标之后插入<br> <code>r</code> 替换光标处字符<br> <code>{数字}+r</code>    替换光标开始n个字符<br> <code>o</code> 插入下一行，光标跳转到新行<br> <code>O</code> 插入上一行，光标跳转到新行</p>
</li>
<li><p>复制粘贴</p>
<p> <code>yy</code> 复制一行<br> <code>{数字}+yy</code> / <code>y+{数字}+y</code> 复制n行<br> <code>y+{位置}+y</code> 复制光标与某一行直接的内容<br> <code>y+w/W</code> / <code>y+e/E</code> 向后复制一个单词<br> <code>y+b/B</code> 向前复制一个单词<br> <code>p</code> 在光标后粘贴<br> <code>P</code> 在光标前粘贴<br> <code>{数字}+p</code> 多次粘贴</p>
</li>
</ol>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ol>
<li><p>常规模式</p>
<p> <code>:h registers</code> 查看man page<br> <code>&quot;+{寄存器名}</code> 引用一个寄存器<br> <code>&quot;&quot;</code> 未命名寄存器，复制或删除都会替换它的内容<br> <code>&quot;0~&quot;9</code> <code>&quot;0</code> 保存最后一次复制内容 <code>&quot;1</code>~<code>&quot;9</code> 保存最后删除的内容，<code>&quot;1</code>为最近删除<br> <code>&quot;+{寄存器名}+y</code> 复制到指定寄存器<br> <code>&quot;+{寄存器名}+p</code> 粘贴指定寄存器内容<br> <code>:reg {寄存器名}</code> 查看寄存器内容<br> <code>&quot;.</code> <code>&quot;%</code> <code>&quot;:</code> <code>&quot;#</code> 只读寄存器<br> &gt;<br> <code>&quot;.</code>存最后插入的内容；<code>&quot;%</code>存当前文件相对于vim打开时的路径；<code>&quot;:</code>存最后执行的命令，使用<code>@:</code>重复执行上一次命令；<code>&quot;#</code>存替换文件名</p>
<p> <code>&quot;=</code>保存表达式或命令结果，<code>ctrl-r =</code>可以在插入模式下粘贴结果，<code>:%s/&lt;Ctrl-r&gt;/something/g</code>可以直接替换之前搜索的结果<br> <code>:let @{寄存器名}=&#39;&lt;Ctrl-r {寄存器名}&gt;&#39;</code> 可以修改寄存器内容</p>
</li>
<li><p>编辑模式 </p>
<p> <code>ctrl+r+{寄存器名}</code> 粘贴寄存器内容</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[go-code-style-guide]]></title>
      <url>http://rivenzoo.github.io/2016/09/24/go-code-style-guide/</url>
      <content type="html"><![CDATA[<h1 id="Go-Code-Style-Guide"><a href="#Go-Code-Style-Guide" class="headerlink" title="Go Code Style Guide"></a>Go Code Style Guide</h1><p>参考 <a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="external">Golang CodeReviewComments</a> 整理而成。每条最后有<code>[require]</code>的表示要求遵守。</p>
<h3 id="Style-Guide"><a href="#Style-Guide" class="headerlink" title="Style Guide"></a>Style Guide</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ol>
<li><p>go vet 静态检查命令，修复错误提示。<code>[require]</code></p>
<p> <code>go vet pkg|file</code></p>
</li>
<li><p>goimports 代码格式化工具，功能比gofmt更多，代码提交前使用。<code>[require]</code></p>
<p> <code>goimports -w file</code></p>
</li>
<li><p>golint 代码风格检查工具，建议按提示修改代码风格。</p>
<p> <code>golint pkg|file</code></p>
</li>
</ol>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ol>
<li>命名使用单词首字母大写的规则，不要使用下划线连接单词。<code>[require]</code></li>
</ol>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ol>
<li><p>注释文档应该是完整的句子，以描述性名词开始，句号结尾。<code>[require]</code></p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Request represents a request to run a command.</span></span><br><span class="line">type <span class="type">Request</span> <span class="class"><span class="keyword">struct</span> </span>&#123; ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Encode writes the JSON encoding of req to w.</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(w io.Writer, req *Request)</span></span> &#123; ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>包和可导出的方法要有注释文档，注释文档和包声明、方法之间不要有空格。<code>[require]</code></p>
</li>
</ol>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><ol>
<li>用返回error代替panic，只在程序逻辑无法继续的情况下使用panic。<code>[require]</code></li>
<li>error字符串不应该首字母大写（除非缩写或专有名词），也不要用标点符号结尾。<code>[require]</code></li>
<li>不要用<code>_</code>丢弃错误。</li>
</ol>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><ol>
<li>import分组，排列顺序为标准库、工程内部包、第三方包。</li>
<li>避免<code>import . pkg</code>，唯一使用的情况是在测试包中。</li>
</ol>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ol>
<li>变量名使用的范围小，短名字更好；变量使用范围大，名字的描述性要好；不常用的变量和全局变量名字描述性要好。<code>[require]</code></li>
<li>声明空数组用<code>var t []string</code>而不用 <del>t := []string{}</del>，前者避免声明时分配内存。<code>[require]</code></li>
<li>对于单词缩写，全大写或全小写，不要使用首字母大写。例如使用URL/url而不用<del>Url</del>，使用appID而不用<del>appId</del>。<code>[require]</code></li>
</ol>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><ol>
<li><p>相同类型返回值使用命名返回值来区分。<code>[require]</code></p>
 <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Location returns f's latitude <span class="keyword">and</span> longitude.</span><br><span class="line">// Negative values mean south <span class="keyword">and</span> west, respectively.</span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f *Foo)</span> L<span class="title">ocation</span><span class="params">()</span> <span class="params">(lat, long float64, err error)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不要为了防止内存拷贝而传递指针，只有在需要修改对象或者传递大对象时才使用指针参数。<code>[require]</code></p>
</li>
</ol>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li>方法接受对象的名字不要使用<code>me</code>/<code>this</code>/<code>self</code>之类通用的名字，使用具体描述性单词，短方法可以使用短名字。<code>[require]</code></li>
<li>如果接受对象是map，不要使用指针。<code>[require]</code></li>
<li>如果接受对象是slice，并且不需要重新分配slice大小，不要使用指针。<code>[require]</code></li>
<li>如果接受对象是struct，并且有类似<code>sync.Mutex</code>用于同步的字段，需要使用指针避免拷贝。<code>[require]</code></li>
<li>如果接受对象是大的struct或者array，需要使用指针避免拷贝。参考函数声明参数类型选择。<code>[require]</code></li>
<li>如果需要修改接受对象，需要使用指针。<code>[require]</code></li>
<li>如果接受对象的任何元素含有可变对象或指针，建议使用指针。</li>
<li>如果接受对象是array或struct，元素和字段只包含<code>int</code>/<code>string</code>/<code>time.Time</code>这类不可变类型，建议使用值类型。</li>
<li>如果以上情况不适用，则使用指针类型。</li>
</ol>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><ol>
<li>包内部类型或函数命名不要以包名为前缀。<code>[require]</code></li>
</ol>
<h4 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h4><ol>
<li><p>及时处理错误。建议使用下面的形式。<code>[require]</code></p>
 <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br><span class="line"></span><br><span class="line">x, <span class="keyword">err</span> := <span class="built_in">f</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use x</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>init</code>函数内只做一些轻量级初始化工作，避免执行依赖其他资源的代码。<code>[require]</code></p>
</li>
</ol>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ol>
<li><p>测试失败时要描述清楚具体错误、输入输出以及期望的输出。</p>
 <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> got != tt.want &#123;</span><br><span class="line">    t.Errorf(<span class="string">"Foo(%q) = %d; want %d"</span>, tt.in, got, tt.want) // <span class="keyword">or</span> Fatalf, <span class="keyword">if</span> test can<span class="string">'t test anything more past this point</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ssh-settings]]></title>
      <url>http://rivenzoo.github.io/2016/05/24/ssh-settings/</url>
      <content type="html"><![CDATA[<h4 id="记一下平时用到的有用的ssh设置和命令"><a href="#记一下平时用到的有用的ssh设置和命令" class="headerlink" title="记一下平时用到的有用的ssh设置和命令"></a>记一下平时用到的有用的ssh设置和命令</h4><ol>
<li><p>设置防止自动断开<br><code>ssh user@host -o ServerAliveInterval=30</code><br><code>-o</code>可以设置很多选项，<code>ServerAliveInterval</code>设置隔多少秒没收到数据之后，给对方发送消息请求响应，防止连接被中断</p>
</li>
<li><p>公钥验证免密码登陆<br>服务端设置: 修改 <code>/etc/ssh/sshd_config</code>，设置 <code>RSAAuthentication yes</code>，重启ssh服务<br>本机: 生成公钥 <code>$ ssh-keygen</code>，上传公钥 <code>$ ssh user@host &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></p>
</li>
<li><p>利用session clone来打开多个会话<br>本机: 修改 <code>~/.ssh/config</code>文件，加入下面内容</p>
<pre><code>#file:~/.ssh/config
Host *
ControlMaster auto
ControlPath ~/.ssh/master-%r@%h:%p
ControlPersist 10m
</code></pre><p> 上面的配置在第一次建立ssh连接的时候把连接作为master，后面的连接都会复用第一次建立的网络连接，通过ControlPath下面的文件来确定复用哪个。只要第一个连接不中断，后面ssh命令就可以不输入密码直接连接了。</p>
</li>
<li><p>利用tmux和session clone实现免密码登录<br>找一台私人服务器，按照上面3步骤配置ssh的session clone<br>创建tmux session: <code>tmux new -s session</code><br>在tmux里面登录: <code>ssh user@host -o ServerAliveInterval=30</code><br>这样你打开新的tmux窗口直接ssh就不需要密码了<br>终端退出tmux: <code>ctrl-b &amp;</code>关闭窗口, <code>ctrl-b d</code>detach tmux client，这样tmux session的进程并不会退出，里面登录的ssh session也会保存下来<br>重新登录: <code>tmux attach -t session</code>attach client，原来登录的ssh session可以继续使用<br>登出服务器: 终端退出tmux后把tmux转到后台，假设1号job是tmux执行<code>disown %1</code>，如果进程被挂起需要执行<code>kill -cont -42813</code>，42813是tmux的pid</p>
</li>
<li><p>本地端口转发<br><code>$ ssh -NT -D 8080 host</code></p>
</li>
<li><p>python自动ssh登录<br>利用下面两个库可以实现自动ssh登录<br><code>pexpect</code>模拟shell输入<br><code>pyotp</code>进行otp验证</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Go使用Rsa加解密]]></title>
      <url>http://rivenzoo.github.io/2016/04/15/go-rsa-notes/</url>
      <content type="html"><![CDATA[<h3 id="一次使用rsa的经历"><a href="#一次使用rsa的经历" class="headerlink" title="一次使用rsa的经历"></a>一次使用rsa的经历</h3><p>   最近项目中要提供一个接口供客户端查询信息。逻辑简单主要考虑安全性问题，信息保密要求不高但是要保证是服务端返回的，也就是要防止数据被篡改和替换。</p>
<p>   因为只有一个这样的接口，而且申请证书比较麻烦就不考虑https了。客户端的安全性不是很可靠，如果用AES这样的对称加密，密钥放客户端会有较大风险。考虑用rsa加密来达到目的。</p>
<p>   初步想法是服务端保存rsa私钥，用来加密数据，客户端保存公钥，解密服务端返回的数据，这样客户端只能解服务端返回的数据，而且是密文传输。想法很简单，实现起来就遇到了问题。Go语言的rsa包提供的解密方法只能使用公钥加密。</p>
<p>   函数原型<br>    <code>func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err error)</code></p>
<p>   试验半天还是不知道如何使用私钥加密。Go论坛上有个使用私钥加密的讨论<a href="https://groups.google.com/d/msg/golang-nuts/SkOBSsqLsrE/5rLo02hutbwJ" target="_blank" rel="external">https://groups.google.com/d/msg/golang-nuts/SkOBSsqLsrE/5rLo02hutbwJ</a>，大概的意思是公钥大家都能拿到，用私钥加密的信息并没有起到保密的作用，一般私钥只用来签名。虽然理论上私钥加密是可以的，但在这里只好换一个思路。</p>
<p>   在这个场景中，签名可以达到要求，用私钥对关键信息签名，客户端用公钥校验，可以保证接受正确的服务端信息，唯一不太好的是明文传输的，需要引入一个对称加密对消息加密。</p>
<p>   要引入对称加密，可以由客户端随机生成key，用这个key对称加密带校验信息的数据，然后用公钥加密key，这样只有服务端能解出key。然后服务端把客户端带上来的校验信息和数据打包，使用这个key进行对称加密再返回，客户端用自己生成的key解密并校验数据。这样一个流程能保证接受正确的服务端信息，同时是密文传输。</p>
<p>   公钥是放在客户端的，假如被其他人拿到，破解了查询协议，最多只能查到数据。要伪造数据去欺骗其他客户端，必须同时知道其他客户端生成的key和校验信息，才能用伪造的请求的结果去欺骗这个客户端。若是AES的key泄漏，不但能查到数据，还能构造其他客户端的查询结果。</p>
<h3 id="rsa使用笔记"><a href="#rsa使用笔记" class="headerlink" title="rsa使用笔记"></a>rsa使用笔记</h3><p>   在跟客户端对接的过程中由于对rsa不是很熟悉，遇到了一些问题。</p>
<ol>
<li><p>padding模式<br>  rsa遵循公钥加密标准(Public Key Cryptography Standards, PKCS)，老的是1.x，一般用1.5，新的是2。对应的padding模式有三种：PKCS1V15对应v1.5，OAEP对应v2，Nopadding。Go的rsa库有前面两种，推荐使用OAEP。</p>
</li>
<li><p>hash算法<br>  Go的rsa库提供hash函数的参数，可以自己设置hash函数，推荐使用sha256。不同hash值的长度会影响OAEP模式下最大消息长度，下面会讲到。加解密的hash函数要设置成一样的，客户端使用的比较旧的openssl使用的sha1，跟我设置的不一样，因为这个调试了很久。对比了一下sha256和md5，md5要快一点。</p>
</li>
<li><p>消息长度<br>  每次加解密的消息长度有限制。对于v1.5，最大长度为<code>keyBytes-11</code>，<code>keyBytes</code>是私钥字节数，比如2048位的私钥就是256字节。对于v2，最大长度为<code>keyBytes-(hashSize*2+2)</code>，根据hash函数不同长度不同，比如sha1计算结果20字节，对于2048位的key最大长度<code>256-(20*2+2)</code>。<br>  如果原文超过了这个一般就分块进行加密。</p>
</li>
</ol>
<h3 id="rsa简介"><a href="#rsa简介" class="headerlink" title="rsa简介"></a>rsa简介</h3><ol>
<li>选择质数<code>p</code>和<code>q</code>，计算<code>n=p*q</code>，欧拉函数<code>φ(n)=(p-1)*(q-1)</code></li>
<li>随机选择一个整数<code>e</code>，条件是<code>1&lt; e &lt; φ(n)</code>，且<code>e</code>与<code>φ(n)</code>互质，计算模反元素<code>d</code>，即<code>(e*d)mod(φ(n))=1</code></li>
<li><p>经过上面两步得到<code>p、q、n、e、d</code>五个数，把<code>n、e</code>作为公钥，<code>n、d</code>作为私钥进行加解密。</p>
<ul>
<li>加密：消息<code>m</code>，<code>m&lt;n</code>，计算<code>(pow(m,e))mod(n)=c</code>，<code>c</code>就是<code>m</code>的密文</li>
<li>解密：密文<code>c</code>，计算<code>(pow(c,d)mod(n))=m</code></li>
<li>对于<code>m&gt;=n</code>，可以分块加密或者使用对称加密<code>m</code>然后公钥加密对称加密密钥</li>
</ul>
<p>算法的安全性保证在于很难从<code>n</code>和<code>e</code>推断出<code>d</code>，计算<code>d</code>需要知道<code>φ(n)</code>，而当<code>n</code>值很大的时候，直接计算<code>φ(n)</code>很困难，分解<code>n</code>得到<code>p、q</code>也很困难。</p>
<p>rsa原理的介绍推荐阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="external">文章</a>。</p>
</li>
</ol>
<h3 id="Go语言rsa简单封装"><a href="#Go语言rsa简单封装" class="headerlink" title="Go语言rsa简单封装"></a>Go语言rsa简单封装</h3><p>   为了方便使用做了个简单封装，放在Github上。</p>
<p>   安装方法<br>    <code>go get github.com/RivenZoo/goutil/dencrypt</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu Mount NTFS with system boot]]></title>
      <url>http://rivenzoo.github.io/2015/10/10/ubuntu-mount-ntfs/</url>
      <content type="html"><![CDATA[<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu14.<span class="number">04</span></span><br><span class="line"></span><br><span class="line">$ vim <span class="regexp">/etc/</span>fstab</span><br><span class="line"></span><br><span class="line"><span class="regexp">/dev/</span>sda2 <span class="regexp">/media ntfs auto,user,rw,async,exec 0 0 # 加exec选项才可以执行挂载目录内的程序，相当于 mount -t ntfs /</span>dev<span class="regexp">/sda2 /m</span>edia -o exec</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Go Notes]]></title>
      <url>http://rivenzoo.github.io/2015/09/19/go-notes/</url>
      <content type="html"><![CDATA[<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p>   <code>go test -v -run=[pattern]</code></p>
<h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><p>   <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t]</code></p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><ul>
<li><p>race:</p>
<p>  <code>go test -v -run=[pattern] -race</code></p>
</li>
<li><p>cpu:</p>
<p>  <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t] -cpuprofile=[output]</code></p>
</li>
<li><p>mem:</p>
<p>  <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t] -memprofile=[output]</code></p>
</li>
<li><p>block:</p>
<p>  <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t] -blockprofile=[output]</code></p>
<p>  <code>go tool pprof [program].test [output]</code></p>
</li>
</ul>
<h3 id="GODEBUG"><a href="#GODEBUG" class="headerlink" title="GODEBUG"></a>GODEBUG</h3><p>   runtime提供了环境变量来控制程序。GODEBUG是其中一，它可以设置很多值，格式<code>name=value,name=val</code>，如开启gctrace：<code>$ GODEBUG=&#39;gctrace=1&#39; your_program</code>，会在标准错误输出gc信息。</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>   推荐使用<a href="https://github.com/pquerna/ffjson" target="_blank" rel="external">ffjson</a><br>   用它替换标准库后，编解码效率提高2倍。对于一些需要编码的大对象，可以采用sync.Pool缓存一定大小的bytes.Buffer，然后直接写buffer来完成json编码，性能有一定提高，在我笔记本上测10*1024的字符串数组，大概比标准json快20%，结果受到分配buffer大小的影响。在对json对象编码的时候，如果有字符串字段，并且字符串可能出现json格式用到的字符，最好预先对字符串编码，否则json编码的时候处理字符串转义会导致性能下降，如果字符串很长，可能会成为瓶颈。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PythonBrew]]></title>
      <url>http://rivenzoo.github.io/2015/04/15/python-brew/</url>
      <content type="html"><![CDATA[<h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><p>pythonbrew作者弃坑了，推荐了另外一个项目<a href="https://github.com/yyuu/pyenv" target="_blank" rel="external">https://github.com/yyuu/pyenv</a><br>功能跟这个有重叠，貌似更强大，用的人也更多</p>
<h3 id="pythonbrew多版本管理工具"><a href="#pythonbrew多版本管理工具" class="headerlink" title="pythonbrew多版本管理工具"></a>pythonbrew多版本管理工具</h3><p>pythonbrew是一个python版本管理的工具，具体命令见<a href="http://pythonbrew.readthedocs.org/en/latest/" target="_blank" rel="external">http://pythonbrew.readthedocs.org/en/latest/</a>。</p>
<h4 id="pythonbrew-install-2-5-6-的问题"><a href="#pythonbrew-install-2-5-6-的问题" class="headerlink" title="pythonbrew install 2.5.6 的问题"></a>pythonbrew install 2.5.6 的问题</h4><p>在安装python 2.5.6的时候遇到编译错误<code>make: *** [Modules/getbuildinfo.o] error 1</code>，参考了<a href="http://askubuntu.com/questions/398481/make-python2-5-failed-on-ubuntu-13-04" target="_blank" rel="external">http://askubuntu.com/questions/398481/make-python2-5-failed-on-ubuntu-13-04</a>这里的解决方法。<br>在python 2.5.6下载解压后的目录<br><code>/HOME/.pythonbrew/build/Python-2.5.6</code>，<br>手动执行<br><code>SVNVERSION=not-found ./configure --prefix=/HOME/.pythonbrew/pythons/Python-2.5.6</code>，<br>把python2.5.6安装到了pythonbrew预定的目录就可以了。</p>
<p>pythonbrew管理虚拟环境<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pythonbrew venv init</span><br><span class="line">$ pythonbrew venv create proj -<span class="selector-tag">p</span> x<span class="selector-class">.x</span><span class="selector-class">.x</span></span><br></pre></td></tr></table></figure></p>
<p>以上2步就创建了一个可用的虚拟环境，然后到需要环境的工程，执行<code>pythonbrew venv use proj</code>就可以使用之前创建的虚拟环境了。</p>
<h5 id="ps-pythonbrew有个别名pybrew。"><a href="#ps-pythonbrew有个别名pybrew。" class="headerlink" title="ps:pythonbrew有个别名pybrew。"></a>ps:pythonbrew有个别名pybrew。</h5>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Take a look at Level source code]]></title>
      <url>http://rivenzoo.github.io/2015/03/08/leveldb-source-1/</url>
      <content type="html"><![CDATA[<p>最近看了一点leveldb源码，了解一下实现机制。</p>
<p>之前也看过leveldb相关介绍以及别人的分析blog，已经有了一定了解。leveldb如其名，按照层级来组织数据，数据从内存到磁盘一层一层迁移。在内存中是通过skiplist来管理数据，而磁盘上则是一种名为SSTable(Sorted Strings Table)的结构来存储数据的。</p>
<h5 id="DB-Get实现"><a href="#DB-Get实现" class="headerlink" title="DB::Get实现"></a>DB::Get实现</h5><p>这个头文件include/leveldb/db.h定义了DB抽象类，Get接口也在其中，具体实现在db/db_impl.cc文件中。<br>下面引用的代码因为篇幅会删除一些代码行，完整代码参考源文件。 </p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Get(<span class="keyword">const</span> ReadOptions&amp; options,</span><br><span class="line">                   <span class="keyword">const</span> Slice&amp; key,</span><br><span class="line">                   <span class="built_in">std</span>::<span class="built_in">string</span>* value) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">NULL</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = current-&gt;Get(options, lkey, value, &amp;stats);</span><br><span class="line">      have_stat_update = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) &#123;</span><br><span class="line">    MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是Get的实现函数，省略了一些代码。Get主要的查询过程在中间if-else语句分支中。在查询之前<code>mutex_.Unlock();</code>进行了解锁，是因为数据是只追加不删除的，可以同时读写。数据删除会转换成一条标记key-deleted的数据追加到库中。 </p>
<p>SequenceNumber snapshot为数据序号，每一条数据都有序号，后追加的序号比之前的序号要大，相同key的数据，序号大的要排在前面，参见<code>db/dbformat.cc</code> <code>InternalKeyComparator::Compare</code>函数。 </p>
<p>第一个分支mem指向一个MemTable，MemTable只有Add和Get两个接口来操作数据，底层实现为skiplist，这个mem指向可修改的MemTable。 </p>
<p>第二个分支imm指向一个不可修改的MemTable，imm是mem达到一定条件后转换来的，具体的逻辑在db/db_impl.cc DBImpl::MakeRoomForWrite函数中。 </p>
<p>前面2个分支都是在内存中进行查询，没找到就只能到磁盘上查询。最后一个分支current指向当前的Version，Version包含数据文件的元信息。 </p>
<p>最后根据情况调用MaybeScheduleCompaction函数，在后台对数据进行Compact，将内存的迁到磁盘，对磁盘上的数据进行合并等。</p>
<p>Version::Get实现。这个函数就是上一节最后一个if分支调用的函数，也是查询磁盘数据的入口。 </p>
<p>代码:<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Status Version::Get(const ReadOptions&amp; options,</span><br><span class="line">                    const LookupKey&amp; k,</span><br><span class="line">                    std::string* value,</span><br><span class="line">                    GetStats* stats) &#123;      </span><br><span class="line">  ...       </span><br><span class="line">  <span class="comment">// We can search level-by-level since entries never hop across</span></span><br><span class="line">  <span class="comment">// levels.  Therefore we are guaranteed that if we find data</span></span><br><span class="line">  <span class="comment">// in an smaller level, later levels are irrelevant.</span></span><br><span class="line">  std::vector&lt;FileMetaData*&gt; tmp<span class="comment">;</span></span><br><span class="line">  FileMetaData* tmp2<span class="comment">;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span><span class="comment">; level &lt; config::kNumLevels; level++) &#123;</span></span><br><span class="line">    size_t num_files = files_[level].size()<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the list of files to search in this level</span></span><br><span class="line">    FileMetaData* const* files = &amp;files_[level][<span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Level-0 files may overlap each other.  Find all files that</span></span><br><span class="line">      <span class="comment">// overlap user_key and process them in order from newest to oldest.</span></span><br><span class="line">      tmp.reserve(num_files)<span class="comment">;</span></span><br><span class="line">      <span class="keyword">for</span> (uint32_t i = <span class="number">0</span><span class="comment">; i &lt; num_files; i++) &#123;</span></span><br><span class="line">        FileMetaData* f = files[i]<span class="comment">;</span></span><br><span class="line">        <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          tmp.push_back(f)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (tmp.empty()) <span class="keyword">continue</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">      std::sort(tmp.begin(), tmp.<span class="keyword">end</span>(), NewestFirst)<span class="comment">;</span></span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Binary search to find earliest index whose largest key &gt;= ikey.</span></span><br><span class="line">      uint32_t index = FindFile(vset_-&gt;icmp_, files_[level], ikey)<span class="comment">;</span></span><br><span class="line">      <span class="keyword">if</span> (index &gt;= num_files) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp2 = files[index]<span class="comment">;</span></span><br><span class="line">        <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, tmp2-&gt;smallest.user_key()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// All of "tmp2" is past any data for user_key</span></span><br><span class="line">          ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          files = &amp;tmp2<span class="comment">;</span></span><br><span class="line">          num_files = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint32_t i = <span class="number">0</span><span class="comment">; i &lt; num_files; ++i) &#123;</span></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">      FileMetaData* f = files[i]<span class="comment">;</span></span><br><span class="line">      last_file_read = f<span class="comment">;</span></span><br><span class="line">      last_file_read_level = level<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">      Saver saver<span class="comment">;</span></span><br><span class="line">      saver.state = kNotFound<span class="comment">;</span></span><br><span class="line">      saver.ucmp = ucmp<span class="comment">;</span></span><br><span class="line">      saver.user_key = user_key<span class="comment">;</span></span><br><span class="line">      saver.value = value<span class="comment">;</span></span><br><span class="line">      s = vset_-&gt;table_cache_-&gt;Get(options, f-&gt;number, f-&gt;file_size,</span><br><span class="line">                                   ikey, &amp;saver, SaveValue)<span class="comment">;</span></span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="keyword">return</span> Status::NotFound(Slice())<span class="comment">;  // Use an empty error message for speed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的函数主要是对每个level上的数据从低到高进行查询，比较新的数据放在低的level。 </p>
<p>主for循环所有level，先根据key查找符合要求的文件，由于Sstable是排序数据，每个文件都有key的范围，所以可以查找包含了查询key的文件即可。level-0和其他的level处理方式不太一样，level-0是直接遍历，而其他level调用FindFile进行查询。 </p>
<p>找到符合要求的文件之后，进入后一个for循环，通过vset_-&gt;table<em>cache</em>-&gt;Get查找所有的文件。</p>
<p>上面提到的FindFile使用internal_key即带序号的查询key在一层的文件中进行二分查找，找到离查询key最近且文件largest-key比查询key大的文件，如果key存在库的这一层中，那应该会落在这个文件。 </p>
<p>TableCache::Get比较简单，先调用了FindTable找到对应的Table对象，然后调用Table对象的InternalGet函数。下面说FindTable函数和Table::InternalGet函数。</p>
<p>FindTable函数 </p>
<p>代码:<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,</span><br><span class="line">                             Cache::Handle** handle) &#123;</span><br><span class="line">  Status s<span class="comment">;</span></span><br><span class="line">  char buf[sizeof(file_number)]<span class="comment">;</span></span><br><span class="line">  EncodeFixed64(buf, file_number)<span class="comment">;</span></span><br><span class="line">  Slice key(buf, sizeof(buf))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  *handle = cache_-&gt;Lookup(key)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*handle == NULL) &#123;</span><br><span class="line">    std::string fname = TableFileName(dbname_, file_number)<span class="comment">;</span></span><br><span class="line">    RandomAccessFile* file = NULL<span class="comment">;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = Table::Open(*options_, file, file_size, &amp;table)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TableAndFile* tf = new TableAndFile<span class="comment">;</span></span><br><span class="line">      tf-&gt;file = file<span class="comment">;</span></span><br><span class="line">      tf-&gt;table = table<span class="comment">;</span></span><br><span class="line">      *handle = cache_-&gt;Insert(key, tf, <span class="number">1</span>, &amp;DeleteEntry)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>cache<em>-&gt;Lookup(key)先在cache中查找，cache</em>指向一个LRU的cache，缓存的内容为打开的文件对象和Table对象的指针，最后一个else语句块里cache_-&gt;Insert把要缓存的内容插入了缓存。 </p>
<p>若缓存中没有要找的Table则调用Table::Open打开文件载入Table对象，然后插入缓存。 </p>
<p>Table::Open代码:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Status Table::Open(const <span class="keyword">Options</span>&amp; <span class="keyword">options</span>,</span><br><span class="line">               RandomAccessFile* <span class="keyword">file</span>,</span><br><span class="line">               uint64_t <span class="keyword">size</span>,</span><br><span class="line">               Table** table) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">char</span> footer_space[Footer::kEncodedLength];</span><br><span class="line">  Slice footer_input;</span><br><span class="line">  Status s = <span class="keyword">file</span>-&gt;<span class="keyword">Read</span>(<span class="keyword">size</span> - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                        &amp;footer_input, footer_space);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    s = ReadBlock(<span class="keyword">file</span>, opt, footer.index_handle(), &amp;contents);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      index_block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// We've successfully read the footer and the index block: we're</span></span><br><span class="line">    <span class="comment">// ready to serve requests.</span></span><br><span class="line">    Rep* rep = <span class="keyword">new</span> Table::Rep;</span><br><span class="line">    rep-&gt;<span class="keyword">options</span> = <span class="keyword">options</span>;</span><br><span class="line">    rep-&gt;<span class="keyword">file</span> = <span class="keyword">file</span>;</span><br><span class="line">    rep-&gt;metaindex_handle = footer.metaindex_handle();</span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    rep-&gt;cache_id = (<span class="keyword">options</span>.block_cache ? <span class="keyword">options</span>.block_cache-&gt;NewId() : <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    *table = <span class="keyword">new</span> Table(rep);</span><br><span class="line">    (*table)-&gt;ReadMeta(footer);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Table::Open把index-block的内容读出来缓存起来，如果有meta数据或filter数据，也会读出来并缓存。options.block_cache这个指针如果指向一个cache对象，后面在读入新的block的时候也会把block缓存起来。</p>
<p>Table::InternalGet </p>
<p>代码:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Status Table::InternalGet(const ReadOptions&amp; options, const Slice&amp; k,</span><br><span class="line">                          void* arg,</span><br><span class="line">                          void (*saver)(void*, const Slice&amp;, const Slice&amp;)) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  I<span class="function"><span class="title">terator</span>* iiter = rep_-&gt;</span><span class="function"><span class="title">index_block</span>-&gt;</span>N<span class="function"><span class="title">ewIterator</span>(rep_-&gt;</span>options.comparator);</span><br><span class="line">  <span class="function"><span class="title">iiter</span>-&gt;</span>Seek(k);</span><br><span class="line">  <span class="function"><span class="title">if</span> (iiter-&gt;</span>Valid()) &#123;</span><br><span class="line">    S<span class="function"><span class="title">lice</span> handle_value = iiter-&gt;</span>value();</span><br><span class="line">    F<span class="function"><span class="title">ilterBlockReader</span>* filter = rep_-&gt;</span>filter;</span><br><span class="line">    BlockHandle handle;</span><br><span class="line">    <span class="keyword">if</span> (filter != NULL &amp;&amp;</span><br><span class="line">        handle.DecodeFrom(&amp;handle_value).ok() &amp;&amp;</span><br><span class="line">        !<span class="function"><span class="title">filter</span>-&gt;</span>KeyMayMatch(handle.offset(), k)) &#123;</span><br><span class="line">      <span class="comment">// Not found</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      I<span class="function"><span class="title">terator</span>* block_iter = BlockReader(this, options, iiter-&gt;</span>value());</span><br><span class="line">      <span class="function"><span class="title">block_iter</span>-&gt;</span>Seek(k);</span><br><span class="line">      <span class="function"><span class="title">if</span> (block_iter-&gt;</span>Valid()) &#123;</span><br><span class="line">        (*<span class="function"><span class="title">saver</span>)(arg, block_iter-&gt;</span><span class="function"><span class="title">key</span>(), block_iter-&gt;</span>value());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="title">s</span> = block_iter-&gt;</span>status();</span><br><span class="line">      delete block_iter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Table::InternalGet先在index-block中找到距离key最近的block，block也有key范围，查找过程和查找文件类似也是通过二分查找找到最近的block，但是index-block并不是所有block的索引，所以还需要进一步到block附近进行查找。 </p>
<p>如果找到key附近的block，就对block进行查找。先结合filter判断key是否不在，如不在直接返回NotFound。然后读index对应的block，进行二次查找。iter-&gt;Seek(k)具体可以参考table/block.cc Block::Iter::Seek函数，函数并没有进行相等比较，只能定位范围。由于iter-&gt;Seek(k)只能定位到key附近，所以需要调用(*saver)(arg, block_iter-&gt;key(), block_iter-&gt;value())，saver对应上文提到的db/version_set.cc SaveValue函数，代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveValue</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> Slice&amp; ikey, <span class="keyword">const</span> Slice&amp; v)</span> </span>&#123;</span><br><span class="line">  Saver* s = <span class="keyword">reinterpret_cast</span>&lt;Saver*&gt;(arg);</span><br><span class="line">  ParsedInternalKey parsed_key;</span><br><span class="line">  <span class="keyword">if</span> (!ParseInternalKey(ikey, &amp;parsed_key)) &#123;</span><br><span class="line">    s-&gt;state = kCorrupt;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;ucmp-&gt;Compare(parsed_key.user_key, s-&gt;user_key) == <span class="number">0</span>) &#123;</span><br><span class="line">      s-&gt;state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;</span><br><span class="line">      <span class="keyword">if</span> (s-&gt;state == kFound) &#123;</span><br><span class="line">        s-&gt;value-&gt;assign(v.data(), v.size());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据文件的编码格式比较复杂，就不写了，可以参考源文件或网络。 </p>
<p>以上就是Get的过程，流程还是比较长的。网上的测试结果表明leveldb的写性能高于读，跟它的磁盘查找关系很大，对于需要频繁随机读的应用还是要仔细考虑一下性能问题。打开block-cache可能会提高读性能，相应的就需要消耗内存，把文件放到ssd也是一个优化方案，没有具体实践，不知效果如何。 </p>
<p>欢迎指出本文的错误，也欢迎分享相关内容！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Makefile获取依赖的源文件]]></title>
      <url>http://rivenzoo.github.io/2015/03/07/makefile-source-dependency/</url>
      <content type="html"><![CDATA[<p>代码：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exclude=<span class="string">"_test"</span></span><br><span class="line"><span class="comment">#exclude="___"</span></span><br><span class="line">src=<span class="variable">$(</span>wildcard *[^<span class="variable">$(</span>exclude)].c ./subs/*.c)</span><br><span class="line"></span><br><span class="line">files=<span class="variable">$(</span>notdir <span class="variable">$(</span>src))</span><br><span class="line"></span><br><span class="line">obj=<span class="variable">$(</span>patsubst %.c,%.o,<span class="variable">$(</span>files) )</span><br><span class="line"></span><br><span class="line"><span class="symbol">all:</span></span><br><span class="line">        <span class="variable">@echo</span> <span class="variable">$(</span>src)</span><br><span class="line">        <span class="variable">@echo</span> <span class="variable">$(</span>files)</span><br><span class="line">        <span class="variable">@echo</span> <span class="variable">$(</span>obj)</span><br><span class="line">        <span class="variable">@echo</span> <span class="string">"end"</span></span><br></pre></td></tr></table></figure></p>
<p>wildcard通过通配符来匹配文件并将结果展开，第一个参数排除了_test.c的文件。<br>notdir去掉src中的目录，只保留文件名<br>patsubst进行替换，把.c换成.o<br>上面代码参考Makefile中的wildcard用法这篇blog，稍微修改了下。</p>
<h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>上面的代码</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exclude</span>=<span class="string">"_test"</span></span><br><span class="line">#<span class="keyword">exclude</span>=<span class="string">"___"</span></span><br><span class="line">src=$(wildcard *[^$(<span class="keyword">exclude</span>)].c .<span class="regexp">/subs/</span>*.c)</span><br></pre></td></tr></table></figure>
<p>其实有点问题，*[^$<em>test].c这个正则只能过滤.c之前是’</em>‘,’t’,’e’,’s’这4个字符的文件名，达不到想要的目的。<br>需要修改一下，对src进行替换</p>
<p><code>$(patsubst %_test.c,, $(src))</code></p>
<p>这样就把文件列表中含_test.c的去掉了。修改后为</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src <span class="symbol">:</span>=<span class="variable">$(</span>wildcard *.c ./subs/*.c)</span><br><span class="line">src <span class="symbol">:</span>=<span class="variable">$(</span>patsubst %_test.c,,<span class="variable">$(</span>src))</span><br><span class="line"></span><br><span class="line">files <span class="symbol">:</span>=<span class="variable">$(</span>notdir <span class="variable">$(</span>src))</span><br><span class="line"></span><br><span class="line">obj <span class="symbol">:</span>=<span class="variable">$(</span>patsubst %.c,%.o,<span class="variable">$(</span>files) )</span><br><span class="line"></span><br><span class="line"><span class="symbol">all:</span></span><br><span class="line">        <span class="variable">@echo</span> <span class="variable">$(</span>src)</span><br><span class="line">        <span class="variable">@echo</span> <span class="variable">$(</span>files)</span><br><span class="line">        <span class="variable">@echo</span> <span class="variable">$(</span>obj)</span><br><span class="line">        <span class="variable">@echo</span> <span class="string">"end"</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C语言INT_MIN定义的问题]]></title>
      <url>http://rivenzoo.github.io/2015/01/21/c-minint-define/</url>
      <content type="html"><![CDATA[<p>关于c语言INT_MIN定义的问题</p>
<p>最近看到一段代码</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br></pre></td></tr></table></figure>
<p>INT_MIN的值应该为 -2147483648，为什么不直接定义呢？原因参考<a href="http://www.cnblogs.com/Jack47/archive/2013/01/06/TMin32-in-c.html" target="_blank" rel="external">Jack47的blog:C语言中TMin的写法</a>这篇文章。</p>
<p>个人理解为C语言在处理程序中常量时，符号-和后面的值是分开处理的，先处理字面值，然后将-作为一元运算符。处理字面值的时候会决定这个常量的类型，基本的规则是选能容纳字面值的最小类型。如32位系统，2147483648这个值决定为unsigned int，如果使用<code>#define INT_MIN (-2147483648)</code>这个定义，INT_MIN类型为unsigned int。</p>
<p>写了一段代码验证</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TMIN is unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TMIN (-2147483648)        </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; TMIN) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d &gt; tmin\n"</span>, i);</span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d &lt; tmin\n"</span>, i);</span><br><span class="line">    <span class="keyword">if</span> (i &gt; INT_MIN)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d &gt;INT_MIN\n"</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(TMIN));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为</p>
<blockquote>
<p>1 &lt; tmin<br>1 &gt;INT_MIN<br>4</p>
</blockquote>
<p>补充：</p>
<p>CSAPP的补充材料<a href="http://csapp.cs.cmu.edu/public/waside/waside-tmin.pdf" target="_blank" rel="external">waside-tmin.pdf</a></p>
<p>上面的例子说明了不同格式字面值在C90和C99下面的类型确定的规则，C90 32位下类型为unsigned，就会产生上面程序的结果。</p>
<p>对于这种会产生不同行为的代码最好避免.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Notes About Kafka]]></title>
      <url>http://rivenzoo.github.io/2014/09/21/notes-about-kafka/</url>
      <content type="html"><![CDATA[<h5 id="consumer-offset-commit"><a href="#consumer-offset-commit" class="headerlink" title="consumer offset commit"></a>consumer offset commit</h5><p>使用kafka的python api时遇到了offset回滚的问题，因为最初使用了autocommit参数，发现有时会重复取记录，发现autocommit是批量提交，并且有offset回滚的问题，具体原因未发现，解决方法是手动调用commit函数提交，经过测试手动调用没有出现offset回滚的问题。</p>
<h5 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h5><p>一开始为了简单只使用了一个分区，consumer都从一个leader取数据，请求压力都在一台机器。使用不同分区策略可以分散topic的leader，还可以灵活处理不同数据。</p>
<h5 id="fetch-msg"><a href="#fetch-msg" class="headerlink" title="fetch msg"></a>fetch msg</h5><p>MaxWaitTime 请求最大等待时间，MinBytes 请求消息的最小字节数，通过这2个参数可以调整你获取数据时的等待策略，最简单的做法就是不等待，没数据直接返回。</p>
<h5 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h5><p>由于硬盘限制，把kafka和zookeeper的日志目录放在了同一个磁盘，而且磁盘的性能不是很好，造成了kafka写数据效率低下，每次写数据只有几百k。zookeeper网站上对这2个配置有Notes说不要把他们放在繁忙的磁盘设备上，会影响其他程序写磁盘的性能，最好这2个目录都分开存放不同设备。简单看了一下，dataDir下存的是snapshot文件，dataLogDir存的是log文件，应该是zookeeper把内存数据持久化到这2种文件中了，而且持久化操作很频繁且写的数据很少，会影响kafka写日志。</p>
<h5 id="磁盘参数"><a href="#磁盘参数" class="headerlink" title="磁盘参数"></a>磁盘参数</h5><p>在排查磁盘io高的问题时用到了<code>iostat -d -x</code>命令，在排查时主要关注w/s、wkB/s、rkB/s，对于扇区没怎么关注，rsec/s wsec/s avgrq-sz这几个参数反应磁盘操作扇区的情况，当磁盘利用率高且iowait高，而平均扇区低也就意味着磁盘把大量时间用于磁盘寻道，你可能需要考虑是不是有大量随机写磁盘的操作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重入与线程安全]]></title>
      <url>http://rivenzoo.github.io/2013/11/22/about-thread-safe/</url>
      <content type="html"><![CDATA[<p>在stackoverflow上看的的关于可重入与线程安全的区别：</p>
<blockquote>
<p>These functions are not reentrant. They are thread-safe. There’s a big difference. Functions that are reentrant are automatically thread-safe, but thread-safe functions can still deadlock (or worse) if called again from the same thread they’re already running in (for example from a signal handler).</p>
</blockquote>
<p>函数可重入很自然会觉得该函数是线程安全的，既然能被其他流程中断并可调用自身也就可以被多个线程同时调用。但是线程安全是不是可重入有点模糊，上面说了一种情况，当重复调用一个线程安全的函数，并且函数中有锁就有可能发生死锁，表明线程安全不一定可重入。看来重入的要求比线程安全要更严格一点。</p>
<p>附带查了查关于Posix的标准io操作，Posix标准要求操作字符流的函数实现为可重入，但是各个实现为了性能方面的考虑都没有实现为可重入的，这些函数有潜在不安全。但是又说明：</p>
<blockquote>
<p>all standard I/O functions that reference character streams shall behave as if they use flockfile() and funlockfile() internally to obtain ownership of the character streams</p>
</blockquote>
<p>表明它们应该是线程安全的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自定义linux信号]]></title>
      <url>http://rivenzoo.github.io/2013/11/05/define-linux-signal/</url>
      <content type="html"><![CDATA[<p>有时候我们需要在程序中利用信号来控制程序行为，linux为我们提供了2个已经定义的信号SIGUSR1和SIGUSR2，一般的程序利用这2个信号已经能满足需要，不过我最近需要一些其他信号来避免覆盖原来的信号处理函数。 </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSIG_MSG        (SIGUSR2 + 1)</span></span><br><span class="line"><span class="comment">// 定义信号然后注册处理函数</span></span><br></pre></td></tr></table></figure>
<p>然后到系统里查了一下，MYSIG_MSG其实将其他的信号给覆盖了<br><code>$kill -l</code></p>
<blockquote>
<p>10) SIGUSR1    11) SIGSEGV    12) SIGUSR2 13) SIGPIPE    14) SIGALRM </p>
</blockquote>
<p>虽然SIGPIPE和SIGALRM在这个程序中没有用到，但是这并不是我想要的效果。<br>我发现在后面有 </p>
<blockquote>
<p>34) SIGRTMIN 35) SIGRTMIN+1    36) SIGRTMIN+2 </p>
</blockquote>
<p><code>man 7 signal</code>页面同样也说明可以用 SIGRTMIN作为自定义信号。然后程序里就多了下面的代码： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSIG_MSG        (SIGRTMIN+ 1)</span></span><br></pre></td></tr></table></figure>
<p>结果出错了，但是并不是这个定义方式的问题。在我程序中有下面的代码： </p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(signo)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attribute">MYSIG_MSG</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span><br><span class="line">编译时才发现原来SIGRTMIN并不是一个常量，看了头文件里才知道：</span></span><br></pre></td></tr></table></figure>
<p>// centos5.9 /usr/include/bits/signum.h</p>
<p>#define SIGRTMIN        (__libc_current_sigrtmin ())<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">原来是函数调用，运行时确定的。 </span><br><span class="line">要用这个SIGRTMIN宏是不行，只能自己定义了：</span><br></pre></td></tr></table></figure></p>
<p>#define MYSIGRTMIN    34</p>
<p>#define MYSIG_MSG     (MYSIGRTMIN + 1)<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在找到系统定义的SIGRTMIN值之前，根据man <span class="number">7</span> <span class="keyword">signal</span><span class="string">里面的说明：</span></span><br><span class="line">&gt; Linux supports <span class="number">32</span> <span class="built_in">real</span>-time signals, numbered from <span class="number">32</span> (SIGRTMIN) to <span class="number">63</span> (SIGRTMAX). </span><br><span class="line">我把自定义的信号值定义成了<span class="number">32</span>，但是一直注册不了这个信号，后来赫然发现在 <span class="string">`man 7 signal`</span>下面有一行说明， </span><br><span class="line">&gt; However, the glibc POSIX threads implementation internally uses two (<span class="keyword">for</span> NPTL) or three  (<span class="keyword">for</span>  LinuxThreads)  <span class="built_in">real</span>-time signals  (see  pthreads(<span class="number">7</span>)), and adjusts the value <span class="keyword">of</span> SIGRTMIN suitably (to <span class="number">34</span> or <span class="number">35</span>) </span><br><span class="line"></span><br><span class="line">这个说明在ubuntu12<span class="number">.04</span>里面看见的，估计centos也有类似的情况。同时头文件下面也有：</span><br></pre></td></tr></table></figure></p>
<p>/<em> These are the hard limits of the kernel.  These values should not be<br>used directly at user level.  </em>/</p>
<p>#define __SIGRTMIN  32</p>
<p>#define __SIGRTMAX  (_NSIG - 1)<br>```<br>改成34之后就没有问题了。不过这个方法不太可靠，程序不应该直接用常量标识信号. </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://rivenzoo.github.io/2013/09/01/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
