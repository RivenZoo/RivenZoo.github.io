<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Go使用Rsa加解密]]></title>
      <url>http://rivenzoo.github.io/2016/04/15/go-rsa-notes/</url>
      <content type="html"><![CDATA[<h4 id="一次使用rsa的经历"><a href="#一次使用rsa的经历" class="headerlink" title="一次使用rsa的经历"></a>一次使用rsa的经历</h4><p>   最近项目中要提供一个接口供客户端查询信息。逻辑简单但要考虑安全性问题，信息保密要求不高但是要保证是服务端返回的，也就是要防止数据被篡改和替换。</p>
<p>   因为只有一个这样的接口，而且申请证书比较麻烦就不考虑https了。客户端的安全性不是很可靠，如果用AES这样的对称加密，密钥放客户端会有较大风险，只能考虑用rsa来达到目的。</p>
<p>   初步想法是服务端保存rsa私钥，用来加密数据，客户端保存公钥，解密服务端返回的数据，这样客户端只能解服务端返回的数据，而且是密文传输。</p>
<p>   想法很简单，实现起来就遇到了问题。Go语言的rsa包提供的解密方法只能使用公钥加密。</p>
<p>   函数原型<br>    <code>func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err error)</code></p>
<p>   找了半天没找到使用私钥加密的方法。论坛上有关于这个的讨论<a href="https://groups.google.com/d/msg/golang-nuts/SkOBSsqLsrE/5rLo02hutbwJ" target="_blank" rel="external">https://groups.google.com/d/msg/golang-nuts/SkOBSsqLsrE/5rLo02hutbwJ</a>，大概的意思是公钥大家都能拿到，用私钥加密的信息并没有起到保密的作用，一般私钥只用来签名。虽然理论上私钥加密是可以的，但在这里只好换一个思路。</p>
<p>   在这个场景中，签名可以达到要求，用私钥对关键信息签名，客户端用公钥校验，可以保证接受正确的服务端信息，唯一不太好的是明文传输的，需要引入一个对称加密对消息加密。</p>
<p>   既然要引入对称加密，可以由客户端随机生成key，用这个key对称加密带校验信息的数据，然后用公钥加密key，这样只有服务端能解出key。然后服务端把客户端带上来的校验信息和数据打包，使用这个key进行对称加密再返回，客户端用自己生成的key解密并校验数据。这样一个流程能保证接受正确的服务端信息，同时是密文传输。</p>
<p>   公钥是放在客户端的，假如被其他人拿到，破解了查询协议，最多只能查到数据。要伪造数据去欺骗其他客户端，必须同时知道其他客户端生成的key和校验信息，才能用伪造的请求的结果去欺骗这个客户端。若是AES的key泄漏，不但能查到数据，还能构造其他客户端的查询结果。</p>
<h4 id="rsa使用笔记"><a href="#rsa使用笔记" class="headerlink" title="rsa使用笔记"></a>rsa使用笔记</h4><p>   在跟客户端对接的过程中由于对rsa不是很熟悉，遇到了一些问题。</p>
<ol>
<li><p>padding模式<br>  rsa有个PKCS规范，老的是1.x，一般用1.5，新的是2。对应的padding模式有三种：PKCS1V15对应v1.5，OAEP对应v2，Nopadding。Go的rsa库有前面两种，推荐使用OAEP。</p>
</li>
<li><p>hash算法<br>  Go的rsa库提供hash函数的参数可以自己设置hash函数，推荐使用sha256。不同hash值的长度会影响OAEP模式下最大消息长度，下面会讲到。加解密的hash函数要设置成一样的，客户端使用的比较旧的openssl使用的sha1，跟我设置的不一样，因为这个调试了很久。对比了一下sha256和md5，md5要快一点。</p>
</li>
<li><p>消息长度<br>  每次加解密的消息长度有限制。对于v1.5，最大长度为(keyBytes-11)，keyBytes是私钥字节数，比如2048位的私钥就是256字节。对于v2，最大长度为(keyBytes-(hashSize<em>2+2))，根据hash函数不同长度不同，比如sha1计算结果20字节，对于2048位的key最大长度256-(20</em>2+2)。<br>  如果原文超高了这个一般就分块进行加密。</p>
</li>
</ol>
<h4 id="rsa简单封装"><a href="#rsa简单封装" class="headerlink" title="rsa简单封装"></a>rsa简单封装</h4><p>   为了方便使用做了个简单封装，放在Github上。</p>
<p>   安装方法<br>    <code>go get github.com/RivenZoo/goutil/dencrypt</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu Mount NTFS with system boot]]></title>
      <url>http://rivenzoo.github.io/2015/10/10/ubuntu-mount-ntfs/</url>
      <content type="html"><![CDATA[<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu14.<span class="number">04</span></span><br><span class="line"></span><br><span class="line">$ vim <span class="regexp">/etc/</span>fstab</span><br><span class="line"></span><br><span class="line"><span class="regexp">/dev/</span>sda2 <span class="regexp">/media ntfs auto,user,rw,async,exec 0 0 # 加exec选项才可以执行挂载目录内的程序，相当于 mount -t ntfs /</span>dev<span class="regexp">/sda2 /m</span>edia -o exec</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Go Notes]]></title>
      <url>http://rivenzoo.github.io/2015/09/19/go-notes/</url>
      <content type="html"><![CDATA[<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p>   <code>go test -v -run=[pattern]</code></p>
<h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><p>   <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t]</code></p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><ul>
<li><p>race:</p>
<p>  <code>go test -v -run=[pattern] -race</code></p>
</li>
<li><p>cpu:</p>
<p>  <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t] -cpuprofile=[output]</code></p>
</li>
<li><p>mem:</p>
<p>  <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t] -memprofile=[output]</code></p>
</li>
<li><p>block:</p>
<p>  <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t] -blockprofile=[output]</code></p>
<p>  <code>go tool pprof [program].test [output]</code></p>
</li>
</ul>
<h3 id="GODEBUG"><a href="#GODEBUG" class="headerlink" title="GODEBUG"></a>GODEBUG</h3><p>   runtime提供了环境变量来控制程序。GODEBUG是其中一，它可以设置很多值，格式<code>name=value,name=val</code>，如开启gctrace：<code>$ GODEBUG=&#39;gctrace=1&#39; your_program</code>，会在标准错误输出gc信息。</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>   推荐使用<a href="https://github.com/pquerna/ffjson" target="_blank" rel="external">ffjson</a><br>   用它替换标准库后，编解码效率提高2倍。对于一些需要编码的大对象，可以采用sync.Pool缓存一定大小的bytes.Buffer，然后直接写buffer来完成json编码，性能有一定提高，在我笔记本上测10*1024的字符串数组，大概比标准json快20%，结果受到分配buffer大小的影响。在对json对象编码的时候，如果有字符串字段，并且字符串可能出现json格式用到的字符，最好预先对字符串编码，否则json编码的时候处理字符串转义会导致性能下降，如果字符串很长，可能会成为瓶颈。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PythonBrew]]></title>
      <url>http://rivenzoo.github.io/2015/04/15/python-brew/</url>
      <content type="html"><![CDATA[<h3 id="pythonbrew多版本管理工具"><a href="#pythonbrew多版本管理工具" class="headerlink" title="pythonbrew多版本管理工具"></a>pythonbrew多版本管理工具</h3><p>pythonbrew是一个python版本管理的工具，具体命令见<a href="http://pythonbrew.readthedocs.org/en/latest/" target="_blank" rel="external">http://pythonbrew.readthedocs.org/en/latest/</a>。</p>
<h4 id="pythonbrew-install-2-5-6-的问题"><a href="#pythonbrew-install-2-5-6-的问题" class="headerlink" title="pythonbrew install 2.5.6 的问题"></a>pythonbrew install 2.5.6 的问题</h4><p>在安装python 2.5.6的时候遇到编译错误<code>make: *** [Modules/getbuildinfo.o] error 1</code>，参考了<a href="http://askubuntu.com/questions/398481/make-python2-5-failed-on-ubuntu-13-04" target="_blank" rel="external">http://askubuntu.com/questions/398481/make-python2-5-failed-on-ubuntu-13-04</a>这里的解决方法。<br>在python 2.5.6下载解压后的目录<br><code>/HOME/.pythonbrew/build/Python-2.5.6</code>，<br>手动执行<br><code>SVNVERSION=not-found ./configure --prefix=/HOME/.pythonbrew/pythons/Python-2.5.6</code>，<br>把python2.5.6安装到了pythonbrew预定的目录就可以了。</p>
<p>pythonbrew管理虚拟环境<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pythonbrew venv init</span><br><span class="line">$ pythonbrew venv create proj -<span class="selector-tag">p</span> x<span class="selector-class">.x</span><span class="selector-class">.x</span></span><br></pre></td></tr></table></figure></p>
<p>以上2步就创建了一个可用的虚拟环境，然后到需要环境的工程，执行<code>pythonbrew venv use proj</code>就可以使用之前创建的虚拟环境了。</p>
<h5 id="ps-pythonbrew有个别名pybrew。"><a href="#ps-pythonbrew有个别名pybrew。" class="headerlink" title="ps:pythonbrew有个别名pybrew。"></a>ps:pythonbrew有个别名pybrew。</h5>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Take a look at Level source code]]></title>
      <url>http://rivenzoo.github.io/2015/03/08/leveldb-source-1/</url>
      <content type="html"><![CDATA[<p>最近看了一点leveldb源码，了解一下实现机制。</p>
<p>之前也看过leveldb相关介绍以及别人的分析blog，已经有了一定了解。leveldb如其名，按照层级来组织数据，数据从内存到磁盘一层一层迁移。在内存中是通过skiplist来管理数据，而磁盘上则是一种名为SSTable(Sorted Strings Table)的结构来存储数据的。</p>
<h5 id="DB-Get实现"><a href="#DB-Get实现" class="headerlink" title="DB::Get实现"></a>DB::Get实现</h5><p>这个头文件include/leveldb/db.h定义了DB抽象类，Get接口也在其中，具体实现在db/db_impl.cc文件中。<br>下面引用的代码因为篇幅会删除一些代码行，完整代码参考源文件。 </p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Get(<span class="keyword">const</span> ReadOptions&amp; options,</span><br><span class="line">                   <span class="keyword">const</span> Slice&amp; key,</span><br><span class="line">                   <span class="built_in">std</span>::<span class="built_in">string</span>* value) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">NULL</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = current-&gt;Get(options, lkey, value, &amp;stats);</span><br><span class="line">      have_stat_update = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) &#123;</span><br><span class="line">    MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是Get的实现函数，省略了一些代码。Get主要的查询过程在中间if-else语句分支中。在查询之前<code>mutex_.Unlock();</code>进行了解锁，是因为数据是只追加不删除的，可以同时读写。数据删除会转换成一条标记key-deleted的数据追加到库中。 </p>
<p>SequenceNumber snapshot为数据序号，每一条数据都有序号，后追加的序号比之前的序号要大，相同key的数据，序号大的要排在前面，参见<code>db/dbformat.cc</code> <code>InternalKeyComparator::Compare</code>函数。 </p>
<p>第一个分支mem指向一个MemTable，MemTable只有Add和Get两个接口来操作数据，底层实现为skiplist，这个mem指向可修改的MemTable。 </p>
<p>第二个分支imm指向一个不可修改的MemTable，imm是mem达到一定条件后转换来的，具体的逻辑在db/db_impl.cc DBImpl::MakeRoomForWrite函数中。 </p>
<p>前面2个分支都是在内存中进行查询，没找到就只能到磁盘上查询。最后一个分支current指向当前的Version，Version包含数据文件的元信息。 </p>
<p>最后根据情况调用MaybeScheduleCompaction函数，在后台对数据进行Compact，将内存的迁到磁盘，对磁盘上的数据进行合并等。</p>
<p>Version::Get实现。这个函数就是上一节最后一个if分支调用的函数，也是查询磁盘数据的入口。 </p>
<p>代码:<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Status Version::Get(const ReadOptions&amp; options,</span><br><span class="line">                    const LookupKey&amp; k,</span><br><span class="line">                    std::string* value,</span><br><span class="line">                    GetStats* stats) &#123;      </span><br><span class="line">  ...       </span><br><span class="line">  <span class="comment">// We can search level-by-level since entries never hop across</span></span><br><span class="line">  <span class="comment">// levels.  Therefore we are guaranteed that if we find data</span></span><br><span class="line">  <span class="comment">// in an smaller level, later levels are irrelevant.</span></span><br><span class="line">  std::vector&lt;FileMetaData*&gt; tmp<span class="comment">;</span></span><br><span class="line">  FileMetaData* tmp2<span class="comment">;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span><span class="comment">; level &lt; config::kNumLevels; level++) &#123;</span></span><br><span class="line">    size_t num_files = files_[level].size()<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the list of files to search in this level</span></span><br><span class="line">    FileMetaData* const* files = &amp;files_[level][<span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Level-0 files may overlap each other.  Find all files that</span></span><br><span class="line">      <span class="comment">// overlap user_key and process them in order from newest to oldest.</span></span><br><span class="line">      tmp.reserve(num_files)<span class="comment">;</span></span><br><span class="line">      <span class="keyword">for</span> (uint32_t i = <span class="number">0</span><span class="comment">; i &lt; num_files; i++) &#123;</span></span><br><span class="line">        FileMetaData* f = files[i]<span class="comment">;</span></span><br><span class="line">        <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          tmp.push_back(f)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (tmp.empty()) <span class="keyword">continue</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">      std::sort(tmp.begin(), tmp.<span class="keyword">end</span>(), NewestFirst)<span class="comment">;</span></span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Binary search to find earliest index whose largest key &gt;= ikey.</span></span><br><span class="line">      uint32_t index = FindFile(vset_-&gt;icmp_, files_[level], ikey)<span class="comment">;</span></span><br><span class="line">      <span class="keyword">if</span> (index &gt;= num_files) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp2 = files[index]<span class="comment">;</span></span><br><span class="line">        <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, tmp2-&gt;smallest.user_key()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// All of "tmp2" is past any data for user_key</span></span><br><span class="line">          ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          files = &amp;tmp2<span class="comment">;</span></span><br><span class="line">          num_files = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint32_t i = <span class="number">0</span><span class="comment">; i &lt; num_files; ++i) &#123;</span></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">      FileMetaData* f = files[i]<span class="comment">;</span></span><br><span class="line">      last_file_read = f<span class="comment">;</span></span><br><span class="line">      last_file_read_level = level<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">      Saver saver<span class="comment">;</span></span><br><span class="line">      saver.state = kNotFound<span class="comment">;</span></span><br><span class="line">      saver.ucmp = ucmp<span class="comment">;</span></span><br><span class="line">      saver.user_key = user_key<span class="comment">;</span></span><br><span class="line">      saver.value = value<span class="comment">;</span></span><br><span class="line">      s = vset_-&gt;table_cache_-&gt;Get(options, f-&gt;number, f-&gt;file_size,</span><br><span class="line">                                   ikey, &amp;saver, SaveValue)<span class="comment">;</span></span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="keyword">return</span> Status::NotFound(Slice())<span class="comment">;  // Use an empty error message for speed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的函数主要是对每个level上的数据从低到高进行查询，比较新的数据放在低的level。 </p>
<p>主for循环所有level，先根据key查找符合要求的文件，由于Sstable是排序数据，每个文件都有key的范围，所以可以查找包含了查询key的文件即可。level-0和其他的level处理方式不太一样，level-0是直接遍历，而其他level调用FindFile进行查询。 </p>
<p>找到符合要求的文件之后，进入后一个for循环，通过vset_-&gt;table<em>cache</em>-&gt;Get查找所有的文件。</p>
<p>上面提到的FindFile使用internal_key即带序号的查询key在一层的文件中进行二分查找，找到离查询key最近且文件largest-key比查询key大的文件，如果key存在库的这一层中，那应该会落在这个文件。 </p>
<p>TableCache::Get比较简单，先调用了FindTable找到对应的Table对象，然后调用Table对象的InternalGet函数。下面说FindTable函数和Table::InternalGet函数。</p>
<p>FindTable函数 </p>
<p>代码:<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,</span><br><span class="line">                             Cache::Handle** handle) &#123;</span><br><span class="line">  Status s<span class="comment">;</span></span><br><span class="line">  char buf[sizeof(file_number)]<span class="comment">;</span></span><br><span class="line">  EncodeFixed64(buf, file_number)<span class="comment">;</span></span><br><span class="line">  Slice key(buf, sizeof(buf))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  *handle = cache_-&gt;Lookup(key)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*handle == NULL) &#123;</span><br><span class="line">    std::string fname = TableFileName(dbname_, file_number)<span class="comment">;</span></span><br><span class="line">    RandomAccessFile* file = NULL<span class="comment">;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = Table::Open(*options_, file, file_size, &amp;table)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TableAndFile* tf = new TableAndFile<span class="comment">;</span></span><br><span class="line">      tf-&gt;file = file<span class="comment">;</span></span><br><span class="line">      tf-&gt;table = table<span class="comment">;</span></span><br><span class="line">      *handle = cache_-&gt;Insert(key, tf, <span class="number">1</span>, &amp;DeleteEntry)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>cache<em>-&gt;Lookup(key)先在cache中查找，cache</em>指向一个LRU的cache，缓存的内容为打开的文件对象和Table对象的指针，最后一个else语句块里cache_-&gt;Insert把要缓存的内容插入了缓存。 </p>
<p>若缓存中没有要找的Table则调用Table::Open打开文件载入Table对象，然后插入缓存。 </p>
<p>Table::Open代码:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Status Table::Open(const <span class="keyword">Options</span>&amp; <span class="keyword">options</span>,</span><br><span class="line">               RandomAccessFile* <span class="keyword">file</span>,</span><br><span class="line">               uint64_t <span class="keyword">size</span>,</span><br><span class="line">               Table** table) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">char</span> footer_space[Footer::kEncodedLength];</span><br><span class="line">  Slice footer_input;</span><br><span class="line">  Status s = <span class="keyword">file</span>-&gt;<span class="keyword">Read</span>(<span class="keyword">size</span> - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                        &amp;footer_input, footer_space);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    s = ReadBlock(<span class="keyword">file</span>, opt, footer.index_handle(), &amp;contents);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      index_block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// We've successfully read the footer and the index block: we're</span></span><br><span class="line">    <span class="comment">// ready to serve requests.</span></span><br><span class="line">    Rep* rep = <span class="keyword">new</span> Table::Rep;</span><br><span class="line">    rep-&gt;<span class="keyword">options</span> = <span class="keyword">options</span>;</span><br><span class="line">    rep-&gt;<span class="keyword">file</span> = <span class="keyword">file</span>;</span><br><span class="line">    rep-&gt;metaindex_handle = footer.metaindex_handle();</span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    rep-&gt;cache_id = (<span class="keyword">options</span>.block_cache ? <span class="keyword">options</span>.block_cache-&gt;NewId() : <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    *table = <span class="keyword">new</span> Table(rep);</span><br><span class="line">    (*table)-&gt;ReadMeta(footer);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Table::Open把index-block的内容读出来缓存起来，如果有meta数据或filter数据，也会读出来并缓存。options.block_cache这个指针如果指向一个cache对象，后面在读入新的block的时候也会把block缓存起来。</p>
<p>Table::InternalGet </p>
<p>代码:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Status Table::InternalGet(const ReadOptions&amp; options, const Slice&amp; k,</span><br><span class="line">                          void* arg,</span><br><span class="line">                          void (*saver)(void*, const Slice&amp;, const Slice&amp;)) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  I<span class="function"><span class="title">terator</span>* iiter = rep_-&gt;</span><span class="function"><span class="title">index_block</span>-&gt;</span>N<span class="function"><span class="title">ewIterator</span>(rep_-&gt;</span>options.comparator);</span><br><span class="line">  <span class="function"><span class="title">iiter</span>-&gt;</span>Seek(k);</span><br><span class="line">  <span class="function"><span class="title">if</span> (iiter-&gt;</span>Valid()) &#123;</span><br><span class="line">    S<span class="function"><span class="title">lice</span> handle_value = iiter-&gt;</span>value();</span><br><span class="line">    F<span class="function"><span class="title">ilterBlockReader</span>* filter = rep_-&gt;</span>filter;</span><br><span class="line">    BlockHandle handle;</span><br><span class="line">    <span class="keyword">if</span> (filter != NULL &amp;&amp;</span><br><span class="line">        handle.DecodeFrom(&amp;handle_value).ok() &amp;&amp;</span><br><span class="line">        !<span class="function"><span class="title">filter</span>-&gt;</span>KeyMayMatch(handle.offset(), k)) &#123;</span><br><span class="line">      <span class="comment">// Not found</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      I<span class="function"><span class="title">terator</span>* block_iter = BlockReader(this, options, iiter-&gt;</span>value());</span><br><span class="line">      <span class="function"><span class="title">block_iter</span>-&gt;</span>Seek(k);</span><br><span class="line">      <span class="function"><span class="title">if</span> (block_iter-&gt;</span>Valid()) &#123;</span><br><span class="line">        (*<span class="function"><span class="title">saver</span>)(arg, block_iter-&gt;</span><span class="function"><span class="title">key</span>(), block_iter-&gt;</span>value());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="title">s</span> = block_iter-&gt;</span>status();</span><br><span class="line">      delete block_iter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Table::InternalGet先在index-block中找到距离key最近的block，block也有key范围，查找过程和查找文件类似也是通过二分查找找到最近的block，但是index-block并不是所有block的索引，所以还需要进一步到block附近进行查找。 </p>
<p>如果找到key附近的block，就对block进行查找。先结合filter判断key是否不在，如不在直接返回NotFound。然后读index对应的block，进行二次查找。iter-&gt;Seek(k)具体可以参考table/block.cc Block::Iter::Seek函数，函数并没有进行相等比较，只能定位范围。由于iter-&gt;Seek(k)只能定位到key附近，所以需要调用(*saver)(arg, block_iter-&gt;key(), block_iter-&gt;value())，saver对应上文提到的db/version_set.cc SaveValue函数，代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveValue</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> Slice&amp; ikey, <span class="keyword">const</span> Slice&amp; v)</span> </span>&#123;</span><br><span class="line">  Saver* s = <span class="keyword">reinterpret_cast</span>&lt;Saver*&gt;(arg);</span><br><span class="line">  ParsedInternalKey parsed_key;</span><br><span class="line">  <span class="keyword">if</span> (!ParseInternalKey(ikey, &amp;parsed_key)) &#123;</span><br><span class="line">    s-&gt;state = kCorrupt;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;ucmp-&gt;Compare(parsed_key.user_key, s-&gt;user_key) == <span class="number">0</span>) &#123;</span><br><span class="line">      s-&gt;state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;</span><br><span class="line">      <span class="keyword">if</span> (s-&gt;state == kFound) &#123;</span><br><span class="line">        s-&gt;value-&gt;assign(v.data(), v.size());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据文件的编码格式比较复杂，就不写了，可以参考源文件或网络。 </p>
<p>以上就是Get的过程，流程还是比较长的。网上的测试结果表明leveldb的写性能高于读，跟它的磁盘查找关系很大，对于需要频繁随机读的应用还是要仔细考虑一下性能问题。打开block-cache可能会提高读性能，相应的就需要消耗内存，把文件放到ssd也是一个优化方案，没有具体实践，不知效果如何。 </p>
<p>欢迎指出本文的错误，也欢迎分享相关内容！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Makefile获取依赖的源文件]]></title>
      <url>http://rivenzoo.github.io/2015/03/07/makefile-source-dependency/</url>
      <content type="html"><![CDATA[<p>代码：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exclude=<span class="string">"_test"</span></span><br><span class="line"><span class="comment">#exclude="___"</span></span><br><span class="line">src=<span class="variable">$(</span>wildcard *[^<span class="variable">$(</span>exclude)].c ./subs/*.c)</span><br><span class="line"></span><br><span class="line">dir=<span class="variable">$(</span>notdir <span class="variable">$(</span>src))</span><br><span class="line"></span><br><span class="line">obj=<span class="variable">$(</span>patsubst %.c,%.o,<span class="variable">$(</span>dir) )</span><br><span class="line"></span><br><span class="line"><span class="symbol">all:</span></span><br><span class="line">        <span class="variable">@echo</span> <span class="variable">$(</span>src)</span><br><span class="line">        <span class="variable">@echo</span> <span class="variable">$(</span>dir)</span><br><span class="line">        <span class="variable">@echo</span> <span class="variable">$(</span>obj)</span><br><span class="line">        <span class="variable">@echo</span> <span class="string">"end"</span></span><br></pre></td></tr></table></figure></p>
<p>wildcard通过通配符来匹配文件并将结果展开，第一个参数排除了_test.c的文件。<br>notdir去掉src中的目录，只保留文件名<br>patsubst进行替换，把.c换成.o<br>上面代码参考Makefile中的wildcard用法这篇blog，稍微修改了下。</p>
<h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>上面的代码</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exclude</span>=<span class="string">"_test"</span></span><br><span class="line">#<span class="keyword">exclude</span>=<span class="string">"___"</span></span><br><span class="line">src=$(wildcard *[^$(<span class="keyword">exclude</span>)].c .<span class="regexp">/subs/</span>*.c)</span><br></pre></td></tr></table></figure>
<p>其实有点问题，*[^$<em>test].c这个正则只能过滤.c之前是’</em>‘,’t’,’e’,’s’这4个字符的文件名，达不到想要的目的。<br>需要修改一下，对src进行替换</p>
<p><code>$(patsubst %_test.c,, $(src))</code></p>
<p>这样就把文件列表中含_test.c的去掉了。修改后为</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src <span class="symbol">:</span>=<span class="variable">$(</span>wildcard *.c ./subs/*.c)</span><br><span class="line">src <span class="symbol">:</span>=<span class="variable">$(</span>patsubst %_test.c,,<span class="variable">$(</span>src))</span><br><span class="line"></span><br><span class="line">dir <span class="symbol">:</span>=<span class="variable">$(</span>notdir <span class="variable">$(</span>src))</span><br><span class="line"></span><br><span class="line">obj <span class="symbol">:</span>=<span class="variable">$(</span>patsubst %.c,%.o,<span class="variable">$(</span>dir) )</span><br><span class="line"></span><br><span class="line"><span class="symbol">all:</span></span><br><span class="line">        <span class="variable">@echo</span> <span class="variable">$(</span>src)</span><br><span class="line">        <span class="variable">@echo</span> <span class="variable">$(</span>dir)</span><br><span class="line">        <span class="variable">@echo</span> <span class="variable">$(</span>obj)</span><br><span class="line">        <span class="variable">@echo</span> <span class="string">"end"</span></span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C语言INT_MIN定义的问题]]></title>
      <url>http://rivenzoo.github.io/2015/01/21/c-minint-define/</url>
      <content type="html"><![CDATA[<p>关于c语言INT_MIN定义的问题</p>
<p>最近看到一段代码<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br></pre></td></tr></table></figure></p>
<p>INT_MIN的值应该为 -2147483648，为什么不直接定义呢？原因参考<a href="http://www.cnblogs.com/Jack47/archive/2013/01/06/TMin32-in-c.html" target="_blank" rel="external">Jack47的blog:C语言中TMin的写法</a>这篇文章。</p>
<p>个人理解为C语言在处理程序中常量时，符号-和后面的值是分开处理的，先处理字面值，然后将-作为一元运算符。处理字面值的时候会决定这个常量的类型，基本的规则是选能容纳字面值的最小类型。如32位系统，2147483648这个值决定为unsigned int，如果使用<code>#define INT_MIN (-2147483648)</code>这个定义，INT_MIN类型为unsigned int。</p>
<p>写了一段代码验证</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TMIN is unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TMIN (-2147483648)        </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; TMIN) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d &gt; tmin\n"</span>, i);</span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d &lt; tmin\n"</span>, i);</span><br><span class="line">    <span class="keyword">if</span> (i &gt; INT_MIN)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d &gt;INT_MIN\n"</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(TMIN));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为</p>
<blockquote>
<p>1 &lt; tmin<br>1 &gt;INT_MIN<br>4</p>
</blockquote>
<p>补充：</p>
<p>CSAPP的补充材料<a href="http://csapp.cs.cmu.edu/public/waside/waside-tmin.pdf" target="_blank" rel="external">waside-tmin.pdf</a></p>
<p>上面的例子说明了不同格式字面值在C90和C99下面的类型确定的规则，C90 32位下类型为unsigned，就会产生上面程序的结果。</p>
<p>对于这种会产生不同行为的代码最好避免.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Notes About Kafka]]></title>
      <url>http://rivenzoo.github.io/2014/09/21/notes-about-kafka/</url>
      <content type="html"><![CDATA[<h5 id="consumer-offset-commit"><a href="#consumer-offset-commit" class="headerlink" title="consumer offset commit"></a>consumer offset commit</h5><p>使用kafka的python api时遇到了offset回滚的问题，因为最初使用了autocommit参数，发现有时会重复取记录，发现autocommit是批量提交，并且有offset回滚的问题，具体原因未发现，解决方法是手动调用commit函数提交，经过测试手动调用没有出现offset回滚的问题。</p>
<h5 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h5><p>一开始为了简单只使用了一个分区，consumer都从一个leader取数据，请求压力都在一台机器。使用不同分区策略可以分散topic的leader，还可以灵活处理不同数据。</p>
<h5 id="fetch-msg"><a href="#fetch-msg" class="headerlink" title="fetch msg"></a>fetch msg</h5><p>MaxWaitTime 请求最大等待时间，MinBytes 请求消息的最小字节数，通过这2个参数可以调整你获取数据时的等待策略，最简单的做法就是不等待，没数据直接返回。</p>
<h5 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h5><p>由于硬盘限制，把kafka和zookeeper的日志目录放在了同一个磁盘，而且磁盘的性能不是很好，造成了kafka写数据效率低下，每次写数据只有几百k。zookeeper网站上对这2个配置有Notes说不要把他们放在繁忙的磁盘设备上，会影响其他程序写磁盘的性能，最好这2个目录都分开存放不同设备。简单看了一下，dataDir下存的是snapshot文件，dataLogDir存的是log文件，应该是zookeeper把内存数据持久化到这2种文件中了，而且持久化操作很频繁且写的数据很少，会影响kafka写日志。</p>
<h5 id="磁盘参数"><a href="#磁盘参数" class="headerlink" title="磁盘参数"></a>磁盘参数</h5><p>在排查磁盘io高的问题时用到了<code>iostat -d -x</code>命令，在排查时主要关注w/s、wkB/s、rkB/s，对于扇区没怎么关注，rsec/s wsec/s avgrq-sz这几个参数反应磁盘操作扇区的情况，当磁盘利用率高且iowait高，而平均扇区低也就意味着磁盘把大量时间用于磁盘寻道，你可能需要考虑是不是有大量随机写磁盘的操作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重入与线程安全]]></title>
      <url>http://rivenzoo.github.io/2013/11/22/about-thread-safe/</url>
      <content type="html"><![CDATA[<p>在stackoverflow上看的的关于可重入与线程安全的区别：</p>
<blockquote>
<p>These functions are not reentrant. They are thread-safe. There’s a big difference. Functions that are reentrant are automatically thread-safe, but thread-safe functions can still deadlock (or worse) if called again from the same thread they’re already running in (for example from a signal handler).</p>
</blockquote>
<p>函数可重入很自然会觉得该函数是线程安全的，既然能被其他流程中断并可调用自身也就可以被多个线程同时调用。但是线程安全是不是可重入有点模糊，上面说了一种情况，当重复调用一个线程安全的函数，并且函数中有锁就有可能发生死锁，表明线程安全不一定可重入。看来重入的要求比线程安全要更严格一点。</p>
<p>附带查了查关于Posix的标准io操作，Posix标准要求操作字符流的函数实现为可重入，但是各个实现为了性能方面的考虑都没有实现为可重入的，这些函数有潜在不安全。但是又说明：</p>
<blockquote>
<p>all standard I/O functions that reference character streams shall behave as if they use flockfile() and funlockfile() internally to obtain ownership of the character streams</p>
</blockquote>
<p>表明它们应该是线程安全的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自定义linux信号]]></title>
      <url>http://rivenzoo.github.io/2013/11/05/define-linux-signal/</url>
      <content type="html"><![CDATA[<p>有时候我们需要在程序中利用信号来控制程序行为，linux为我们提供了2个已经定义的信号SIGUSR1和SIGUSR2，一般的程序利用这2个信号已经能满足需要，不过我最近需要一些其他信号来避免覆盖原来的信号处理函数。 </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSIG_MSG        (SIGUSR2 + 1)</span></span><br><span class="line"><span class="comment">// 定义信号然后注册处理函数</span></span><br></pre></td></tr></table></figure>
<p>然后到系统里查了一下，MYSIG_MSG其实将其他的信号给覆盖了<br><code>$kill -l</code></p>
<blockquote>
<p>10) SIGUSR1    11) SIGSEGV    12) SIGUSR2 13) SIGPIPE    14) SIGALRM </p>
</blockquote>
<p>虽然SIGPIPE和SIGALRM在这个程序中没有用到，但是这并不是我想要的效果。<br>我发现在后面有 </p>
<blockquote>
<p>34) SIGRTMIN 35) SIGRTMIN+1    36) SIGRTMIN+2 </p>
</blockquote>
<p><code>man 7 signal</code>页面同样也说明可以用 SIGRTMIN作为自定义信号。然后程序里就多了下面的代码： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSIG_MSG        (SIGRTMIN+ 1)</span></span><br></pre></td></tr></table></figure>
<p>结果出错了，但是并不是这个定义方式的问题。在我程序中有下面的代码： </p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(signo)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attribute">MYSIG_MSG</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span><br><span class="line">编译时才发现原来SIGRTMIN并不是一个常量，看了头文件里才知道：</span></span><br></pre></td></tr></table></figure>
<p>// centos5.9 /usr/include/bits/signum.h</p>
<p>#define SIGRTMIN        (__libc_current_sigrtmin ())<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">原来是函数调用，运行时确定的。 </span><br><span class="line">要用这个SIGRTMIN宏是不行，只能自己定义了：</span><br></pre></td></tr></table></figure></p>
<p>#define MYSIGRTMIN    34</p>
<p>#define MYSIG_MSG     (MYSIGRTMIN + 1)<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在找到系统定义的SIGRTMIN值之前，根据man <span class="number">7</span> <span class="keyword">signal</span><span class="string">里面的说明：</span></span><br><span class="line">&gt; Linux supports <span class="number">32</span> <span class="built_in">real</span>-time signals, numbered from <span class="number">32</span> (SIGRTMIN) to <span class="number">63</span> (SIGRTMAX). </span><br><span class="line">我把自定义的信号值定义成了<span class="number">32</span>，但是一直注册不了这个信号，后来赫然发现在 <span class="string">`man 7 signal`</span>下面有一行说明， </span><br><span class="line">&gt; However, the glibc POSIX threads implementation internally uses two (<span class="keyword">for</span> NPTL) or three  (<span class="keyword">for</span>  LinuxThreads)  <span class="built_in">real</span>-time signals  (see  pthreads(<span class="number">7</span>)), and adjusts the value <span class="keyword">of</span> SIGRTMIN suitably (to <span class="number">34</span> or <span class="number">35</span>) </span><br><span class="line"></span><br><span class="line">这个说明在ubuntu12<span class="number">.04</span>里面看见的，估计centos也有类似的情况。同时头文件下面也有：</span><br></pre></td></tr></table></figure></p>
<p>/<em> These are the hard limits of the kernel.  These values should not be<br>used directly at user level.  </em>/</p>
<p>#define __SIGRTMIN  32</p>
<p>#define __SIGRTMAX  (_NSIG - 1)<br>```<br>改成34之后就没有问题了。不过这个方法不太可靠，程序不应该直接用常量标识信号. </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://rivenzoo.github.io/2013/09/01/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
