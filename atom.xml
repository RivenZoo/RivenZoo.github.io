<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Riven的博客</title>
  
  <subtitle>Look Inside Deeply</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rivenzoo.github.io/"/>
  <updated>2020-03-28T12:37:23.897Z</updated>
  <id>http://rivenzoo.github.io/</id>
  
  <author>
    <name>RivenZoo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go-code-style-guide</title>
    <link href="http://rivenzoo.github.io/2020/03/28/go-code-style-guide/"/>
    <id>http://rivenzoo.github.io/2020/03/28/go-code-style-guide/</id>
    <published>2020-03-28T09:18:47.000Z</published>
    <updated>2020-03-28T12:37:23.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-Code-Style-Guide"><a href="#Go-Code-Style-Guide" class="headerlink" title="Go Code Style Guide"></a>Go Code Style Guide</h1><p>linter工具的警告必须检查，大部分警告都需要进行修复</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>当命名包时，请遵守下面规则：</p><ul><li>全部小写。没有大写或下划线。</li><li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li><li>不建议使用“common”，“util”，“shared”或“lib”。这些是信息量不足的名称。</li></ul><p>BAD</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kv_log</span><br><span class="line">rateLimit</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kvlog</span></span><br><span class="line"><span class="attribute">ratelimit</span></span><br></pre></td></tr></table></figure><h3 id="函数、变量名"><a href="#函数、变量名" class="headerlink" title="函数、变量名"></a>函数、变量名</h3><p>遵循 Go 社区关于使用 MixedCaps 作为函数名 的约定。使用单词首字母大小写命名，作用域越大的名称越详细，名字不包含下划线。<br>有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：TestMyFunction_WhatIsBeingTested.<br>函数名字使用动词加名词的形式，避免使用<code>v1/v2</code>这类后缀.</p><p>BAD</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global_variable <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">const</span> MAX_SIZE = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVariable <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">const</span> MaxSize = <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="时间相关变量命名带上单位。"><a href="#时间相关变量命名带上单位。" class="headerlink" title="时间相关变量命名带上单位。"></a>时间相关变量命名带上单位。</h3><p>BAD</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expireTime <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expireMilliSeconds <span class="keyword">int</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="接收者命名"><a href="#接收者命名" class="headerlink" title="接收者命名"></a>接收者命名</h3><p>使用一致的名字.<br>不推荐this、self，原因是跟开源社区习惯不一致。<br>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f foo)</span> <span class="title">A</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pf *foo)</span> <span class="title">B</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// 这类的pf跟前面使用的f不一致</span></span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f foo)</span> <span class="title">A</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">B</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="函数和接口定义"><a href="#函数和接口定义" class="headerlink" title="函数和接口定义"></a>函数和接口定义</h2><h3 id="函数长度"><a href="#函数长度" class="headerlink" title="函数长度"></a>函数长度</h3><p>不超过100行。</p><h3 id="函数复杂度"><a href="#函数复杂度" class="headerlink" title="函数复杂度"></a>函数复杂度</h3><p>圈复杂度小于12（易于测试）<br>认知复杂度小于15（便于理解）</p><h3 id="参数和返回值个数"><a href="#参数和返回值个数" class="headerlink" title="参数和返回值个数"></a>参数和返回值个数</h3><p>参数少于5个，返回值少于3个.<br>过多的参数请根据它们的用途归类到参数对象传递.</p><h3 id="context参数"><a href="#context参数" class="headerlink" title="context参数"></a>context参数</h3><p>必须作为函数第一个参数出现<br>禁止业务代码通过context传递参数，以明确的参数代替。<br>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    isOldUser, ok := ctx.Value(<span class="string">"is_old_user"</span>).(boo) <span class="comment">// ctx禁止传递业务参数</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isOldUser &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(ctx context.Context, isOldUser <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> isOldUser &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="枚举从1开始"><a href="#枚举从1开始" class="headerlink" title="枚举从1开始"></a>枚举从1开始</h3><p>0是Go语言的默认值，通常只有在它能代表一定意义才会使用，否则应该避免0值。<br>BAD</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">type</span> Operation int</span><br><span class="line"><span class="symbol">const</span> (</span><br><span class="line">  <span class="keyword">Add </span>Operation = iota</span><br><span class="line">  <span class="keyword">Subtract</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">Multiply</span></span><br><span class="line"><span class="keyword">)</span></span><br><span class="line"><span class="keyword">// </span><span class="keyword">Add=0, </span><span class="keyword">Subtract=1, </span><span class="keyword">Multiply=2</span></span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">type</span> Operation int</span><br><span class="line"><span class="symbol">const</span> (</span><br><span class="line">  <span class="keyword">Add </span>Operation = iota + <span class="number">1</span></span><br><span class="line">  <span class="keyword">Subtract</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">Multiply</span></span><br><span class="line"><span class="keyword">)</span></span><br><span class="line"><span class="keyword">// </span><span class="keyword">Add=1, </span><span class="keyword">Subtract=2, </span><span class="keyword">Multiply=3</span></span><br></pre></td></tr></table></figure><h3 id="使用字段名初始化结构体"><a href="#使用字段名初始化结构体" class="headerlink" title="使用字段名初始化结构体"></a>使用字段名初始化结构体</h3><p>初始化结构体时，应该指定字段名称。<br>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;<span class="string">"John"</span>, <span class="string">"Doe"</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line"><span class="symbol">    FirstName:</span> <span class="string">"John"</span>,</span><br><span class="line"><span class="symbol">    LastName:</span> <span class="string">"Doe"</span>,</span><br><span class="line"><span class="symbol">    Admin:</span> true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用常量代替魔法数字"><a href="#用常量代替魔法数字" class="headerlink" title="用常量代替魔法数字"></a>用常量代替魔法数字</h3><p>对于有意义的魔法数字，必须用常量代替</p><p>BAD</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch processState &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch processState &#123;</span><br><span class="line">case <span class="keyword">state</span>Successfully:</span><br><span class="line">...</span><br><span class="line">case <span class="keyword">state</span>ExitWithError:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-defer-释放资"><a href="#使用-defer-释放资" class="headerlink" title="使用 defer 释放资"></a>使用 defer 释放资</h3><p>使用 defer 释放资源，诸如文件和锁。</p><p>BAD</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>.Lock()</span><br><span class="line"><span class="keyword">if</span> <span class="selector-tag">p</span><span class="selector-class">.count</span> &lt; <span class="number">10</span> &#123;</span><br><span class="line">  <span class="selector-tag">p</span>.Unlock()</span><br><span class="line">  return <span class="selector-tag">p</span>.count</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>.count++</span><br><span class="line">newCount := <span class="selector-tag">p</span>.count</span><br><span class="line"><span class="selector-tag">p</span>.Unlock()</span><br><span class="line">return newCount</span><br><span class="line"><span class="comment">// 当有多个 return 分支时，很容易遗忘 unlock</span></span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>.Lock()</span><br><span class="line">defer <span class="selector-tag">p</span>.Unlock()</span><br><span class="line"><span class="keyword">if</span> <span class="selector-tag">p</span><span class="selector-class">.count</span> &lt; <span class="number">10</span> &#123;</span><br><span class="line">  return <span class="selector-tag">p</span>.count</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>.count++</span><br><span class="line">return <span class="selector-tag">p</span>.count</span><br><span class="line"><span class="comment">// 更可读</span></span><br></pre></td></tr></table></figure><h3 id="返回错误"><a href="#返回错误" class="headerlink" title="返回错误"></a>返回错误</h3><p>错误类型必须是error接口<br>如果调用者需要检测某种特定错误，必须返回一个特定哨兵错误。<br>如果自定义错误类型，最好提供检查错误的方法。</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">"could not open"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err.Error() == <span class="string">"could not open"</span> &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err == foo.ErrCouldNotOpen &#123; <span class="comment">// 哨兵错误值</span></span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotFoundError</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  _, ok := err.(errNotFound)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(<span class="string">"testfile.txt"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := IsNotFoundError(err); ok &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理函数返回的error"><a href="#处理函数返回的error" class="headerlink" title="处理函数返回的error"></a>处理函数返回的error</h3><p>最好处理所有error。<br>对于那些不关心的error使用下划线占位符。</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> errors.New(<span class="string">"error"</span>) &#125;</span><br><span class="line">foo() <span class="comment">// 未处理的错误</span></span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> errors.New(<span class="string">"error"</span>) &#125;</span><br><span class="line"><span class="keyword">if</span> err := foo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理类型断言失败"><a href="#处理类型断言失败" class="headerlink" title="处理类型断言失败"></a>处理类型断言失败</h3><p>使用”comma ok”的语句形式</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="comment">// 优雅地处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理panic"><a href="#处理panic" class="headerlink" title="处理panic"></a>处理panic</h3><p>对于可以预料的错误不应该产生panic，应该返回错误由调用者处理，必要时加上监控或上报sentry。</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">raiseError</span><span class="params">(e <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errors.New(<span class="string">"error occur"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">raiseError</span><span class="params">(e <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"error occur"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管理goruntine"><a href="#管理goruntine" class="headerlink" title="管理goruntine"></a>管理goruntine</h3><p>goruntine需要在入口处recover住panic并处理panic。<br>goruntine要有明确的生命周期管理，如果有长时间运行的goruntine，需要通过context传递结束信号。</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mayPanic</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rand.Int()%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(errors.New(<span class="string">"surprise"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mayPanic()</span><br><span class="line">&#125; ()</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">mayPanic()</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片 Slice"></a>切片 Slice</h3><ul><li><p>取元素之前需要确保索引不超过有效长度。</p></li><li><p>要检查切片是否为空，请始终使用len(s) == 0。而非 nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>不应明确返回长度为零的切片。应该返回nil来代替</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>零值切片（用var声明的切片）可立即使用，无需调用make()创建。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="在边界处拷贝-Slices-和-Maps"><a href="#在边界处拷贝-Slices-和-Maps" class="headerlink" title="在边界处拷贝 Slices 和 Maps"></a>在边界处拷贝 Slices 和 Maps</h3><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。<br>接收 Slices 和 Maps<br>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = trips</span><br><span class="line">&#125;</span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"><span class="comment">// 你是要修改 d1.trips 吗？</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))</span><br><span class="line">  <span class="built_in">copy</span>(d.trips, trips)</span><br><span class="line">&#125;</span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"><span class="comment">// 这里我们修改 trips[0]，但不会影响到 d1.trips</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br><span class="line">返回 slices 或 maps</span><br><span class="line">同样，请注意用户对暴露内部状态的 <span class="keyword">map</span> 或 slice 的修改。</span><br></pre></td></tr></table></figure><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Snapshot 返回当前状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> s.counters</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// snapshot 不再受互斥锁保护</span></span><br><span class="line"><span class="comment">// 因此对 snapshot 的任何访问都将受到数据竞争的影响</span></span><br><span class="line"><span class="comment">// 影响 stats.counters</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">  result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(s.counters))</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;</span><br><span class="line">    result[k] = v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// snapshot 现在是一个拷贝</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure><h3 id="减少嵌套"><a href="#减少嵌套" class="headerlink" title="减少嵌套"></a>减少嵌套</h3><p>代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。<br>嵌套层级最好不要超过3层。</p><p>BAD</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123; <span class="comment">// 第一层</span></span><br><span class="line">  <span class="keyword">if</span> v.F1 == 1 &#123; <span class="comment">// 第二层</span></span><br><span class="line">    v = process(v)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> := v.Call(); <span class="keyword">err</span> == nil &#123; <span class="comment">// 第三层</span></span><br><span class="line">      v.Send()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">log</span>.Printf(<span class="string">"quot;Invalid v: %v"</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 != 1 &#123;</span><br><span class="line">    <span class="keyword">log</span>.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  v = process(v)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">err</span> := v.Call(); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">  &#125;</span><br><span class="line">  v.Send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免在闭包中引用循环变量"><a href="#避免在闭包中引用循环变量" class="headerlink" title="避免在闭包中引用循环变量"></a>避免在闭包中引用循环变量</h3><p>在闭包中引用循环变量经常会导致非预期的结果，产生bug。</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">GOOD</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;(s) <span class="comment">// 传值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> option <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">    opt *option</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newConfig</span><span class="params">(opt *option)</span> *<span class="title">config</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;config&#123;opt: opt&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> []option&#123;option&#123;A:<span class="number">10</span>&#125;, option&#123;A:<span class="number">20</span>&#125;&#125; &#123;</span><br><span class="line">   v := opt <span class="comment">// 拷贝一次</span></span><br><span class="line">   newConfig(&amp;v) <span class="comment">// 把临时变量指针保存以后使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不必要的-else"><a href="#不必要的-else" class="headerlink" title="不必要的 else"></a>不必要的 else</h3><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p><p>BAD</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> int</span><br><span class="line"><span class="keyword">if</span> <span class="selector-tag">b</span> &#123;</span><br><span class="line">  <span class="selector-tag">a</span> = <span class="number">100</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="selector-tag">a</span> = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> <span class="selector-tag">b</span> &#123;</span><br><span class="line">  <span class="selector-tag">a</span> = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外部调用"><a href="#外部调用" class="headerlink" title="外部调用"></a>外部调用</h2><h3 id="设置超时"><a href="#设置超时" class="headerlink" title="设置超时"></a>设置超时</h3><p>调用外部系统例如HTTP服务、数据库等必须设置一个超时时间</p><p>BAD</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.<span class="builtin-name">Get</span>(url)</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">   <span class="attribute">Timeout</span>: time<span class="variable">.Millisecond</span> * time<span class="variable">.Duration</span>(conf<span class="variable">.TimeoutMS</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免数据库事务被用户取消"><a href="#避免数据库事务被用户取消" class="headerlink" title="避免数据库事务被用户取消"></a>避免数据库事务被用户取消</h3><p>在事务中谨慎使用从用户请求传递过来的context，因为可能会随着用户请求取消而产生非预期的行为</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestHandle</span><span class="params">(ctx context.Context, param <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    db.Txx(ctx, param() <span class="comment">// 直接调用会因为用户取消而导致事务失败，如果这个行为不是你想要的，那么很可能会导致问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestHandle</span><span class="params">(ctx context.Context, param <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    txCtx, cancel := context.WithTimeout(context.Background(), <span class="number">100</span>*time.Millisecond)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    db.Txx(txCtx, param() <span class="comment">// 重新设定超时时间，用户取消也会在超时时间内执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免散播存储层的错误"><a href="#避免散播存储层的错误" class="headerlink" title="避免散播存储层的错误"></a>避免散播存储层的错误</h3><p>避免调用者检查数据库返回的错误，需要把关注的错误码转换成其他形式返回给调用者</p><p>BAD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getValueFromRedis</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(val *<span class="keyword">struct</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, redis.Nil</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v, err := getValueFromRedis(<span class="string">""</span>)</span><br><span class="line">    <span class="comment">// 在下层处理redis.Nil，返回(nil,nil)或者自定义错误(nil, ErrKeyNotExists)</span></span><br><span class="line">    <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GOOD</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getValueFromRedis</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(val *<span class="keyword">struct</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v, err := getValueFromRedis(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否为空指针</span></span><br><span class="line">    <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件布局"><a href="#文件布局" class="headerlink" title="文件布局"></a>文件布局</h2><p>从上到下依次为:</p><ul><li>常量定义</li><li>变量定义</li><li>类型定义</li><li>类型构造函数</li><li>类型方法 </li><li>(多个类型)…</li><li>全局函数</li></ul><p>函数根据调用顺序，被调用函数放在调用者之后<br>类型定义和类型构造函数、类型方法定义不能分散到多个文件里面</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="使用表驱动测试"><a href="#使用表驱动测试" class="headerlink" title="使用表驱动测试"></a>使用表驱动测试</h3><p>使用表驱动搭配断言来编写测试用例</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Go-Code-Style-Guide&quot;&gt;&lt;a href=&quot;#Go-Code-Style-Guide&quot; class=&quot;headerlink&quot; title=&quot;Go Code Style Guide&quot;&gt;&lt;/a&gt;Go Code Style Guide&lt;/h1&gt;&lt;p&gt;linter工具的警告必须检查，大部分警告都需要进行修复&lt;/p&gt;
&lt;h2 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命名&lt;/h2&gt;&lt;h3 id=&quot;包名&quot;&gt;&lt;a href=&quot;#包名&quot; class=&quot;headerlink&quot; title=&quot;包名&quot;&gt;&lt;/a&gt;包名&lt;/h3&gt;&lt;p&gt;当命名包时，请遵守下面规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全部小写。没有大写或下划线。&lt;/li&gt;
&lt;li&gt;简短而简洁。请记住，在每个使用的地方都完整标识了该名称。&lt;/li&gt;
&lt;li&gt;不建议使用“common”，“util”，“shared”或“lib”。这些是信息量不足的名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BAD&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;kv_log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rateLimit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;GOOD&lt;/p&gt;
&lt;figure class=&quot;highlight ebnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;kvlog&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;ratelimit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;函数、变量名&quot;&gt;&lt;a href=&quot;#函数、变量名&quot; class=&quot;headerlink&quot; title=&quot;函数、变量名&quot;&gt;&lt;/a&gt;函数、变量名&lt;/h3&gt;&lt;p&gt;遵循 Go 社区关于使用 MixedCaps 作为函数名 的约定。使用单词首字母大小写命名，作用域越大的名称越详细，名字不包含下划线。&lt;br&gt;有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：TestMyFunction_WhatIsBeingTested.&lt;br&gt;函数名字使用动词加名词的形式，避免使用&lt;code&gt;v1/v2&lt;/code&gt;这类后缀.&lt;/p&gt;
&lt;p&gt;BAD&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; global_variable &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; MAX_SIZE = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;GOOD&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; globalVariable &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; MaxSize = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;时间相关变量命名带上单位。&quot;&gt;&lt;a href=&quot;#时间相关变量命名带上单位。&quot; class=&quot;headerlink&quot; title=&quot;时间相关变量命名带上单位。&quot;&gt;&lt;/a&gt;时间相关变量命名带上单位。&lt;/h3&gt;&lt;p&gt;BAD&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; expireTime &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;GOOD&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; expireMilliSeconds &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Go" scheme="http://rivenzoo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>LVS notes</title>
    <link href="http://rivenzoo.github.io/2019/04/06/LVS-notes/"/>
    <id>http://rivenzoo.github.io/2019/04/06/LVS-notes/</id>
    <published>2019-04-06T08:06:35.000Z</published>
    <updated>2019-04-06T08:20:09.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LVS-Linux-Virtual-Server"><a href="#LVS-Linux-Virtual-Server" class="headerlink" title="LVS (Linux Virtual Server)"></a>LVS (Linux Virtual Server)</h3><p>它是一种集群(Cluster)技术，采用IP负载均衡技术</p><p><img src="/images/15545381191583.jpg" alt=""></p><h4 id="主要组成部分"><a href="#主要组成部分" class="headerlink" title="主要组成部分"></a>主要组成部分</h4><p>负载调度器(load balancer/ Director)<br>服务器池(server pool/ Realserver)<br>共享存储(shared storage)</p><h4 id="负载均衡方式"><a href="#负载均衡方式" class="headerlink" title="负载均衡方式"></a>负载均衡方式</h4><ul><li><p>Virtual Server via Network Address Translation NAT(VS/NAT) </p><p>  NAT修改请求的目的VIP和端口为选出来的后端服务器的IP和端口，发送给真实处理的服务器<br>  服务器处理完成，通过设置默认网关为VIP，返回结果给调度器<br>  调度器修改结果的源IP和端口为VIP和端口，然后返回给客户端<br>  in/out的流量都要经过调度器<br>  当集群规模变大，调度器可能成为瓶颈</p></li><li><p>Virtual Server via IP Tunneling(VS/TUN)</p><p>  调度器对请求的IP报文进行封装，外层为真实服务器IP<br>  真实服务器收到包后进行解封，获得目的地址为VIP的包，通过设置隧道设备为VIP让内核处理这个包<br>  处理完直接返回给客户端，因为目的地址是VIP，返回的源地址也是VIP<br>  调度器转发的端口和后端服务器的端口需要一致，调度器需要维护连接状态<br>  <img src="/images/15545381400249.jpg" alt=""></p><p>  建立tunnel对IP报文封包转发，返回报文直接发送给用户<br>  需要内核支持IP-tunnel协议，性能较高</p></li><li><p>Virtual Server via Direct Routing(VS/DR)</p><p>  <img src="/images/15545381565629.jpg" alt=""></p></li></ul><pre><code>修改报文Mac地址路由给real-server，真实服务器配置一个非ARP设备的IP为VIP来接收并处理请求返回报文直接发送给用户调度器转发的端口和后端服务器的端口需要一致，调度器需要维护连接状态需要real-server有一块网卡和调度器连接在同一网段，性能高</code></pre><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><table><thead><tr><th>_</th><th>VS/NAT</th><th>VS/TUN</th><th>VS/DR</th></tr></thead><tbody><tr><td>Server</td><td>any</td><td>Tunneling</td><td>Non-arp device</td></tr><tr><td>server network</td><td>private</td><td>LAN/WAN</td><td>LAN</td></tr><tr><td>server number</td><td>low (10~20)</td><td>High (100)</td><td>High (100)</td></tr><tr><td>server gateway</td><td>load balancer</td><td>own router</td><td>Own router</td></tr></tbody></table><h4 id="负载均衡调度算法"><a href="#负载均衡调度算法" class="headerlink" title="负载均衡调度算法"></a>负载均衡调度算法</h4><ul><li>最少的连接方式(Least Connection)</li><li>最快模式(Fastest)</li><li>观察模式(Observed)</li><li>预测模式(Predictive)</li><li>动态性能分配(Dynamic Ratio-APM)</li><li>动态服务器补充(Dynamic Server Act.)</li><li>服务质量(QoS)</li><li>服务类型(ToS)</li><li>规则模式</li></ul><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>主备模式<br>ARP欺骗切换IP<br>多线路存活探测<br>高效状态同步</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.linuxvirtualserver.org/zh/lvs3.html" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/zh/lvs3.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LVS-Linux-Virtual-Server&quot;&gt;&lt;a href=&quot;#LVS-Linux-Virtual-Server&quot; class=&quot;headerlink&quot; title=&quot;LVS (Linux Virtual Server)&quot;&gt;&lt;/a&gt;LVS (Linux V
      
    
    </summary>
    
      <category term="Linux" scheme="http://rivenzoo.github.io/categories/Linux/"/>
    
      <category term="Network" scheme="http://rivenzoo.github.io/categories/Linux/Network/"/>
    
    
      <category term="LVS" scheme="http://rivenzoo.github.io/tags/LVS/"/>
    
  </entry>
  
  <entry>
    <title>Golang Channel小结</title>
    <link href="http://rivenzoo.github.io/2018/10/17/Golang-Channel%E5%B0%8F%E7%BB%93/"/>
    <id>http://rivenzoo.github.io/2018/10/17/Golang-Channel小结/</id>
    <published>2018-10-16T16:20:16.000Z</published>
    <updated>2018-10-16T16:21:03.855Z</updated>
    
    <content type="html"><![CDATA[<h4 id="确保接收"><a href="#确保接收" class="headerlink" title="确保接收"></a>确保接收</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">01 </span>go func() &#123;</span><br><span class="line"><span class="symbol">02 </span>    p := &lt;-ch // Receive</span><br><span class="line"><span class="symbol">03 </span>&#125;()</span><br><span class="line"><span class="number">04</span></span><br><span class="line"><span class="symbol">05 </span>ch &lt;- <span class="string">"paper"</span> // Send</span><br></pre></td></tr></table></figure><p>以上代码，当05行发送之后，不同的channel接收者的行为不同。</p><p>channel类型：</p><ul><li><p>Buffered</p><p>  确保接收之后发送的代码才继续执行</p></li><li><p>Unbuffered</p><p>  发送代码继续执行，不确保此时被接收</p></li></ul><h4 id="状态和行为"><a href="#状态和行为" class="headerlink" title="状态和行为"></a>状态和行为</h4><p>状态：</p><ul><li>nil</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ** nil channel</span><br><span class="line">// A channel is <span class="keyword">in</span> a nil <span class="keyword">state</span> when it is declared <span class="keyword">to</span> its zero value</span><br><span class="line">var ch chan string</span><br><span class="line"></span><br><span class="line">// A channel can be placed <span class="keyword">in</span> a nil <span class="keyword">state</span> by explicitly setting it <span class="keyword">to</span> nil.</span><br><span class="line">ch = nil</span><br></pre></td></tr></table></figure><ul><li>open </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ** open channel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A channel is in a open state when it’s made using the built-in function make.</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure><ul><li>closed</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">// ** closed channel</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> A channel <span class="keyword">is</span> <span class="keyword">in</span> a closed state <span class="keyword">when</span> <span class="literal">it</span>’s closed using the built-<span class="keyword">in</span> <span class="keyword">function</span> close.</span><br><span class="line">close(ch)</span><br></pre></td></tr></table></figure><p>行为：</p><table><thead><tr><th>操作\状态</th><th>Nil</th><th>Open</th><th>Closed</th></tr></thead><tbody><tr><td>Send</td><td>Blocked</td><td>Allowed</td><td>Panic</td></tr><tr><td>Receive</td><td>Blocked</td><td>Allowed</td><td>Allowed</td></tr><tr><td>Close</td><td>Panic</td><td>Allowed</td><td>Panic</td></tr></tbody></table><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;确保接收&quot;&gt;&lt;a href=&quot;#确保接收&quot; class=&quot;headerlink&quot; title=&quot;确保接收&quot;&gt;&lt;/a&gt;确保接收&lt;/h4&gt;&lt;figure class=&quot;highlight basic&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="编程语言" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Go" scheme="http://rivenzoo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>shell基础语法</title>
    <link href="http://rivenzoo.github.io/2018/09/02/shell%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://rivenzoo.github.io/2018/09/02/shell基础语法/</id>
    <published>2018-09-01T16:54:35.000Z</published>
    <updated>2018-09-01T18:53:00.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="shell基础语法"><a href="#shell基础语法" class="headerlink" title="shell基础语法"></a>shell基础语法</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ expression ][</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> test expression; <span class="keyword">then</span></span><br><span class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ expression <span class="number">1</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="number">1</span> <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line">elif [[ expression <span class="number">2</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="number">2</span> <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line">elif [[ expression <span class="number">3</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="number">3</span> <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> <span class="literal">no</span> expression <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SERVICES=<span class="string">"80   22   25   110   8000   23   20   21   3306   "</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="variable">$SERVICES</span>; do</span><br><span class="line">  iptables -A INPUT -p tcp --dport <span class="variable">$x</span> -m <span class="keyword">state</span> --state NEW -j ACCEPT</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以下是Bash的用法，与zsh的不同</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a=(1 2 3 4 5)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$a</span></span></span><br><span class="line">1</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;#a[@]&#125;</span> <span class="comment"># 用$&#123;#数组名[@或*]&#125; 可以得到数组长度</span></span></span><br><span class="line">5</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;a[*]&#125;</span> <span class="comment"># 用$&#123;数组名[下标]&#125; 下标是从0开始  下标是：*或者@ 得到整个数组内容</span></span></span><br><span class="line">1 2 3 4 5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接通过 数组名[下标] 就可以对其进行引用赋值，如果下标不存在，自动添加新一个数组元素到数组末尾</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a[1]=100 &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;a[1]&#125;</span></span></span><br><span class="line">100</span><br><span class="line"><span class="meta">#</span><span class="bash"> a[10]=100 &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;a[*]&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;a[10]&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;#a[*]&#125;</span></span></span><br><span class="line">1 2 3 4 5 100</span><br><span class="line">100</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接通过：<span class="built_in">unset</span> 数组[下标] 可以清除相应的元素，不带下标，清除整个数据。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">unset</span> a[1] &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;#a[*]&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;a[1]&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;a[*]&#125;</span></span></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">1 3 4 5 100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接通过 <span class="variable">$&#123;数组名[@或*]:起始位置:长度&#125;</span> 切片原先数组，返回是字符串，中间用“空格”分开，因此如果加上”()”，将得到切片数组，上面例子：c 就是一个新数据。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a=(1 2 3 4 5) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;a[@]:0:3&#125;</span></span></span><br><span class="line">1 2 3</span><br><span class="line"><span class="meta">#</span><span class="bash"> c=(<span class="variable">$&#123;a[@]:1:4&#125;</span>) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;#c[@]&#125;</span></span></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换元素调用方法是：<span class="variable">$&#123;数组名[@或*]/查找字符/替换字符&#125;</span> 该操作不会改变原先数组内容，如果需要修改，可以看上面例子，重新定义数据。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a=(1 2 3 4 5) &amp;&amp; c=(<span class="variable">$&#123;a[@]/3/100&#125;</span>) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;c[@]&#125;</span></span></span><br><span class="line">1 2 100 4 5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断元素是否在数组中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> [[ <span class="variable">$&#123;array[@]&#125;</span> =~ <span class="variable">$item</span> ]]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">'yes'</span>; <span class="keyword">fi</span></span></span><br></pre></td></tr></table></figure><h4 id="命令行解析"><a href="#命令行解析" class="headerlink" title="命令行解析"></a>命令行解析</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># use <span class="keyword">break</span> to jump <span class="keyword">out</span> <span class="keyword">for</span> loop</span><br><span class="line"><span class="keyword">for</span> opt <span class="keyword">in</span> $@; <span class="keyword">do</span></span><br><span class="line">case $opt <span class="keyword">in</span></span><br><span class="line"><span class="keyword">init</span>) project_init</span><br><span class="line"><span class="keyword">break</span>;;</span><br><span class="line">start) start_train</span><br><span class="line"><span class="keyword">break</span>;;</span><br><span class="line">stop) stop_train</span><br><span class="line"><span class="keyword">break</span>;;</span><br><span class="line">resume) resume_train</span><br><span class="line"><span class="keyword">break</span>;;</span><br><span class="line">*) show_usage</span><br><span class="line"><span class="keyword">break</span>;;</span><br><span class="line">esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><ul><li><p>通过子命令的方式</p><p>  函数内部任何标准输出都会返回给接收变量，结果容易受到输出日志的干扰</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">a=$(foo)</span><br><span class="line"><span class="keyword">echo</span> $a <span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure></li><li><p>通过return返回整数值，<code>$?</code>获取</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">foo <span class="comment"># 1 2</span></span><br><span class="line"><span class="keyword">echo</span> $? <span class="comment"># 0</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><ul><li>截取字符串</li></ul><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>$&#123;#string}</td><td>$string的长度</td></tr><tr><td><code>${string:position}</code></td><td>在$string中, 从位置$position开始提取子串</td></tr><tr><td><code>${string:position:length}</code></td><td>在$string中, 从位置$position开始提取长度为$length的子串</td></tr><tr><td><code>${string#substring}</code></td><td>从变量$string的开头, 删除最短匹配$substring的子串</td></tr><tr><td><code>${string##substring}</code></td><td>从变量$string的开头, 删除最长匹配$substring的子串</td></tr><tr><td><code>${string%substring}</code></td><td>从变量$string的结尾, 删除最短匹配$substring的子串</td></tr><tr><td><code>${string%%substring}</code></td><td>从变量$string的结尾, 删除最长匹配$substring的子串</td></tr><tr><td><code>${string/substring/replacement}</code></td><td>使用$replacement, 来代替第一个匹配的$substring</td></tr><tr><td><code>${string//substring/replacement}</code></td><td>使用$replacement, 代替所有匹配的$substring</td></tr><tr><td><code>${string/#substring/replacement}</code></td><td>如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</td></tr><tr><td><code>${string/%substring/replacement}</code></td><td>如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</td></tr></tbody></table><ul><li><p>示例:</p><pre><code>${str:0:-1} 去掉最后一个字符${str:0: ${#str}} 返回整个字符串。避免写成$#str，$#有特殊含义，是传给函数或脚本的参数个数``` </code></pre></li><li><p>定义字符串</p></li></ul><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>${var}</code></td><td>变量var的值, 与$var相同</td></tr><tr><td><code>${var-DEFAULT}</code></td><td>如果var没有被声明, 那么就以$DEFAULT作为其值，但是不会改变变量的值 *</td></tr><tr><td><code>${var:-DEFAULT}</code></td><td>如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 *</td></tr><tr><td><code>${var=DEFAULT}</code></td><td>如果var没有被声明, 那么就以$DEFAULT作为其值，跟上面<code>-</code>的区别在于会设置变量的值 *</td></tr><tr><td><code>${var:=DEFAULT}</code></td><td>如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 *</td></tr><tr><td><code>${var+OTHER}</code></td><td>如果var声明了, 那么其值就是$OTHER, 否则就为null字符串</td></tr><tr><td><code>${var:+OTHER}</code></td><td>如果var被设置了, 那么其值就是$OTHER, 否则就为null字符串</td></tr><tr><td><code>${var?ERR_MSG}</code></td><td>如果var没被声明, 那么就打印$ERR_MSG *</td></tr><tr><td><code>${var:?ERR_MSG}</code></td><td>如果var没被设置, 那么就打印$ERR_MSG *</td></tr><tr><td><code>${!varprefix*}</code></td><td>匹配之前所有以varprefix开头进行声明的变量</td></tr><tr><td><code>${!varprefix@}</code></td><td>匹配之前所有以varprefix开头进行声明的变量</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;shell基础语法&quot;&gt;&lt;a href=&quot;#shell基础语法&quot; class=&quot;headerlink&quot; title=&quot;shell基础语法&quot;&gt;&lt;/a&gt;shell基础语法&lt;/h3&gt;&lt;h4 id=&quot;if语句&quot;&gt;&lt;a href=&quot;#if语句&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="编程语言" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Linux" scheme="http://rivenzoo.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="http://rivenzoo.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Git Hooks</title>
    <link href="http://rivenzoo.github.io/2018/09/02/Git-Hooks/"/>
    <id>http://rivenzoo.github.io/2018/09/02/Git-Hooks/</id>
    <published>2018-09-01T16:48:50.000Z</published>
    <updated>2018-09-01T18:52:00.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-Hooks"><a href="#Git-Hooks" class="headerlink" title="Git Hooks"></a>Git Hooks</h2><p>git通过hooks来定制行为，所有的hooks存储在<code>hooks</code>目录，客户端是<code>.git/hooks</code>目录。<br><code>git init</code>的时候会在<code>.git/hooks</code>目录生成很多示例hook，只要重命名文件就能启用。</p><p>hook分为</p><ul><li>客户端hook</li><li>服务端hook</li></ul><p>客户端hook不会被克隆，如果要强制实现某个git策略，需要用服务端hook。</p><h3 id="客户端hook"><a href="#客户端hook" class="headerlink" title="客户端hook"></a>客户端hook</h3><p>客户端hook在工程目录下运行<br>客户端hook又可以分为</p><ul><li>committing-workflow</li><li>email-workflow</li><li>其他</li></ul><h4 id="committing-workflow"><a href="#committing-workflow" class="headerlink" title="committing-workflow"></a>committing-workflow</h4><ul><li><p>pre-commit</p><p>  第一个运行的hook，在创建提交message之前就运行。<br>  返回非0则终止提交，但是可以用<code>git commit --no-verify</code>来跳过检查。<br>  可以在这个hook中运行测试，检查代码格式，做代码静态检查等。</p></li><li><p>prepare-commit-msg</p><p>  在默认commit message创建之后，打开message编辑器之前运行。<br>  会传入几个参数：当前消息文件路径、commit类型，如果是amend提交再加上commit的SHA-1。<br>  一般用来生成自动提交的信息。</p></li><li><p>commit-msg</p><p>  编辑完提交消息之后运行。<br>  传入一个参数：保存用户提交消息的临时文件的路径。<br>  返回非0终止提交。<br>  一般用来验证消息格式。</p></li><li><p>post-commit    </p><p>  提交完成之后运行。<br>  一般用来做提交通知。</p></li></ul><h4 id="email-workflow-hooks"><a href="#email-workflow-hooks" class="headerlink" title="email-workflow hooks"></a>email-workflow hooks</h4><p>通过<code>git am</code>命令调用，如果你需要通过email来接收patch，可能会用到这个类型的hook。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>pre-rebase</p><p>  rebase之前运行。<br>  返回非0终止rebase。</p></li><li><p>post-rewrite</p><p>  <code>git commit --amend</code>和<code>git rebase</code>会触发这个hook。<br>  传入参数：触发hook的命令。</p></li><li><p>post-checkout</p><p>  checkout成功之后运行。</p></li><li><p>post-merge</p><p>  merge成功之后运行。</p></li><li><p>pre-push</p><p>  remote ref更新之后，传输对象之前运行。<br>  返回非0终止push。<br>  传入参数：远端的名称和地址。</p></li><li><p>pre-auto-gc</p><p>  由<code>git gc --auto</code>触发。</p></li></ul><h3 id="服务端hook"><a href="#服务端hook" class="headerlink" title="服务端hook"></a>服务端hook</h3><p>服务端hook在服务器的工程<code>.git</code>目录下运行</p><ul><li><p>pre-receive</p><p>  服务端接收push第一个运行的hook，从stdin接收被push过来的references。<br>  返回非0则终止push。</p></li><li><p>update</p><p>  类似pre-receive，但是每个分支运行一次。<br>  传入三个参数：分支名、前一个commit的SHA-1，当前push的SHA-1<br>  返回非0则终止push。    </p></li><li><p>post-receive</p><p>  所有流程完成之后运行。<br>  跟pre-receive一样从stdin传入references。<br>  客户端等待这个脚本完成才断开连接。</p></li></ul><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" target="_blank" rel="noopener">https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks</a><br><a href="https://docs.gitlab.com/ee/administration/custom_hooks.html" target="_blank" rel="noopener">https://docs.gitlab.com/ee/administration/custom_hooks.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-Hooks&quot;&gt;&lt;a href=&quot;#Git-Hooks&quot; class=&quot;headerlink&quot; title=&quot;Git Hooks&quot;&gt;&lt;/a&gt;Git Hooks&lt;/h2&gt;&lt;p&gt;git通过hooks来定制行为，所有的hooks存储在&lt;code&gt;hooks&lt;/co
      
    
    </summary>
    
      <category term="git" scheme="http://rivenzoo.github.io/categories/git/"/>
    
    
      <category term="git hook" scheme="http://rivenzoo.github.io/tags/git-hook/"/>
    
  </entry>
  
  <entry>
    <title>Cpp Static Initialization Order Fiasco</title>
    <link href="http://rivenzoo.github.io/2017/01/20/Cpp-Static-initialization-order-fiasco/"/>
    <id>http://rivenzoo.github.io/2017/01/20/Cpp-Static-initialization-order-fiasco/</id>
    <published>2017-01-20T12:08:13.000Z</published>
    <updated>2017-01-20T14:04:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Static-initialization-order-fiasco"><a href="#Static-initialization-order-fiasco" class="headerlink" title="Static initialization order fiasco"></a>Static initialization order fiasco</h3><ul><li><p>Construct On First Use Idiom</p><ul><li><p>If the object does not need to be destructed, uses a static pointer.</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File x.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Fred.h"</span></span></span><br><span class="line"><span class="function">Fred&amp; <span class="title">x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Fred* ans = <span class="keyword">new</span> Fred();</span><br><span class="line">  <span class="keyword">return</span> *ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File Barney.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"Barney.h"</span></span></span><br><span class="line"><span class="symbol">Barney:</span>:Barney()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  x().goBowling();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This approach is that the Fred object is <strong>never destructed</strong>.<br>The Construct On First Use Idiom uses a pointer and intentionally leaks the object.</p></li><li><p>If you need to destruct the object and do not care the order of static objects deinitialization, uses a static object.</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File x.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Fred.h"</span></span></span><br><span class="line"><span class="function">Fred&amp; <span class="title">x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Fred ans;  <span class="comment">// was static Fred* ans = new Fred();</span></span><br><span class="line">  <span class="keyword">return</span> ans;       <span class="comment">// was return *ans;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  It does not leak the object, but <strong>it does not control the order of static deinitialization</strong>, so it is (very!) unsafe to use the object during static deinitialization, that is, from a destructor of another statically declared object.</p></li></ul></li><li><p>Nifty Counter</p><p>  It is a more complicated solution that solves problems mentioned above.</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STREAM_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STREAM_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stream</span> &#123;</span></span><br><span class="line">  Stream ();</span><br><span class="line">  ~Stream ();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> Stream&amp; stream; <span class="comment">// global stream object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">StreamInitializer</span> &#123;</span></span><br><span class="line">  StreamInitializer ();</span><br><span class="line">  ~StreamInitializer ();</span><br><span class="line">&#125; streamInitializer; <span class="comment">// static initializer for every translation unit</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STREAM_H</span></span></span><br></pre></td></tr></table></figure>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Stream.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;         // placement new</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt; // aligned_storage</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nifty_counter; <span class="comment">// zero initialized at load time</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">typename</span> std::aligned_storage&lt;<span class="keyword">sizeof</span> (<span class="built_in">Stream</span>), <span class="keyword">alignof</span> (<span class="built_in">Stream</span>)&gt;::type</span><br><span class="line">  stream_buf; <span class="comment">// memory for the stream object</span></span><br><span class="line"><span class="built_in">Stream</span>&amp; stream = <span class="keyword">reinterpret_cast</span>&lt;<span class="built_in">Stream</span>&amp;&gt; (stream_buf);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Stream</span>::<span class="built_in">Stream</span> ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// initialize things</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Stream</span>::~<span class="built_in">Stream</span> ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// clean-up</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">StreamInitializer::StreamInitializer ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">if</span> (nifty_counter++ == <span class="number">0</span>) <span class="keyword">new</span> (&amp;stream) <span class="built_in">Stream</span> (); <span class="comment">// placement new</span></span><br><span class="line">&#125;</span><br><span class="line">StreamInitializer::~StreamInitializer ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">if</span> (--nifty_counter == <span class="number">0</span>) (&amp;stream)-&gt;~<span class="built_in">Stream</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  The header file of the Stream class <strong>must be included before any member function can be called on the Stream object</strong>.<br>  An instance of the StreamInitializer class is included in each compilation unit. Any use of the Stream object follows the inclusion of the header, which ensures that the constructor of the initializer object is called before the Stream object is used.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Static-initialization-order-fiasco&quot;&gt;&lt;a href=&quot;#Static-initialization-order-fiasco&quot; class=&quot;headerlink&quot; title=&quot;Static initialization or
      
    
    </summary>
    
      <category term="编程语言" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://rivenzoo.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>go-doc-tips</title>
    <link href="http://rivenzoo.github.io/2016/12/18/go-doc-tips/"/>
    <id>http://rivenzoo.github.io/2016/12/18/go-doc-tips/</id>
    <published>2016-12-18T13:57:03.000Z</published>
    <updated>2016-12-18T14:01:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go-doc-tips"><a href="#Go-doc-tips" class="headerlink" title="Go doc tips"></a>Go doc tips</h3><ol><li><p>新建<code>doc.go</code>作为文档文件，<code>package pkgname</code>之前的注释作为文档。</p></li><li><p>文档注释的格式</p><ol><li>相邻的行位于同一段落，分段需要添加空行</li><li>上下空行的短语会被作为接下来段落的head</li><li>预先格式化的文本需要跟周围的注释保持缩进</li><li>URL会被转换成链接，不需要标记</li></ol></li><li><p>Go同一个目录可以添加<code>{pkg}_test</code>的测试包。</p></li><li><p>包<code>{pkg}_test</code>的文件(<code>_test.go</code>结尾)，函数名以<code>Example</code>开头且没有参数的函数作为示例代码。</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleFoo</span><span class="params">()</span></span>     <span class="comment">// documents the Foo function or type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleBar_Qux</span><span class="params">()</span></span> <span class="comment">// documents the Qux method of type Bar</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example</span><span class="params">()</span></span>        <span class="comment">// documents the package as a whole</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleReverse</span><span class="params">()</span></span> <span class="comment">// Reverse first example</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleReverse_second</span><span class="params">()</span></span> <span class="comment">// Reverse second example</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleReverse_third</span><span class="params">()</span></span> <span class="comment">// Reverse thirdß example</span></span><br></pre></td></tr></table></figure><p> <code>_test.go</code>结尾的文件，如果只包含一个<code>Example</code>函数，并且有其他包级声明，整个文件会作为示例代码显示。</p></li><li><p><code>// Output: olleh</code>预期输出，示例函数可以作为<code>go test</code>的测试用例。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stringutil_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/golang/example/stringutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleReverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(stringutil.Reverse(<span class="string">"hello"</span>))</span><br><span class="line">    <span class="comment">// Output: olleh</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Go-doc-tips&quot;&gt;&lt;a href=&quot;#Go-doc-tips&quot; class=&quot;headerlink&quot; title=&quot;Go doc tips&quot;&gt;&lt;/a&gt;Go doc tips&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;新建&lt;code&gt;doc.go&lt;/code&gt;作为文档
      
    
    </summary>
    
      <category term="编程语言" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Go" scheme="http://rivenzoo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>vim-shortcut</title>
    <link href="http://rivenzoo.github.io/2016/12/12/vim-shortcut/"/>
    <id>http://rivenzoo.github.io/2016/12/12/vim-shortcut/</id>
    <published>2016-12-12T12:17:08.000Z</published>
    <updated>2016-12-11T16:25:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vim快捷键"><a href="#vim快捷键" class="headerlink" title="vim快捷键"></a>vim快捷键</h3><h4 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h4><ol><li><p>行内跳转 </p><p> <code>^</code> 行开头<br> <code>$</code> 行尾<br> <code>w/W</code> 下一个单词开头<br> <code>e/E</code> 下一个单词末尾<br> <code>b/B</code> 上一个单词开头<br> <code>f+{字符}</code> 下一个字符本身 <code>F+{字符}</code> 上一个字符本身<br> <code>t+{字符}</code> 下一个字符之后 <code>T+{字符}</code> 上一个字符之后</p></li></ol><ol start="2"><li><p>跨行跳转</p><p> <code>h</code> 左 <code>j</code> 下 <code>k</code> 上 <code>l</code> 右<br> <code>{数字}+h/j/k/l</code> 跳转n个位置<br> <code>{数字}+G</code> 跳转到第n行<br> <code>*</code> 向下搜索光标对应单词<br> <code>#</code> 向上搜索光标对应单词<br> <code>gg</code> 文件开头<br> <code>G</code> 文件末尾<br> <code>ctrl+b</code> 向上翻页<br> <code>ctrl+f</code> 向下翻页<br> <code>ctrl+u</code> 向上翻半页<br> <code>ctrl+d</code> 向下翻半页<br> <code>ctrl+o</code> 跳转到光标上一个位置<br> <code>ctrl+i</code> 跳转到光标下一个位置</p></li></ol><h4 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h4><ol><li><p>行内编辑</p><p> <code>x</code> 删除一个字符<br> <code>{数字}+x</code> 删除n个字符<br> <code>dd</code> 删除一行，包括换行<br> <code>d+{数字}+d</code> / <code>{数字}+dd</code> 删除n行<br> <code>d+w/W</code> / <code>d+e/E</code> 向后删除一个单词<br> <code>d+b/B</code> 向前删除一个单词<br> <code>D</code> / <code>d+$</code> 删除光标之后所有字符，不包括换行<br> <code>i</code> 光标之前插入<br> <code>a</code> 光标之后插入<br> <code>r</code> 替换光标处字符<br> <code>{数字}+r</code>    替换光标开始n个字符<br> <code>o</code> 插入下一行，光标跳转到新行<br> <code>O</code> 插入上一行，光标跳转到新行</p></li><li><p>复制粘贴</p><p> <code>yy</code> 复制一行<br> <code>{数字}+yy</code> / <code>y+{数字}+y</code> 复制n行<br> <code>y+{位置}+y</code> 复制光标与某一行直接的内容<br> <code>y+w/W</code> / <code>y+e/E</code> 向后复制一个单词<br> <code>y+b/B</code> 向前复制一个单词<br> <code>p</code> 在光标后粘贴<br> <code>P</code> 在光标前粘贴<br> <code>{数字}+p</code> 多次粘贴</p></li></ol><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ol><li><p>常规模式</p><p> <code>:h registers</code> 查看man page<br> <code>&quot;+{寄存器名}</code> 引用一个寄存器<br> <code>&quot;&quot;</code> 未命名寄存器，复制或删除都会替换它的内容<br> <code>&quot;0~&quot;9</code> <code>&quot;0</code> 保存最后一次复制内容 <code>&quot;1</code>~<code>&quot;9</code> 保存最后删除的内容，<code>&quot;1</code>为最近删除<br> <code>&quot;+{寄存器名}+y</code> 复制到指定寄存器<br> <code>&quot;+{寄存器名}+p</code> 粘贴指定寄存器内容<br> <code>:reg {寄存器名}</code> 查看寄存器内容<br> <code>&quot;.</code> <code>&quot;%</code> <code>&quot;:</code> <code>&quot;#</code> 只读寄存器</p><blockquote></blockquote><p> <code>&quot;.</code>存最后插入的内容；<code>&quot;%</code>存当前文件相对于vim打开时的路径；<code>&quot;:</code>存最后执行的命令，使用<code>@:</code>重复执行上一次命令；<code>&quot;#</code>存替换文件名</p><p> <code>&quot;=</code>保存表达式或命令结果，<code>ctrl-r =</code>可以在插入模式下粘贴结果，<code>:%s/&lt;Ctrl-r&gt;/something/g</code>可以直接替换之前搜索的结果<br> <code>:let @{寄存器名}=&#39;&lt;Ctrl-r {寄存器名}&gt;&#39;</code> 可以修改寄存器内容</p></li><li><p>编辑模式 </p><p> <code>ctrl+r+{寄存器名}</code> 粘贴寄存器内容</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vim快捷键&quot;&gt;&lt;a href=&quot;#vim快捷键&quot; class=&quot;headerlink&quot; title=&quot;vim快捷键&quot;&gt;&lt;/a&gt;vim快捷键&lt;/h3&gt;&lt;h4 id=&quot;跳转&quot;&gt;&lt;a href=&quot;#跳转&quot; class=&quot;headerlink&quot; title=&quot;跳转&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="编程工具" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Vim" scheme="http://rivenzoo.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>ssh-settings</title>
    <link href="http://rivenzoo.github.io/2016/05/24/ssh-settings/"/>
    <id>http://rivenzoo.github.io/2016/05/24/ssh-settings/</id>
    <published>2016-05-24T14:58:05.000Z</published>
    <updated>2016-06-13T15:41:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="记一下平时用到的有用的ssh设置和命令"><a href="#记一下平时用到的有用的ssh设置和命令" class="headerlink" title="记一下平时用到的有用的ssh设置和命令"></a>记一下平时用到的有用的ssh设置和命令</h4><ol><li><p>设置防止自动断开<br><code>ssh user@host -o ServerAliveInterval=30</code><br><code>-o</code>可以设置很多选项，<code>ServerAliveInterval</code>设置隔多少秒没收到数据之后，给对方发送消息请求响应，防止连接被中断</p></li><li><p>公钥验证免密码登陆<br>服务端设置: 修改 <code>/etc/ssh/sshd_config</code>，设置 <code>RSAAuthentication yes</code>，重启ssh服务<br>本机: 生成公钥 <code>$ ssh-keygen</code>，上传公钥 <code>$ ssh user@host &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></p></li><li><p>利用session clone来打开多个会话<br>本机: 修改 <code>~/.ssh/config</code>文件，加入下面内容</p><pre><code>#file:~/.ssh/configHost *ControlMaster autoControlPath ~/.ssh/master-%r@%h:%pControlPersist 10m</code></pre><p> 上面的配置在第一次建立ssh连接的时候把连接作为master，后面的连接都会复用第一次建立的网络连接，通过ControlPath下面的文件来确定复用哪个。只要第一个连接不中断，后面ssh命令就可以不输入密码直接连接了。</p></li><li><p>利用tmux和session clone实现免密码登录<br>找一台私人服务器，按照上面3步骤配置ssh的session clone<br>创建tmux session: <code>tmux new -s session</code><br>在tmux里面登录: <code>ssh user@host -o ServerAliveInterval=30</code><br>这样你打开新的tmux窗口直接ssh就不需要密码了<br>终端退出tmux: <code>ctrl-b &amp;</code>关闭窗口, <code>ctrl-b d</code>detach tmux client，这样tmux session的进程并不会退出，里面登录的ssh session也会保存下来<br>重新登录: <code>tmux attach -t session</code>attach client，原来登录的ssh session可以继续使用<br>登出服务器: 终端退出tmux后把tmux转到后台，假设1号job是tmux执行<code>disown %1</code>，如果进程被挂起需要执行<code>kill -cont -42813</code>，42813是tmux的pid</p></li><li><p>本地端口转发<br><code>$ ssh -NT -D 8080 host</code></p></li><li><p>python自动ssh登录<br>利用下面两个库可以实现自动ssh登录<br><code>pexpect</code>模拟shell输入<br><code>pyotp</code>进行otp验证</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;记一下平时用到的有用的ssh设置和命令&quot;&gt;&lt;a href=&quot;#记一下平时用到的有用的ssh设置和命令&quot; class=&quot;headerlink&quot; title=&quot;记一下平时用到的有用的ssh设置和命令&quot;&gt;&lt;/a&gt;记一下平时用到的有用的ssh设置和命令&lt;/h4&gt;&lt;ol&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="http://rivenzoo.github.io/categories/Linux/"/>
    
    
      <category term="SSH" scheme="http://rivenzoo.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>Go使用Rsa加解密</title>
    <link href="http://rivenzoo.github.io/2016/04/15/go-rsa-notes/"/>
    <id>http://rivenzoo.github.io/2016/04/15/go-rsa-notes/</id>
    <published>2016-04-15T15:05:18.000Z</published>
    <updated>2016-04-17T08:07:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一次使用rsa的经历"><a href="#一次使用rsa的经历" class="headerlink" title="一次使用rsa的经历"></a>一次使用rsa的经历</h3><p>   最近项目中要提供一个接口供客户端查询信息。逻辑简单主要考虑安全性问题，信息保密要求不高但是要保证是服务端返回的，也就是要防止数据被篡改和替换。</p><p>   因为只有一个这样的接口，而且申请证书比较麻烦就不考虑https了。客户端的安全性不是很可靠，如果用AES这样的对称加密，密钥放客户端会有较大风险。考虑用rsa加密来达到目的。</p><p>   初步想法是服务端保存rsa私钥，用来加密数据，客户端保存公钥，解密服务端返回的数据，这样客户端只能解服务端返回的数据，而且是密文传输。想法很简单，实现起来就遇到了问题。Go语言的rsa包提供的解密方法只能使用公钥加密。</p><p>   函数原型<br>    <code>func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err error)</code></p><p>   试验半天还是不知道如何使用私钥加密。Go论坛上有个使用私钥加密的讨论<a href="https://groups.google.com/d/msg/golang-nuts/SkOBSsqLsrE/5rLo02hutbwJ" target="_blank" rel="noopener">https://groups.google.com/d/msg/golang-nuts/SkOBSsqLsrE/5rLo02hutbwJ</a>，大概的意思是公钥大家都能拿到，用私钥加密的信息并没有起到保密的作用，一般私钥只用来签名。虽然理论上私钥加密是可以的，但在这里只好换一个思路。</p><p>   在这个场景中，签名可以达到要求，用私钥对关键信息签名，客户端用公钥校验，可以保证接受正确的服务端信息，唯一不太好的是明文传输的，需要引入一个对称加密对消息加密。</p><p>   要引入对称加密，可以由客户端随机生成key，用这个key对称加密带校验信息的数据，然后用公钥加密key，这样只有服务端能解出key。然后服务端把客户端带上来的校验信息和数据打包，使用这个key进行对称加密再返回，客户端用自己生成的key解密并校验数据。这样一个流程能保证接受正确的服务端信息，同时是密文传输。</p><p>   公钥是放在客户端的，假如被其他人拿到，破解了查询协议，最多只能查到数据。要伪造数据去欺骗其他客户端，必须同时知道其他客户端生成的key和校验信息，才能用伪造的请求的结果去欺骗这个客户端。若是AES的key泄漏，不但能查到数据，还能构造其他客户端的查询结果。</p><h3 id="rsa使用笔记"><a href="#rsa使用笔记" class="headerlink" title="rsa使用笔记"></a>rsa使用笔记</h3><p>   在跟客户端对接的过程中由于对rsa不是很熟悉，遇到了一些问题。</p><ol><li><p>padding模式<br>  rsa遵循公钥加密标准(Public Key Cryptography Standards, PKCS)，老的是1.x，一般用1.5，新的是2。对应的padding模式有三种：PKCS1V15对应v1.5，OAEP对应v2，Nopadding。Go的rsa库有前面两种，推荐使用OAEP。</p></li><li><p>hash算法<br>  Go的rsa库提供hash函数的参数，可以自己设置hash函数，推荐使用sha256。不同hash值的长度会影响OAEP模式下最大消息长度，下面会讲到。加解密的hash函数要设置成一样的，客户端使用的比较旧的openssl使用的sha1，跟我设置的不一样，因为这个调试了很久。对比了一下sha256和md5，md5要快一点。</p></li><li><p>消息长度<br>  每次加解密的消息长度有限制。对于v1.5，最大长度为<code>keyBytes-11</code>，<code>keyBytes</code>是私钥字节数，比如2048位的私钥就是256字节。对于v2，最大长度为<code>keyBytes-(hashSize*2+2)</code>，根据hash函数不同长度不同，比如sha1计算结果20字节，对于2048位的key最大长度<code>256-(20*2+2)</code>。<br>  如果原文超过了这个一般就分块进行加密。</p></li></ol><h3 id="rsa简介"><a href="#rsa简介" class="headerlink" title="rsa简介"></a>rsa简介</h3><ol><li><p>选择质数<code>p</code>和<code>q</code>，计算<code>n=p*q</code>，欧拉函数<code>φ(n)=(p-1)*(q-1)</code></p></li><li><p>随机选择一个整数<code>e</code>，条件是<code>1&lt; e &lt; φ(n)</code>，且<code>e</code>与<code>φ(n)</code>互质，计算模反元素<code>d</code>，即<code>(e*d)mod(φ(n))=1</code></p></li><li><p>经过上面两步得到<code>p、q、n、e、d</code>五个数，把<code>n、e</code>作为公钥，<code>n、d</code>作为私钥进行加解密。</p><ul><li>加密：消息<code>m</code>，<code>m&lt;n</code>，计算<code>(pow(m,e))mod(n)=c</code>，<code>c</code>就是<code>m</code>的密文</li><li>解密：密文<code>c</code>，计算<code>(pow(c,d)mod(n))=m</code></li><li>对于<code>m&gt;=n</code>，可以分块加密或者使用对称加密<code>m</code>然后公钥加密对称加密密钥</li></ul><p>算法的安全性保证在于很难从<code>n</code>和<code>e</code>推断出<code>d</code>，计算<code>d</code>需要知道<code>φ(n)</code>，而当<code>n</code>值很大的时候，直接计算<code>φ(n)</code>很困难，分解<code>n</code>得到<code>p、q</code>也很困难。</p><p>rsa原理的介绍推荐阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">文章</a>。</p></li></ol><h3 id="Go语言rsa简单封装"><a href="#Go语言rsa简单封装" class="headerlink" title="Go语言rsa简单封装"></a>Go语言rsa简单封装</h3><p>   为了方便使用做了个简单封装，放在Github上。</p><p>   安装方法<br>    <code>go get github.com/RivenZoo/goutil/dencrypt</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一次使用rsa的经历&quot;&gt;&lt;a href=&quot;#一次使用rsa的经历&quot; class=&quot;headerlink&quot; title=&quot;一次使用rsa的经历&quot;&gt;&lt;/a&gt;一次使用rsa的经历&lt;/h3&gt;&lt;p&gt;   最近项目中要提供一个接口供客户端查询信息。逻辑简单主要考虑安全性问题，
      
    
    </summary>
    
      <category term="编程语言" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="安全" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Go" scheme="http://rivenzoo.github.io/tags/Go/"/>
    
      <category term="Rsa" scheme="http://rivenzoo.github.io/tags/Rsa/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu Mount NTFS with system boot</title>
    <link href="http://rivenzoo.github.io/2015/10/10/ubuntu-mount-ntfs/"/>
    <id>http://rivenzoo.github.io/2015/10/10/ubuntu-mount-ntfs/</id>
    <published>2015-10-10T03:14:23.000Z</published>
    <updated>2016-04-01T12:01:46.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu14.<span class="number">04</span></span><br><span class="line"></span><br><span class="line">$ vim <span class="regexp">/etc/</span>fstab</span><br><span class="line"></span><br><span class="line"><span class="regexp">/dev/</span>sda2 <span class="regexp">/media ntfs auto,user,rw,async,exec 0 0 # 加exec选项才可以执行挂载目录内的程序，相当于 mount -t ntfs /</span>dev<span class="regexp">/sda2 /m</span>edia -o exec</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight awk&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://rivenzoo.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="http://rivenzoo.github.io/tags/Ubuntu/"/>
    
      <category term="NTFS" scheme="http://rivenzoo.github.io/tags/NTFS/"/>
    
  </entry>
  
  <entry>
    <title>Go Notes</title>
    <link href="http://rivenzoo.github.io/2015/09/19/go-notes/"/>
    <id>http://rivenzoo.github.io/2015/09/19/go-notes/</id>
    <published>2015-09-18T17:07:10.000Z</published>
    <updated>2016-04-01T10:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p>   <code>go test -v -run=[pattern]</code></p><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><p>   <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t]</code></p><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>race:</p><p>  <code>go test -v -run=[pattern] -race</code></p></li><li><p>cpu:</p><p>  <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t] -cpuprofile=[output]</code></p></li><li><p>mem:</p><p>  <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t] -memprofile=[output]</code></p></li><li><p>block:</p><p>  <code>go test -v -run=bench -bench=[pattern] -cpu=[n] -benchtime=[t] -blockprofile=[output]</code></p><p>  <code>go tool pprof [program].test [output]</code></p></li></ul><h3 id="GODEBUG"><a href="#GODEBUG" class="headerlink" title="GODEBUG"></a>GODEBUG</h3><p>   runtime提供了环境变量来控制程序。GODEBUG是其中一，它可以设置很多值，格式<code>name=value,name=val</code>，如开启gctrace：<code>$ GODEBUG=&#39;gctrace=1&#39; your_program</code>，会在标准错误输出gc信息。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>   推荐使用<a href="https://github.com/pquerna/ffjson" target="_blank" rel="noopener">ffjson</a><br>   用它替换标准库后，编解码效率提高2倍。对于一些需要编码的大对象，可以采用sync.Pool缓存一定大小的bytes.Buffer，然后直接写buffer来完成json编码，性能有一定提高，在我笔记本上测10*1024的字符串数组，大概比标准json快20%，结果受到分配buffer大小的影响。在对json对象编码的时候，如果有字符串字段，并且字符串可能出现json格式用到的字符，最好预先对字符串编码，否则json编码的时候处理字符串转义会导致性能下降，如果字符串很长，可能会成为瓶颈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Test&quot;&gt;&lt;a href=&quot;#Test&quot; class=&quot;headerlink&quot; title=&quot;Test&quot;&gt;&lt;/a&gt;Test&lt;/h3&gt;&lt;p&gt;   &lt;code&gt;go test -v -run=[pattern]&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;Benchmar
      
    
    </summary>
    
      <category term="编程语言" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Go" scheme="http://rivenzoo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>PythonBrew</title>
    <link href="http://rivenzoo.github.io/2015/04/15/python-brew/"/>
    <id>http://rivenzoo.github.io/2015/04/15/python-brew/</id>
    <published>2015-04-15T11:44:00.000Z</published>
    <updated>2016-05-24T15:00:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><p>pythonbrew作者弃坑了，推荐了另外一个项目<a href="https://github.com/yyuu/pyenv" target="_blank" rel="noopener">https://github.com/yyuu/pyenv</a><br>功能跟这个有重叠，貌似更强大，用的人也更多</p><h3 id="pythonbrew多版本管理工具"><a href="#pythonbrew多版本管理工具" class="headerlink" title="pythonbrew多版本管理工具"></a>pythonbrew多版本管理工具</h3><p>pythonbrew是一个python版本管理的工具，具体命令见<a href="http://pythonbrew.readthedocs.org/en/latest/" target="_blank" rel="noopener">http://pythonbrew.readthedocs.org/en/latest/</a>。</p><h4 id="pythonbrew-install-2-5-6-的问题"><a href="#pythonbrew-install-2-5-6-的问题" class="headerlink" title="pythonbrew install 2.5.6 的问题"></a>pythonbrew install 2.5.6 的问题</h4><p>在安装python 2.5.6的时候遇到编译错误<code>make: *** [Modules/getbuildinfo.o] error 1</code>，参考了<a href="http://askubuntu.com/questions/398481/make-python2-5-failed-on-ubuntu-13-04" target="_blank" rel="noopener">http://askubuntu.com/questions/398481/make-python2-5-failed-on-ubuntu-13-04</a>这里的解决方法。<br>在python 2.5.6下载解压后的目录<br><code>/HOME/.pythonbrew/build/Python-2.5.6</code>，<br>手动执行<br><code>SVNVERSION=not-found ./configure --prefix=/HOME/.pythonbrew/pythons/Python-2.5.6</code>，<br>把python2.5.6安装到了pythonbrew预定的目录就可以了。</p><p>pythonbrew管理虚拟环境</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pythonbrew venv init</span><br><span class="line">$ pythonbrew venv create proj -<span class="selector-tag">p</span> x<span class="selector-class">.x</span><span class="selector-class">.x</span></span><br></pre></td></tr></table></figure><p>以上2步就创建了一个可用的虚拟环境，然后到需要环境的工程，执行<code>pythonbrew venv use proj</code>就可以使用之前创建的虚拟环境了。</p><h5 id="ps-pythonbrew有个别名pybrew。"><a href="#ps-pythonbrew有个别名pybrew。" class="headerlink" title="ps:pythonbrew有个别名pybrew。"></a>ps:pythonbrew有个别名pybrew。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Warning&quot;&gt;&lt;a href=&quot;#Warning&quot; class=&quot;headerlink&quot; title=&quot;Warning&quot;&gt;&lt;/a&gt;Warning&lt;/h3&gt;&lt;p&gt;pythonbrew作者弃坑了，推荐了另外一个项目&lt;a href=&quot;https://github.c
      
    
    </summary>
    
      <category term="编程语言" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://rivenzoo.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Take a look at Level source code</title>
    <link href="http://rivenzoo.github.io/2015/03/08/leveldb-source-1/"/>
    <id>http://rivenzoo.github.io/2015/03/08/leveldb-source-1/</id>
    <published>2015-03-08T13:32:02.000Z</published>
    <updated>2020-03-28T12:36:31.072Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一点leveldb源码，了解一下实现机制。</p><p>之前也看过leveldb相关介绍以及别人的分析blog，已经有了一定了解。leveldb如其名，按照层级来组织数据，数据从内存到磁盘一层一层迁移。在内存中是通过skiplist来管理数据，而磁盘上则是一种名为SSTable(Sorted Strings Table)的结构来存储数据的。</p><a id="more"></a><h5 id="DB-Get实现"><a href="#DB-Get实现" class="headerlink" title="DB::Get实现"></a>DB::Get实现</h5><p>这个头文件include/leveldb/db.h定义了DB抽象类，Get接口也在其中，具体实现在db/db_impl.cc文件中。<br>下面引用的代码因为篇幅会删除一些代码行，完整代码参考源文件。 </p><p>代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Get(<span class="keyword">const</span> ReadOptions&amp; options,</span><br><span class="line">                   <span class="keyword">const</span> Slice&amp; key,</span><br><span class="line">                   std::string* value) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  MutexLock l(&amp;mutex_);</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    LookupKey lkey(key, snapshot);</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="keyword">NULL</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = current-&gt;Get(options, lkey, value, &amp;stats);</span><br><span class="line">      have_stat_update = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) &#123;</span><br><span class="line">    MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是Get的实现函数，省略了一些代码。Get主要的查询过程在中间if-else语句分支中。在查询之前<code>mutex_.Unlock();</code>进行了解锁，是因为数据是只追加不删除的，可以同时读写。数据删除会转换成一条标记key-deleted的数据追加到库中。 </p><p>SequenceNumber snapshot为数据序号，每一条数据都有序号，后追加的序号比之前的序号要大，相同key的数据，序号大的要排在前面，参见<code>db/dbformat.cc</code> <code>InternalKeyComparator::Compare</code>函数。 </p><p>第一个分支mem指向一个MemTable，MemTable只有Add和Get两个接口来操作数据，底层实现为skiplist，这个mem指向可修改的MemTable。 </p><p>第二个分支imm指向一个不可修改的MemTable，imm是mem达到一定条件后转换来的，具体的逻辑在db/db_impl.cc DBImpl::MakeRoomForWrite函数中。 </p><p>前面2个分支都是在内存中进行查询，没找到就只能到磁盘上查询。最后一个分支current指向当前的Version，Version包含数据文件的元信息。 </p><p>最后根据情况调用MaybeScheduleCompaction函数，在后台对数据进行Compact，将内存的迁到磁盘，对磁盘上的数据进行合并等。</p><p>Version::Get实现。这个函数就是上一节最后一个if分支调用的函数，也是查询磁盘数据的入口。 </p><p>代码:</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Status Version::Get(<span class="keyword">const</span> ReadOptions&amp; options,</span><br><span class="line">                    <span class="keyword">const</span> LookupKey&amp; k,</span><br><span class="line">                    std::string* value,</span><br><span class="line">                    GetStats* stats) &#123;      </span><br><span class="line">  ...       </span><br><span class="line">  <span class="comment">// We can search level-by-level since entries never hop across</span></span><br><span class="line">  <span class="comment">// levels.  Therefore we are guaranteed that if we find data</span></span><br><span class="line">  <span class="comment">// in an smaller level, later levels are irrelevant.</span></span><br><span class="line">  std::vector&lt;FileMetaData*&gt; tmp;</span><br><span class="line">  FileMetaData* tmp2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    size_t num_files = files_[level].size();</span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the list of files to search in this level</span></span><br><span class="line">    FileMetaData* <span class="keyword">const</span>* files = &amp;files_[level][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Level-0 files may overlap each other.  Find all files that</span></span><br><span class="line">      <span class="comment">// overlap user_key and process them in order from newest to oldest.</span></span><br><span class="line">      tmp.reserve(num_files);</span><br><span class="line">      <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; num_files; i++) &#123;</span><br><span class="line">        FileMetaData* f = files[i];</span><br><span class="line">        <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          tmp.push_back(f);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (tmp.<span class="keyword">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::sort(tmp.begin(), tmp.end(), NewestFirst);</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Binary search to find earliest index whose largest key &gt;= ikey.</span></span><br><span class="line">      uint32_t index = FindFile(vset_-&gt;icmp_, files_[level], ikey);</span><br><span class="line">      <span class="keyword">if</span> (index &gt;= num_files) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp2 = files[index];</span><br><span class="line">        <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, tmp2-&gt;smallest.user_key()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// All of "tmp2" is past any data for user_key</span></span><br><span class="line">          ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          files = &amp;tmp2;</span><br><span class="line">          num_files = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; num_files; ++i) &#123;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">      FileMetaData* f = files[i];</span><br><span class="line">      last_file_read = f;</span><br><span class="line">      last_file_read_level = level;</span><br><span class="line"></span><br><span class="line">      Saver saver;</span><br><span class="line">      saver.state = kNotFound;</span><br><span class="line">      saver.ucmp = ucmp;</span><br><span class="line">      saver.user_key = user_key;</span><br><span class="line">      saver.value = value;</span><br><span class="line">      s = vset_-&gt;table_cache_-&gt;Get(options, f-&gt;number, f-&gt;file_size,</span><br><span class="line">                                   ikey, &amp;saver, SaveValue);</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="keyword">return</span> Status::NotFound(Slice());  <span class="comment">// Use an empty error message for speed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数主要是对每个level上的数据从低到高进行查询，比较新的数据放在低的level。 </p><p>主for循环所有level，先根据key查找符合要求的文件，由于Sstable是排序数据，每个文件都有key的范围，所以可以查找包含了查询key的文件即可。level-0和其他的level处理方式不太一样，level-0是直接遍历，而其他level调用FindFile进行查询。 </p><p>找到符合要求的文件之后，进入后一个for循环，通过vset_-&gt;table_cache_-&gt;Get查找所有的文件。</p><p>上面提到的FindFile使用internal_key即带序号的查询key在一层的文件中进行二分查找，找到离查询key最近且文件largest-key比查询key大的文件，如果key存在库的这一层中，那应该会落在这个文件。 </p><p>TableCache::Get比较简单，先调用了FindTable找到对应的Table对象，然后调用Table对象的InternalGet函数。下面说FindTable函数和Table::InternalGet函数。</p><p>FindTable函数 </p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Status TableCache::FindTable(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span><br><span class="line">                             Cache::Handle** handle) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(file_number)];</span><br><span class="line">  EncodeFixed64(buf, file_number);</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">(buf, <span class="keyword">sizeof</span>(buf))</span></span>;</span><br><span class="line"></span><br><span class="line">  *handle = cache_-&gt;Lookup(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br><span class="line">    RandomAccessFile* file = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = Table::Open(*options_, file, file_size, &amp;table);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TableAndFile* tf = <span class="keyword">new</span> TableAndFile;</span><br><span class="line">      tf-&gt;file = file;</span><br><span class="line">      tf-&gt;table = table;</span><br><span class="line">      *handle = cache_-&gt;Insert(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cache_-&gt;Lookup(key)先在cache中查找，cache_指向一个LRU的cache，缓存的内容为打开的文件对象和Table对象的指针，最后一个else语句块里cache_-&gt;Insert把要缓存的内容插入了缓存。 </p><p>若缓存中没有要找的Table则调用Table::Open打开文件载入Table对象，然后插入缓存。 </p><p>Table::Open代码:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="keyword">Table</span>::Open(const <span class="comment">Options&amp; options,</span></span><br><span class="line">               RandomAccessFile* file,</span><br><span class="line">               uint64_t size,</span><br><span class="line">               <span class="keyword">Table</span>** <span class="keyword">table</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  char footer_space[Footer::kEncodedLength];</span><br><span class="line">  Slice footer_input;</span><br><span class="line">  Status s = <span class="keyword">file</span>-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                        &amp;footer_input, footer_space);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    s = ReadBlock(<span class="keyword">file</span>, opt, footer.index_handle(), &amp;contents);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      index_block = new Block(contents);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// We've successfully read the footer and the index block: we're</span></span><br><span class="line">    <span class="comment">// ready to serve requests.</span></span><br><span class="line">    Rep* rep = new <span class="keyword">Table</span>::Rep;</span><br><span class="line">    rep-&gt;options = options;</span><br><span class="line">    rep-&gt;<span class="keyword">file</span> = <span class="keyword">file</span>;</span><br><span class="line">    rep-&gt;metaindex_handle = footer.metaindex_handle();</span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    rep-&gt;cache_id = (<span class="keyword">options</span>.block_cache ? <span class="keyword">options</span>.block_cache-&gt;NewId() : <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    *<span class="keyword">table</span> = new <span class="comment">Table(rep)</span>;</span><br><span class="line">    (*<span class="keyword">table</span>)-&gt;ReadMeta(footer);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;     </span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Table::Open把index-block的内容读出来缓存起来，如果有meta数据或filter数据，也会读出来并缓存。options.block_cache这个指针如果指向一个cache对象，后面在读入新的block的时候也会把block缓存起来。</p><p>Table::InternalGet </p><p>代码:</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Status Table::InternalGet(const ReadOptions&amp; options, const Slice&amp; k,</span><br><span class="line">                          void* arg,</span><br><span class="line">                          void (*saver)(void*, const Slice&amp;, const Slice&amp;)) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  I<span class="function"><span class="title">terator</span>* iiter = rep_-&gt;</span><span class="function"><span class="title">index_block</span>-&gt;</span>N<span class="function"><span class="title">ewIterator</span>(rep_-&gt;</span>options.comparator);</span><br><span class="line">  <span class="function"><span class="title">iiter</span>-&gt;</span>Seek(k);</span><br><span class="line">  <span class="function"><span class="title">if</span> (iiter-&gt;</span>Valid()) &#123;</span><br><span class="line">    S<span class="function"><span class="title">lice</span> handle_value = iiter-&gt;</span>value();</span><br><span class="line">    F<span class="function"><span class="title">ilterBlockReader</span>* filter = rep_-&gt;</span>filter;</span><br><span class="line">    BlockHandle handle;</span><br><span class="line">    <span class="keyword">if</span> (filter != NULL &amp;&amp;</span><br><span class="line">        handle.DecodeFrom(&amp;handle_value).ok() &amp;&amp;</span><br><span class="line">        !<span class="function"><span class="title">filter</span>-&gt;</span>KeyMayMatch(handle.offset(), k)) &#123;</span><br><span class="line">      <span class="comment">// Not found</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      I<span class="function"><span class="title">terator</span>* block_iter = BlockReader(this, options, iiter-&gt;</span>value());</span><br><span class="line">      <span class="function"><span class="title">block_iter</span>-&gt;</span>Seek(k);</span><br><span class="line">      <span class="function"><span class="title">if</span> (block_iter-&gt;</span>Valid()) &#123;</span><br><span class="line">        (*<span class="function"><span class="title">saver</span>)(arg, block_iter-&gt;</span><span class="function"><span class="title">key</span>(), block_iter-&gt;</span>value());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="title">s</span> = block_iter-&gt;</span>status();</span><br><span class="line">      delete block_iter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Table::InternalGet先在index-block中找到距离key最近的block，block也有key范围，查找过程和查找文件类似也是通过二分查找找到最近的block，但是index-block并不是所有block的索引，所以还需要进一步到block附近进行查找。 </p><p>如果找到key附近的block，就对block进行查找。先结合filter判断key是否不在，如不在直接返回NotFound。然后读index对应的block，进行二次查找。iter-&gt;Seek(k)具体可以参考table/block.cc Block::Iter::Seek函数，函数并没有进行相等比较，只能定位范围。由于iter-&gt;Seek(k)只能定位到key附近，所以需要调用(*saver)(arg, block_iter-&gt;key(), block_iter-&gt;value())，saver对应上文提到的db/version_set.cc SaveValue函数，代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveValue</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> Slice&amp; ikey, <span class="keyword">const</span> Slice&amp; v)</span> </span>&#123;</span><br><span class="line">  Saver* s = <span class="keyword">reinterpret_cast</span>&lt;Saver*&gt;(arg);</span><br><span class="line">  ParsedInternalKey parsed_key;</span><br><span class="line">  <span class="keyword">if</span> (!ParseInternalKey(ikey, &amp;parsed_key)) &#123;</span><br><span class="line">    s-&gt;state = kCorrupt;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;ucmp-&gt;Compare(parsed_key.user_key, s-&gt;user_key) == <span class="number">0</span>) &#123;</span><br><span class="line">      s-&gt;state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;</span><br><span class="line">      <span class="keyword">if</span> (s-&gt;state == kFound) &#123;</span><br><span class="line">        s-&gt;value-&gt;assign(v.data(), v.size());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据文件的编码格式比较复杂，就不写了，可以参考源文件或网络。 </p><p>以上就是Get的过程，流程还是比较长的。网上的测试结果表明leveldb的写性能高于读，跟它的磁盘查找关系很大，对于需要频繁随机读的应用还是要仔细考虑一下性能问题。打开block-cache可能会提高读性能，相应的就需要消耗内存，把文件放到ssd也是一个优化方案，没有具体实践，不知效果如何。 </p><p>欢迎指出本文的错误，也欢迎分享相关内容！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了一点leveldb源码，了解一下实现机制。&lt;/p&gt;
&lt;p&gt;之前也看过leveldb相关介绍以及别人的分析blog，已经有了一定了解。leveldb如其名，按照层级来组织数据，数据从内存到磁盘一层一层迁移。在内存中是通过skiplist来管理数据，而磁盘上则是一种名为SSTable(Sorted Strings Table)的结构来存储数据的。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://rivenzoo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="NoSQL" scheme="http://rivenzoo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/"/>
    
    
      <category term="C/C++" scheme="http://rivenzoo.github.io/tags/C-C/"/>
    
      <category term="Leveldb" scheme="http://rivenzoo.github.io/tags/Leveldb/"/>
    
  </entry>
  
  <entry>
    <title>Makefile获取依赖的源文件</title>
    <link href="http://rivenzoo.github.io/2015/03/07/makefile-source-dependency/"/>
    <id>http://rivenzoo.github.io/2015/03/07/makefile-source-dependency/</id>
    <published>2015-03-07T15:52:46.000Z</published>
    <updated>2017-03-10T14:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exclude=<span class="string">"_test"</span></span><br><span class="line"><span class="comment">#exclude="___"</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *[^<span class="variable">$(exclude)</span>].c ./subs/*.c)</span></span><br><span class="line"></span><br><span class="line">files=<span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(files)</span> )</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        @echo <span class="variable">$(src)</span></span><br><span class="line">        @echo <span class="variable">$(files)</span></span><br><span class="line">        @echo <span class="variable">$(obj)</span></span><br><span class="line">        @echo <span class="string">"end"</span></span><br></pre></td></tr></table></figure><p>wildcard通过通配符来匹配文件并将结果展开，第一个参数排除了_test.c的文件。<br>notdir去掉src中的目录，只保留文件名<br>patsubst进行替换，把.c换成.o<br>上面代码参考Makefile中的wildcard用法这篇blog，稍微修改了下。</p><h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>上面的代码</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exclude=<span class="string">"_test"</span></span><br><span class="line"><span class="comment">#exclude="___"</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *[^<span class="variable">$(exclude)</span>].c ./subs/*.c)</span></span><br></pre></td></tr></table></figure><p>其实有点问题，*[^$<em>test].c这个正则只能过滤.c之前是’</em>‘,’t’,’e’,’s’这4个字符的文件名，达不到想要的目的。<br>需要修改一下，对src进行替换</p><p><code>$(patsubst %_test.c,, $(src))</code></p><p>这样就把文件列表中含_test.c的去掉了。修改后为</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src :=<span class="variable">$(<span class="built_in">wildcard</span> *.c ./subs/*.c)</span></span><br><span class="line">src :=<span class="variable">$(<span class="built_in">patsubst</span> %_test.c,,<span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">files :=<span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">obj :=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(files)</span> )</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        @echo <span class="variable">$(src)</span></span><br><span class="line">        @echo <span class="variable">$(files)</span></span><br><span class="line">        @echo <span class="variable">$(obj)</span></span><br><span class="line">        @echo <span class="string">"end"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码：&lt;/p&gt;
&lt;figure class=&quot;highlight makefile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;
      
    
    </summary>
    
      <category term="编程语言" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://rivenzoo.github.io/tags/C-C/"/>
    
      <category term="Makefile" scheme="http://rivenzoo.github.io/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>C语言INT_MIN定义的问题</title>
    <link href="http://rivenzoo.github.io/2015/01/21/c-minint-define/"/>
    <id>http://rivenzoo.github.io/2015/01/21/c-minint-define/</id>
    <published>2015-01-20T16:33:54.000Z</published>
    <updated>2016-07-18T12:47:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于c语言INT_MIN定义的问题</p><p>最近看到一段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br></pre></td></tr></table></figure><p>INT_MIN的值应该为 -2147483648，为什么不直接定义呢？原因参考<a href="http://www.cnblogs.com/Jack47/archive/2013/01/06/TMin32-in-c.html" target="_blank" rel="noopener">Jack47的blog:C语言中TMin的写法</a>这篇文章。</p><p>个人理解为C语言在处理程序中常量时，符号-和后面的值是分开处理的，先处理字面值，然后将-作为一元运算符。处理字面值的时候会决定这个常量的类型，基本的规则是选能容纳字面值的最小类型。如32位系统，2147483648这个值决定为unsigned int，如果使用<code>#define INT_MIN (-2147483648)</code>这个定义，INT_MIN类型为unsigned int。</p><p>写了一段代码验证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TMIN is unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TMIN (-2147483648)        </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; TMIN) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d &gt; tmin\n"</span>, i);</span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d &lt; tmin\n"</span>, i);</span><br><span class="line">    <span class="keyword">if</span> (i &gt; INT_MIN)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d &gt;INT_MIN\n"</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(TMIN));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><blockquote></blockquote><p>1 &lt; tmin<br>1 &gt;INT_MIN<br>4</p><p>补充：</p><p>CSAPP的补充材料<a href="http://csapp.cs.cmu.edu/public/waside/waside-tmin.pdf" target="_blank" rel="noopener">waside-tmin.pdf</a></p><p>上面的例子说明了不同格式字面值在C90和C99下面的类型确定的规则，C90 32位下类型为unsigned，就会产生上面程序的结果。</p><p>对于这种会产生不同行为的代码最好避免.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于c语言INT_MIN定义的问题&lt;/p&gt;
&lt;p&gt;最近看到一段代码&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;sp
      
    
    </summary>
    
      <category term="编程语言" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://rivenzoo.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Notes About Kafka</title>
    <link href="http://rivenzoo.github.io/2014/09/21/notes-about-kafka/"/>
    <id>http://rivenzoo.github.io/2014/09/21/notes-about-kafka/</id>
    <published>2014-09-20T16:08:00.000Z</published>
    <updated>2016-04-01T12:15:52.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="consumer-offset-commit"><a href="#consumer-offset-commit" class="headerlink" title="consumer offset commit"></a>consumer offset commit</h5><p>使用kafka的python api时遇到了offset回滚的问题，因为最初使用了autocommit参数，发现有时会重复取记录，发现autocommit是批量提交，并且有offset回滚的问题，具体原因未发现，解决方法是手动调用commit函数提交，经过测试手动调用没有出现offset回滚的问题。</p><h5 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h5><p>一开始为了简单只使用了一个分区，consumer都从一个leader取数据，请求压力都在一台机器。使用不同分区策略可以分散topic的leader，还可以灵活处理不同数据。</p><h5 id="fetch-msg"><a href="#fetch-msg" class="headerlink" title="fetch msg"></a>fetch msg</h5><p>MaxWaitTime 请求最大等待时间，MinBytes 请求消息的最小字节数，通过这2个参数可以调整你获取数据时的等待策略，最简单的做法就是不等待，没数据直接返回。</p><h5 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h5><p>由于硬盘限制，把kafka和zookeeper的日志目录放在了同一个磁盘，而且磁盘的性能不是很好，造成了kafka写数据效率低下，每次写数据只有几百k。zookeeper网站上对这2个配置有Notes说不要把他们放在繁忙的磁盘设备上，会影响其他程序写磁盘的性能，最好这2个目录都分开存放不同设备。简单看了一下，dataDir下存的是snapshot文件，dataLogDir存的是log文件，应该是zookeeper把内存数据持久化到这2种文件中了，而且持久化操作很频繁且写的数据很少，会影响kafka写日志。</p><h5 id="磁盘参数"><a href="#磁盘参数" class="headerlink" title="磁盘参数"></a>磁盘参数</h5><p>在排查磁盘io高的问题时用到了<code>iostat -d -x</code>命令，在排查时主要关注w/s、wkB/s、rkB/s，对于扇区没怎么关注，rsec/s wsec/s avgrq-sz这几个参数反应磁盘操作扇区的情况，当磁盘利用率高且iowait高，而平均扇区低也就意味着磁盘把大量时间用于磁盘寻道，你可能需要考虑是不是有大量随机写磁盘的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;consumer-offset-commit&quot;&gt;&lt;a href=&quot;#consumer-offset-commit&quot; class=&quot;headerlink&quot; title=&quot;consumer offset commit&quot;&gt;&lt;/a&gt;consumer offset comm
      
    
    </summary>
    
      <category term="Linux" scheme="http://rivenzoo.github.io/categories/Linux/"/>
    
      <category term="消息中间件" scheme="http://rivenzoo.github.io/categories/Linux/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Kafka" scheme="http://rivenzoo.github.io/tags/Kafka/"/>
    
      <category term="Zookeeper" scheme="http://rivenzoo.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>重入与线程安全</title>
    <link href="http://rivenzoo.github.io/2013/11/22/about-thread-safe/"/>
    <id>http://rivenzoo.github.io/2013/11/22/about-thread-safe/</id>
    <published>2013-11-21T16:13:44.000Z</published>
    <updated>2016-09-24T07:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>在stackoverflow上看的的关于可重入与线程安全的区别：</p><blockquote><p>These functions are not reentrant. They are thread-safe. There’s a big difference. Functions that are reentrant are automatically thread-safe, but thread-safe functions can still deadlock (or worse) if called again from the same thread they’re already running in (for example from a signal handler).</p></blockquote><p>函数可重入很自然会觉得该函数是线程安全的，既然能被其他流程中断并可调用自身也就可以被多个线程同时调用。但是线程安全是不是可重入有点模糊，上面说了一种情况，当重复调用一个线程安全的函数，并且函数中有锁就有可能发生死锁，表明线程安全不一定可重入。看来重入的要求比线程安全要更严格一点。</p><p>附带查了查关于Posix的标准io操作，Posix标准要求操作字符流的函数实现为可重入，但是各个实现为了性能方面的考虑都没有实现为可重入的，这些函数有潜在不安全。但是又说明：</p><blockquote><p>all standard I/O functions that reference character streams shall behave as if they use flockfile() and funlockfile() internally to obtain ownership of the character streams</p></blockquote><p>表明它们应该是线程安全的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在stackoverflow上看的的关于可重入与线程安全的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;These functions are not reentrant. They are thread-safe. There’s a big difference. F
      
    
    </summary>
    
      <category term="编程语言" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://rivenzoo.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>自定义linux信号</title>
    <link href="http://rivenzoo.github.io/2013/11/05/define-linux-signal/"/>
    <id>http://rivenzoo.github.io/2013/11/05/define-linux-signal/</id>
    <published>2013-11-05T11:55:55.000Z</published>
    <updated>2016-07-18T12:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们需要在程序中利用信号来控制程序行为，linux为我们提供了2个已经定义的信号SIGUSR1和SIGUSR2，一般的程序利用这2个信号已经能满足需要，不过我最近需要一些其他信号来避免覆盖原来的信号处理函数。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSIG_MSG        (SIGUSR2 + 1)</span></span><br><span class="line"><span class="comment">// 定义信号然后注册处理函数</span></span><br></pre></td></tr></table></figure><p>然后到系统里查了一下，MYSIG_MSG其实将其他的信号给覆盖了<br><code>$kill -l</code></p><blockquote><p>10) SIGUSR1    11) SIGSEGV    12) SIGUSR2 13) SIGPIPE    14) SIGALRM </p></blockquote><p>虽然SIGPIPE和SIGALRM在这个程序中没有用到，但是这并不是我想要的效果。<br>我发现在后面有 </p><blockquote><p>34) SIGRTMIN 35) SIGRTMIN+1    36) SIGRTMIN+2 </p></blockquote><p><code>man 7 signal</code>页面同样也说明可以用 SIGRTMIN作为自定义信号。然后程序里就多了下面的代码： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSIG_MSG        (SIGRTMIN+ 1)</span></span><br></pre></td></tr></table></figure><p>结果出错了，但是并不是这个定义方式的问题。在我程序中有下面的代码： </p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch(signo)&#123;</span><br><span class="line">    <span class="keyword">case</span> MYSIG_MSG:</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">编译时才发现原来SIGRTMIN并不是一个常量，看了头文件里才知道：</span><br></pre></td></tr></table></figure><p>// centos5.9 /usr/include/bits/signum.h<br>#define SIGRTMIN        (__libc_current_sigrtmin ())</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">原来是函数调用，运行时确定的。 </span><br><span class="line">要用这个SIGRTMIN宏是不行，只能自己定义了：</span><br></pre></td></tr></table></figure><p>#define MYSIGRTMIN    34<br>#define MYSIG_MSG     (MYSIGRTMIN + 1)</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在找到系统定义的SIGRTMIN值之前，根据man <span class="number">7</span> signal里面的说明：</span><br><span class="line">&gt; Linux supports <span class="number">32</span> real-<span class="built_in">time</span> signals, numbered <span class="built_in">from</span> <span class="number">32</span> (SIGRTMIN) <span class="built_in">to</span> <span class="number">63</span> (SIGRTMAX). </span><br><span class="line">我把自定义的信号值定义成了<span class="number">32</span>，但是一直注册不了这个信号，后来赫然发现在 `man <span class="number">7</span> signal`下面有一行说明， </span><br><span class="line">&gt; However, <span class="keyword">the</span> glibc POSIX threads implementation internally uses <span class="literal">two</span> (<span class="keyword">for</span> NPTL) <span class="keyword">or</span> <span class="literal">three</span>  (<span class="keyword">for</span>  LinuxThreads)  real-<span class="built_in">time</span> signals  (see  pthreads(<span class="number">7</span>)), <span class="keyword">and</span> adjusts <span class="keyword">the</span> <span class="built_in">value</span> <span class="keyword">of</span> SIGRTMIN suitably (<span class="built_in">to</span> <span class="number">34</span> <span class="keyword">or</span> <span class="number">35</span>) </span><br><span class="line"></span><br><span class="line">这个说明在ubuntu12<span class="number">.04</span>里面看见的，估计centos也有类似的情况。同时头文件下面也有：</span><br></pre></td></tr></table></figure><p>/* These are the hard limits of the kernel.  These values should not be<br>used directly at user level.  */<br>#define __SIGRTMIN  32<br>#define __SIGRTMAX  (_NSIG - 1)</p><pre><code>改成34之后就没有问题了。不过这个方法不太可靠，程序不应该直接用常量标识信号. </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候我们需要在程序中利用信号来控制程序行为，linux为我们提供了2个已经定义的信号SIGUSR1和SIGUSR2，一般的程序利用这2个信号已经能满足需要，不过我最近需要一些其他信号来避免覆盖原来的信号处理函数。 &lt;/p&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="编程语言" scheme="http://rivenzoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://rivenzoo.github.io/tags/C-C/"/>
    
      <category term="Linux" scheme="http://rivenzoo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://rivenzoo.github.io/2013/09/01/hello-world/"/>
    <id>http://rivenzoo.github.io/2013/09/01/hello-world/</id>
    <published>2013-09-01T11:55:55.000Z</published>
    <updated>2016-04-01T12:36:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
